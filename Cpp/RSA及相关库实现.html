<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="退思园" type="application/atom+xml">
  <meta name="google-site-verification" content="EDvvZZUFkxy_QUzZTaqwsG_9VHqFthY-NhQE4j6WL-s">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'LHD9LWONQ3',
      apiKey: '23a113c49e36d8cc93f61239cb530b43',
      indexName: 'gowa.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="应大佬要求来了解一下 RSA 相关的东西，顺便了解一下 Crypto++ 对于 RSA 的实现。">
<meta name="keywords" content="Cpp,Crypto++">
<meta property="og:type" content="article">
<meta property="og:title" content="RSA及相关库实现">
<meta property="og:url" content="https://gowa.club/Cpp/RSA及相关库实现.html">
<meta property="og:site_name" content="退思园">
<meta property="og:description" content="应大佬要求来了解一下 RSA 相关的东西，顺便了解一下 Crypto++ 对于 RSA 的实现。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cryptopp.com/w/images/9/91/Private-key-info.png">
<meta property="og:image" content="https://cryptopp.com/w/images/7/7f/Public-key-info.png">
<meta property="og:image" content="https://cryptopp.com/w/images/thumb/6/65/Rsa-der-key.png/300px-Rsa-der-key.png">
<meta property="og:image" content="https://cryptopp.com/w/images/thumb/8/87/Rsa-raw-vs-cooked.png/300px-Rsa-raw-vs-cooked.png">
<meta property="og:image" content="https://cryptopp.com/w/images/7/77/Rsa-public-dump.png">
<meta property="og:image" content="https://cryptopp.com/w/images/thumb/b/b9/Rsa-private-dump.png/300px-Rsa-private-dump.png">
<meta property="og:image" content="https://cryptopp.com/w/images/thumb/a/aa/Dsa-public-key.png/300px-Dsa-public-key.png">
<meta property="og:image" content="https://cryptopp.com/w/images/thumb/5/58/Dsa-private-key.png/300px-Dsa-private-key.png">
<meta property="og:updated_time" content="2021-01-18T08:06:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RSA及相关库实现">
<meta name="twitter:description" content="应大佬要求来了解一下 RSA 相关的东西，顺便了解一下 Crypto++ 对于 RSA 的实现。">
<meta name="twitter:image" content="https://cryptopp.com/w/images/9/91/Private-key-info.png">

<link rel="canonical" href="https://gowa.club/Cpp/RSA及相关库实现.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>RSA及相关库实现 | 退思园</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137245514-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-137245514-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">退思园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">烦恼一般都是想太多了。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-soft">

    <a href="/soft/" rel="section"><i class="fa fa-fw fa-rocket"></i>soft</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gowa.club/Cpp/RSA及相关库实现.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gowa2017 Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="退思园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RSA及相关库实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-18 16:06:04" itemprop="dateCreated datePublished" datetime="2021-01-18T16:06:04+08:00">2021-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/Cpp/RSA及相关库实现.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Cpp/RSA及相关库实现.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>应大佬要求来了解一下 RSA 相关的东西，顺便了解一下 Crypto++ 对于 RSA 的实现。</p>
<a id="more"></a>
<h1 id="RAS-简单介绍"><a href="#RAS-简单介绍" class="headerlink" title="RAS 简单介绍"></a>RAS 简单介绍</h1><div class="language-dot">
digraph {
  {rank=same p q}
  n[label="n"]
  p -> q[style=dashed,label=X,arrowhead=none]
  {p q} -> n
  fn[label="φ(n)"]
  n -> fn

  e[label="e\n1< e < φ(n)"]
  d[label="d\n e 对 φ(n) 模反元素 \n 使 φ(n) mod e 为1"]
  fn -> d
  e -> d[style=dashed]
  e -> fn[label="互质",style=dashed,dir=both]

  subgraph cluster_public{
    label=公钥
    n e
  }
  subgraph cluster_private{
    label=私钥
    n d
  }

}
</div>
<p>加密：<script type="math/tex">m^e = c (mod/n)</script><br>解密: <script type="math/tex">c^d  = m(mod/n)</script></p>
<h1 id="Crypto-实现"><a href="#Crypto-实现" class="headerlink" title="Crypto++ 实现"></a>Crypto++ 实现</h1><h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><p>常规的 Key 操作，如：生成、验证、加载、保存、导入、导出等在 <a href="https://cryptopp.com/wiki/Keys_and_Formats" target="_blank" rel="noopener">Keys and Formats</a> 进行了讨论。</p>
<p>Crypto++ 的 RSA 实现在 <code>rsa.h</code> 中进行了 typedef</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RSA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> RSAFunction PublicKey;</span><br><span class="line">    <span class="keyword">typedef</span> InvertibleRSAFunction PrivateKey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>InvertibleRSAFunction</code> 提供了一个 <code>GenerateRandomWithKeySize</code> 函数来生成 Key ，密钥对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GenerateRandomWithKeySize (RandomNumberGenerator &amp;rng, <span class="keyword">unsigned</span> <span class="keyword">int</span> keySize)</span><br></pre></td></tr></table></figure>
<p>这个方法的参数是一个 <code>[RandomNumberGenerator](https://cryptopp.com/wiki/RandomNumberGenerator)</code> 和用 <code>bit</code> 来指定的 <code>模（modulus）</code> 的大小。 <code>GenerateRandomWithKeySize</code> 以模的大小来调用 <code>GenerateRandom</code>，然后生成一个加密的 <code>NameValuePairs</code>。<br>在很多的示例代码中，作为展示，<code>InvertibleRSAFunction</code> 都会如下使用来建立逻辑上独立的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Generate Parameters</span></span><br><span class="line">InvertibleRSAFunction params;</span><br><span class="line">params.GenerateRandomWithKeySize(rng, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Create Keys</span></span><br><span class="line">RSA::<span class="function">PrivateKey <span class="title">privateKey</span><span class="params">(params)</span></span>;</span><br><span class="line">RSA::<span class="function">PublicKey <span class="title">publicKey</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实际上，为了提高可读性，应该使用 <code>RSA::PrivateKey</code> ，而不是 <code>InvertibleRSAFunction</code>；而 <code>RSAES_PKCS1v15_Encryptor, RSAES_OAEP_SHA_Encryptor,</code> 由你的朋友们使用。一个更详细的，看待密钥的生成、加载等的参考 <a href="https://cryptopp.com/wiki/Keys_and_Formats" target="_blank" rel="noopener">Keys and Formats</a> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Create Keys</span></span><br><span class="line">RSA::PrivateKey privateKey;</span><br><span class="line">privateKey.GenerateRandomWithKeySize(rng, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line">RSA::<span class="function">PublicKey <span class="title">publicKey</span><span class="params">(privateKey)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一旦，Key 被建立，那么他们就可以被传递给 <code>Encryptors, Decryptors, Signers, and Verifiers.</code> 使用了。<br>如果想要将 Key 持久化到硬盘，使用 <code>Save</code> 函数。如果要从磁盘加载，使用 <code>Load</code> 函数。</p>
<p>如果你有一个由 <code>{n, e, d}</code> 组成的私钥，而你又对 <strong>PKCS #1</strong> 中指定的所有参数的计算感兴趣的话，看 <a href="https://groups.google.com/group/sci.crypt/browse_frm/thread/d228e099f78164e3" target="_blank" rel="noopener">RSA CRT Key</a> 这里。另外，Mounir Idrassi 提供了一个开源工具：<a href="http://rsaconverter.sourceforge.net/" target="_blank" rel="noopener">RSA Converter</a></p>
<p>如果我们需要导入 <code>{n, e, d}</code> 私钥，或者 <code>{n, e}</code> 公钥，使用 <code>Initialize</code>。<code>RSA::PublicKey</code> 和 <code>RSA::PrivateKey</code> 都提供了这个函数的重载。</p>
<h2 id="加密-Encryption"><a href="#加密-Encryption" class="headerlink" title="加密 Encryption"></a>加密 Encryption</h2><p>高级的 <a href="https://cryptopp.com/wiki/RSA_Encryption_Schemes" target="_blank" rel="noopener">RSA encryption schemes</a> 通过 RSAES 导出，它们如下定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">STANDARD</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">RSAES</span> :</span> <span class="keyword">public</span> TF_ES&lt;STANDARD, RSA&gt;</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>模板参数 <code>STANDARD</code>，指定了额外的算法。如，当需要处理 PKCS 的时候，<code>PKCS1v15</code> 就会作为参数传递。</p>
<blockquote>
<p>注意：用 PKCS v1.5 进行 RSA 加密应该非常小心的使用，因为会有 <code>padding oracle attacks</code>。<a href="http://blog.cryptographyengineering.com/2012/06/bad-couple-of-years-for-cryptographic.html" target="_blank" rel="noopener"><a href="http://blog.cryptographyengineering.com/2012/06/bad-couple-of-years-for-cryptographic.html" target="_blank" rel="noopener">A bad couple of years for the cryptographic token industry</a></a></p>
</blockquote>
<p><code>TF_ES</code> 类导出了与 RSA 使用时的一些常用特性。<code>TF</code> 代表了 <code>trapdoor</code> 函数的意思，<code>ES</code> 代表了加密的组合。这里有些存在——在遇到 <code>cryptlib.h</code> 中的 <code>TF_EncryptorBase</code> 和 <code>TF_DecryptorBase</code> 前，至少两层的模板。为了更方便的使用这个库，这里提供了两个 <code>typedef</code>。第一个基于 <code>PKCS #1</code>，第二个是基于 <code>OAEP</code> 和 <code>SHA</code>。因为 PKCS 对齐的实现问题，我们应该优先使用 <code>OAEP</code> 对齐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> RSAES&lt;PKCS1v15&gt;::Decryptor RSAES_PKCS1v15_Decryptor;</span><br><span class="line"><span class="keyword">typedef</span> RSAES&lt;PKCS1v15&gt;::Encryptor RSAES_PKCS1v15_Encryptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> RSAES&lt;OAEP&lt;SHA&gt; &gt;::Decryptor RSAES_OAEP_SHA_Decryptor;</span><br><span class="line"><span class="keyword">typedef</span> RSAES&lt;OAEP&lt;SHA&gt; &gt;::Encryptor RSAES_OAEP_SHA_Encryptor;</span><br></pre></td></tr></table></figure>
<h2 id="签名-Signature"><a href="#签名-Signature" class="headerlink" title="签名 Signature"></a>签名 Signature</h2><p>高级的 <a href="https://cryptopp.com/wiki/RSA_Signature_Schemes" target="_blank" rel="noopener">RSA signature schemes</a> 通过 <code>RSASS</code> 导出，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class STANDARD, class H&gt;</span><br><span class="line">struct RSASS : public TF_SS&lt;STANDARD, H, RSA&gt;</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>和 <code>RSAES</code> 一样，<code>RSASS</code> 也需要一个 <code>STANDARD</code>。<strong>TF</strong> 代表了 <code>trapdoor</code> 函数，<strong>SS</strong> 代表了签名组合。除了 <code>STANDARD</code> 参数外，一个单一方式的哈希函数必须通过 <code>H</code> 来提供。签名者和验签者感兴趣的类是 <code>PK_Signer</code> 和 <code>PK_Verifier</code>，这两个也在 <code>cryptlib.h</code> 中。后一个类提供了如 <code>MaxSignatureLenght, SignMessage, VerifyMessage</code> 这些我们熟悉的函数。</p>
<p>Crypto++ <a href="https://cryptopp.com/wiki/RSA" target="_blank" rel="noopener">RSA</a> 对一个 <a href="https://cryptopp.com/wiki/Digital_Signature" target="_blank" rel="noopener">Signature Scheme with Appendix</a> (SSA) 的实现如下进行了 <code>typedef</code> 。注意，两个额外哈希函数都在 PKCS (<a href="https://cryptopp.com/w/index.php?title=MD2&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">MD2</a> and <a href="https://cryptopp.com/wiki/MD5" target="_blank" rel="noopener">MD5</a>)进行了指定，但不应该使用它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef RSASS&lt;PKCS1v15, SHA&gt;::Signer RSASSA_PKCS1v15_SHA_Signer;</span><br><span class="line">typedef RSASS&lt;PKCS1v15, SHA&gt;::Verifier RSASSA_PKCS1v15_SHA_Verifier;</span><br></pre></td></tr></table></figure>
<p>Crypto++ <a href="https://cryptopp.com/wiki/RSA" target="_blank" rel="noopener">RSA</a> 对一个 <a href="https://cryptopp.com/wiki/Digital_Signature" target="_blank" rel="noopener">Signature Scheme with Recovery</a> (PSSR)的实现和 SSA 类似。然而，这里并没有 <code>typedef</code>，所以这些对象必须使用模板语法进行声明。下面， <code>PSSR</code> (from <code>pssr.h</code>) 进行了传参 (恢复算法)，另又指定了一个 HASH 算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSASS&lt;PSSR, SHA1&gt;::Signer signer;</span><br><span class="line">RSASS&lt;PSSR, SHA1&gt;::Verifier verifier;</span><br></pre></td></tr></table></figure>
<p>如果期待 Whirlpool 那么应该像下面这样操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSASS&lt;PSSR, Whirlpool&gt;::Signer signer;</span><br><span class="line">RSASS&lt;PSSR, Whirlpool&gt;::Verifier verifier;</span><br></pre></td></tr></table></figure>
<p>如果对 SHA-2 家族的哈希感兴趣，那么应该使用 <code>SHA256</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSASS&lt;PSSR, SHA256&gt;::Signer signer;</span><br><span class="line">RSASS&lt;PSSR, SHA256&gt;::Verifier verifier;</span><br></pre></td></tr></table></figure>
<p>尽管签名的类型不同（PSSR vs SSA），我们很容易的通过公钥或者私钥来构造签名者和验签者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Generate or Load keys</span><br><span class="line">RSA::PrivateKey privateKey;</span><br><span class="line">RSA::PublicKey publicKey;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">RSASS&lt;PSSR, SHA1&gt;::Signer signer(privateKey);</span><br><span class="line">// Create signature</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">RSASS&lt;PSSR, SHA1&gt;::Verifier verifier(publicKey);</span><br><span class="line">// Verify signature on message</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Pseudo Random Number Generator</span></span><br><span class="line">AutoSeededRandomPool rng;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Generate Parameters</span></span><br><span class="line">InvertibleRSAFunction params;</span><br><span class="line">params.GenerateRandomWithKeySize(rng, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Generated Parameters</span></span><br><span class="line"><span class="keyword">const</span> Integer&amp; n = params.GetModulus();</span><br><span class="line"><span class="keyword">const</span> Integer&amp; p = params.GetPrime1();</span><br><span class="line"><span class="keyword">const</span> Integer&amp; q = params.GetPrime2();</span><br><span class="line"><span class="keyword">const</span> Integer&amp; d = params.GetPrivateExponent();</span><br><span class="line"><span class="keyword">const</span> Integer&amp; e = params.GetPublicExponent();</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Dump</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"RSA Parameters:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" n: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" p: "</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" q: "</span> &lt;&lt; q &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" e: "</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Create Keys</span></span><br><span class="line">RSA::<span class="function">PrivateKey <span class="title">privateKey</span><span class="params">(params)</span></span>;</span><br><span class="line">RSA::<span class="function">PublicKey <span class="title">publicKey</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="密钥生成的性能"><a href="#密钥生成的性能" class="headerlink" title="密钥生成的性能"></a>密钥生成的性能</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  AutoSeededRandomPool prng;</span><br><span class="line">  RSA::PrivateKey rsa;</span><br><span class="line">  <span class="function">ThreadUserTimer <span class="title">timer</span><span class="params">(TimerBase::MILLISECONDS)</span></span>;</span><br><span class="line"></span><br><span class="line">  timer.StartTimer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> bits = <span class="number">2048</span>;</span><br><span class="line">  rsa.GenerateRandomWithKeySize(prng, bits);</span><br><span class="line"></span><br><span class="line">  <span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> elapsed = timer.GetCurrentTimerValue();</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ticks = timer.TicksPerSecond();</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> seconds = elapsed / ticks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// days, hours, minutes, seconds, 100th seconds</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> d=<span class="number">0</span>, h=<span class="number">0</span>, m=<span class="number">0</span>, s=<span class="number">0</span>, p=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = ((elapsed * <span class="number">100</span>) / ticks) % <span class="number">100</span>;</span><br><span class="line">  s = seconds % <span class="number">60</span>;</span><br><span class="line">  m = (seconds / <span class="number">60</span>) % <span class="number">60</span>;</span><br><span class="line">  h = (seconds / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">60</span>;</span><br><span class="line">  d = (seconds / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>) % <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> fs = (seconds + ((<span class="keyword">float</span>)p/<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(d) &#123;</span><br><span class="line">    ss &lt;&lt; d &lt;&lt; ((d == <span class="number">1</span>) ? <span class="string">" day, "</span> : <span class="string">" days, "</span>);</span><br><span class="line">    <span class="keyword">goto</span> print_hours;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(h) &#123;</span><br><span class="line">    print_hours:</span><br><span class="line">      ss &lt;&lt; h &lt;&lt; ((h == <span class="number">1</span>) ? <span class="string">" hour, "</span> : <span class="string">" hours, "</span>);</span><br><span class="line">      <span class="keyword">goto</span> print_minutes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(m) &#123;</span><br><span class="line">    print_minutes:</span><br><span class="line">      ss &lt;&lt; m &lt;&lt; ((m == <span class="number">1</span>) ? <span class="string">" minute, "</span> : <span class="string">" minutes, "</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ss &lt;&lt; s &lt;&lt; ((s == <span class="number">1</span>) ? <span class="string">" second"</span> : <span class="string">" seconds"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Elapsed time for "</span> &lt;&lt; bits &lt;&lt; <span class="string">" RSA key: "</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; fs &lt;&lt; <span class="string">"s"</span>;</span><br><span class="line">  <span class="keyword">if</span>(seconds)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" ("</span> &lt;&lt; ss.str() &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(CryptoPP::Exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Encryption-Scheme-OAEP-using-SHA"><a href="#Encryption-Scheme-OAEP-using-SHA" class="headerlink" title="Encryption Scheme (OAEP using SHA)"></a>Encryption Scheme (OAEP using SHA)</h3><p>先的代码演示了使用 OAEP 进行 RSA 加密。完成的 RSA 加密的例子可以在 <a href="https://cryptopp.com/wiki/RSA_Encryption_Schemes" target="_blank" rel="noopener">RSA Encryption Schemes</a> 查看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Generate keys</span></span><br><span class="line">AutoSeededRandomPool rng;</span><br><span class="line"></span><br><span class="line">InvertibleRSAFunction params;</span><br><span class="line">params.GenerateRandomWithKeySize(rng, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line">RSA::<span class="function">PrivateKey <span class="title">privateKey</span><span class="params">(params)</span></span>;</span><br><span class="line">RSA::<span class="function">PublicKey <span class="title">publicKey</span><span class="params">(params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> plain=<span class="string">"RSA Encryption"</span>, cipher, recovered;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Encryption</span></span><br><span class="line"><span class="function">RSAES_OAEP_SHA_Encryptor <span class="title">e</span><span class="params">(publicKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StringSource <span class="title">ss1</span><span class="params">(plain, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">new</span> PK_EncryptorFilter(rng, e,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">new</span> StringSink(cipher)</span></span></span><br><span class="line"><span class="function"><span class="params">   ) <span class="comment">// PK_EncryptorFilter</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// StringSource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Decryption</span></span><br><span class="line"><span class="function">RSAES_OAEP_SHA_Decryptor <span class="title">d</span><span class="params">(privateKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StringSource <span class="title">ss2</span><span class="params">(cipher, <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">new</span> PK_DecryptorFilter(rng, d,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">new</span> StringSink(recovered)</span></span></span><br><span class="line"><span class="function"><span class="params">   ) <span class="comment">// PK_DecryptorFilter</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// StringSource</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Recovered plain text"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Signature-Scheme-PKCS-v1-5"><a href="#Signature-Scheme-PKCS-v1-5" class="headerlink" title="Signature Scheme (PKCS v1.5)"></a>Signature Scheme (PKCS v1.5)</h3><p>尽管和 RSA-SSA 类似, <code>RSASSA_PKCS1v15_SHA_Signer</code> and <code>RSASSA_PKCS1v15_SHA_Verifier</code> 使用 PKCS v1.5 对齐。<code>RSASSA_PKCS1v15_&lt;*Digest*&gt;_Signer</code> 和 <code>RSASSA_PKCS1v15_&lt;*Digest*&gt;_Verifier</code> 的 <a href="https://cryptopp.com/w/index.php?title=MD2&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">MD2</a> 与 <a href="https://cryptopp.com/wiki/MD5" target="_blank" rel="noopener">MD5</a> 变量 <strong>不应该</strong> 被使用。完整的 <a href="https://cryptopp.com/wiki/RSA" target="_blank" rel="noopener">RSA</a> 签名组合的代码见 <a href="https://cryptopp.com/wiki/RSA_Signature_Schemes" target="_blank" rel="noopener">RSA Signature Schemes</a>.</p>
<p>Note: RSA encryption with PKCS v1.5 padding should be used with caution due to padding oracle attacks. See <a href="http://blog.cryptographyengineering.com/2012/06/bad-couple-of-years-for-cryptographic.html" target="_blank" rel="noopener">A bad couple of years for the cryptographic token industry</a>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Generate or Load keys</span><br><span class="line">RSA::PrivateKey privateKey = ...;</span><br><span class="line">RSA::PublicKey publicKey = ...;</span><br><span class="line"></span><br><span class="line">// Message</span><br><span class="line">string message = &quot;RSA Signature&quot;, signature;</span><br><span class="line"></span><br><span class="line">////////////////////////////////////////////////</span><br><span class="line">// Sign and Encode</span><br><span class="line">RSASSA_PKCS1v15_SHA_Signer signer(privateKey);</span><br><span class="line"></span><br><span class="line">StringSource ss1(message, true,</span><br><span class="line">    new SignerFilter(rng, signer,</span><br><span class="line">        new StringSink(signature)</span><br><span class="line">   ) // SignerFilter</span><br><span class="line">); // StringSource</span><br><span class="line"></span><br><span class="line">////////////////////////////////////////////////</span><br><span class="line">// Verify and Recover</span><br><span class="line">RSASSA_PKCS1v15_SHA_Verifier verifier(publicKey);</span><br><span class="line"></span><br><span class="line">StringSource ss2(message+signature, true,</span><br><span class="line">    new SignatureVerificationFilter(</span><br><span class="line">        verifier, NULL,</span><br><span class="line">        SignatureVerificationFilter::THROW_EXCEPTION</span><br><span class="line">   ) // SignatureVerificationFilter</span><br><span class="line">); // StringSource</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Verified signature on message&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="Keys-and-Formats"><a href="#Keys-and-Formats" class="headerlink" title="Keys and Formats"></a>Keys and Formats</h1><p>在 Crypto++ 中，有多种密钥，如 RSA/DSA，但是它们的概念是一致的。这是因为，Crypto++ 的继承（从<code>PublicKey</code> 与 <code>PrivateKey</code> 衍生的对象）和组合（从 <code>PublicKeyAlgorithm</code> 和 <code>PrivateKeyAlgorithm</code> 衍生的对象）。</p>
<p>通过，我们应该使用密钥的 <code>Load</code> 和 <code>Save</code> 函数来达到与其他库（如 OpenSSL，Java，微软的 .Net）的交互性。<code>Load</code> 和 <code>Save</code> 在 PKCS#8 的<code>PrivateKeyInfo</code> 和 X509 的 <code>SubjectPublicKeyInfo</code> 上进行操作。</p>
<blockquote>
<p>X.509，IETF 的 Privacy Enhanced Mail（PEM） 和 PKCS #1（RSA 加密标准）在他们对 RSA 公钥的定义是相同的。</p>
</blockquote>
<p>如果密钥只是在程序内工作，我们可以使用 PKCS #8 的 <code>PrivateKey</code>（<code>PrivateKeyInfo</code> 的一部分）和 X.509 的<code>PublicKey</code> （<code>SubjectPublicKeyInfo</code> 的一部分）。 PKCS #8 的 <em>PrivateKey</em> and X.509’s <em>PublicKey</em> 会节省字节和处理的时间。</p>
<p>当写出 X.509 和 PKCS #8 密钥的时候必须使用 <strong>ASN.1</strong>。实际上，密钥写出的时候必须使用 <code>DER</code> 编码，然后使用 <code>BER</code> 编码来读取。<code>BER</code> 比 <code>DER</code> 更宽松一些——这个标准的目的是为了通过 <em>更严格的写入</em> 和 <em>宽松的读取</em> 来推动交互性。See <em><a href="http://www.itu.int/rec/T-REC-X.690/en" target="_blank" rel="noopener">X.690, Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a></em>.</p>
<p>最后, 两个 <a href="http://www.codeproject.com/" target="_blank" rel="noopener">Code Project</a> 文章涵盖了 Crypto++, 密钥和交互性。, See <a href="http://www.codeproject.com/KB/security/CryptoInteropKeys.aspx" target="_blank" rel="noopener">Cryptographic Interoperability: Keys</a> and <a href="http://www.codeproject.com/KB/security/CryptoInteropSign.aspx" target="_blank" rel="noopener">Cryptographic Interoperability: Digital Signatures</a>.</p>
<h2 id="Crypto-Key-Formats"><a href="#Crypto-Key-Formats" class="headerlink" title="Crypto++ Key Formats"></a>Crypto++ Key Formats</h2><p>在内部，Crypto++ 使用一个遵循真实世界对象的关键表示。然而，一个 Crypto++ 密钥的原始字节的 dump，在离开了这个库后就没有什么意义了。例如，Crypto++ <strong>并不</strong> 通过 ASN.1 来编码 PKCS #8 格式的密钥进行表示，所以呢，一个 dump 是没有什么互操作性的。Crypto++ <strong>提供</strong> 允许库与很多流行的格式进行工作的方法，包括了 PKCS #8 和 X.509。</p>
<h3 id="Private-Key-Format"><a href="#Private-Key-Format" class="headerlink" title="Private Key Format"></a>Private Key Format</h3><p><a href="https://cryptopp.com/wiki/File:Private-key-info.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/9/91/Private-key-info.png" alt="Logical depiction of PrivateKeyInfo"></a></p>
<p>Crypto++ 使用的外部私钥格式是 <em><a href="http://www.rsa.com/rsalabs/node.asp?id=2130" target="_blank" rel="noopener">PKCS #8: Private-Key Information Syntax Standard</a></em>。PKCS 标准规定了这种密钥的 ASN.1 编码。 ASN.1 is <a href="http://www.itu.int/rec/T-REC-X.690/" target="_blank" rel="noopener">Abstract Syntax Notation</a> ，它在 ITU 的 <em><a href="http://www.itu.int/rec/T-REC-X.690/" target="_blank" rel="noopener">X.690, Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a></em> 进行了标准化。</p>
<p>概念上，这种格式有两个部分。</p>
<ol>
<li>包消息。如 OID、版本和属性。</li>
<li>密钥的实际序列化后的字节。</li>
</ol>
<p>在 PKCS #8 中，第一部分被叫做 <code>PrivateKeyInfo</code>，第二部分叫做 <code>PrivateKey</code>。</p>
<p>实际上，我们应该将第二部分想做是 <code>XxxPrivateKey</code>，其中 ‘Xxx’ 会在知道了 OID 后进行设置。例如，如果 OID 是 <code>rsaEncryption</code>，<em>XxxPrivateKey</em> 就会变成 <em>RsaPrivateKey</em>。 如果 OID 是 dsa，那么就是 <em>DsaPrivateKey</em>。</p>
<p>上面图片中显示的私钥是 <code>00 B7 67 B4 ...</code>。它是使用 ASN.1 <em>字节字符串</em> 进行编码。</p>
<blockquote>
<p><code>PrivateKeyInfo</code> 包围了 <code>PrivateKey</code>。</p>
</blockquote>
<h3 id="Public-Key-Format"><a href="#Public-Key-Format" class="headerlink" title="Public Key Format"></a>Public Key Format</h3><p><a href="https://cryptopp.com/wiki/File:Public-key-info.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/7/7f/Public-key-info.png" alt="Logical depiction of PublicKeyInfo"></a></p>
<p>Crypto++ 使用的外部公钥格式是 <em><a href="http://www.itu.int/rec/T-REC-X.509/" target="_blank" rel="noopener">X.509: Public-key and attribute certificate frameworks</a></em> 。和 PKCS #8 一样，密钥使用 ASN.1 编码。</p>
<p>概念上，也是两部分：</p>
<ol>
<li>包信息。如 OID</li>
<li>真实序列化后的密钥。（这和上面描述 PKCS #8 听起来是一样的）。</li>
</ol>
<p>在 X.509 中，第一部分叫做 <em>PublicKeyInfo</em>，第二部分叫做 <em>PublicKey</em>。如 <em>XxxPrivateKey</em>，当我们知道了 OID 后就会进行设置。</p>
<p><em>PublicKey</em> 和 PKCS #8 使用 ASN.1 来编码有些不同。上面的图片中展示了样例数据 101010111…。这个数据使用的是 ASN.1 的<em>二进制字符串</em>。在 PKCS #8 中，PublicKeyInfo 包围了 PublicKey。</p>
<h3 id="Crypto-PKCS8PrivateKey"><a href="#Crypto-PKCS8PrivateKey" class="headerlink" title="Crypto++ PKCS8PrivateKey"></a>Crypto++ PKCS8PrivateKey</h3><p><code>RSA::PrivateKey</code> 和 <code>DSA::PrivateKey</code> 是 Crypto++ 中封装了大多数 RSA 和 DSA 的标准密钥(ie, PKCS, X.509, IEEE, and IETF)。 它们都从一个 PrivateKey 继承，更重要的是 PKCS8PrivateKey<code>。PKCS8PrivateKey 类的文档在 [PKCS8PrivateKey Class Reference](http://www.cryptopp.com/docs/ref/class_p_k_c_s8_private_key.html)，其中展示了这个类提供了</code>Load, Save` 函数。</p>
<h3 id="Crypto-X509PublicKey"><a href="#Crypto-X509PublicKey" class="headerlink" title="Crypto++ X509PublicKey"></a>Crypto++ X509PublicKey</h3><p>类似, <code>RSA::PublicKey</code> 和 <code>DSA::PublicKey</code> 都从一个 <code>PublicKey</code> 和 <code>X509PublicKey</code>继承。<code>X509PublicKey</code> 类的文档位于<a href="http://www.cryptopp.com/docs/ref/class_x509_public_key.html" target="_blank" rel="noopener">X509PublicKey Class Reference</a> ，其中也提供了 <code>Load, Save</code> 方法。</p>
<h2 id="Generating-Validating-Saving-and-Loading-Keys"><a href="#Generating-Validating-Saving-and-Loading-Keys" class="headerlink" title="Generating, Validating, Saving, and Loading Keys"></a>Generating, Validating, Saving, and Loading Keys</h2><p>我们需要一个程序来生成 RSA/DSA 的密钥对，这是<a href="https://cryptopp.com/w/images/4/4f/Cryptopp-key-gen.zip" target="_blank" rel="noopener">cryptopp-key-gen</a>。 cryptopp-key-gen 为了演示目的而生成与保存这些密钥。RSA 密钥可以用来进行加密 (see <a href="https://cryptopp.com/wiki/RSA_Cryptography#Encryption_Scheme" target="_blank" rel="noopener">RSA Encryption Schemes</a>) 或者签名 (see <a href="https://cryptopp.com/wiki/RSA_Cryptography#Signature_Scheme" target="_blank" rel="noopener">RSA Signature Schemes</a>); DSA 与 <a href="https://cryptopp.com/wiki/Digital_Signature_Algorithm" target="_blank" rel="noopener">Digital Signature Algorithm</a>一起使用。</p>
<blockquote>
<p><strong>Note</strong>: <code>RSA::PrivateKey</code> 和 <code>DSA::PrivateKey</code> 是 Crypto++ 中与 PKCS #8 <em>PrivateKeyInfo</em> 等价的东西。 类似， <code>RSA::PublicKey</code> 和 <code>DSA::PublicKey</code> 是与 X.509 <em>PublicKeyInfo</em> 等价的。如果我们想要保存和加载一个 PKCS #8 <em>XxxPrivateKey</em> 格式或 X.509 <em>XxxPublicKey</em> 格式， 查看 <a href="https://cryptopp.com/wiki/Keys_and_Formats#BER_and_DER_Encoding" target="_blank" rel="noopener">BER and DER Encoding</a>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">RSA::PrivateKey rsaPrivate;</span><br><span class="line">rsaPrivate.GenerateRandomWithKeySize(rnd, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line">RSA::<span class="function">PublicKey <span class="title">rsaPublic</span><span class="params">(rsaPrivate)</span></span>;</span><br><span class="line"></span><br><span class="line">SavePrivateKey(<span class="string">"rsa-private.key"</span>, rsaPrivate);</span><br><span class="line">SavePublicKey(<span class="string">"rsa-public.key"</span>, rsaPublic);</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">DSA::PrivateKey dsaPrivate;</span><br><span class="line">dsaPrivate.GenerateRandomWithKeySize(rnd, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">DSA::PublicKey dsaPublic;</span><br><span class="line">dsaPrivate.MakePublicKey(dsaPublic);</span><br><span class="line"></span><br><span class="line">SavePrivateKey(<span class="string">"dsa-private.key"</span>, dsaPrivate);</span><br><span class="line">SavePublicKey(<span class="string">"dsa-public.key"</span>, dsaPublic);</span><br></pre></td></tr></table></figure>
<h3 id="Generating-Keys"><a href="#Generating-Keys" class="headerlink" title="Generating Keys"></a>Generating Keys</h3><p>RSA/DSA 的密钥生成非常的类似。<code>RSA::PrivateKey</code> 和<code>DSA::PrivateKey</code> 都从 Crypto++ 的 <code>PrivateKey</code> (documented at <a href="http://www.cryptopp.com/docs/ref/class_private_key.html" target="_blank" rel="noopener">PrivateKey Class Reference</a>)继承， <code>PrivateKey</code> 提供了 <code>GenerateRandom</code> 和<code>GenerateRandomWithKeySize</code>。Crypto++ 方法都使用一个 <code>RandomNumberGenerator</code> (documented at <a href="http://www.cryptopp.com/docs/ref/class_random_number_generator.html" target="_blank" rel="noopener">RandomNumberGenerator Class Reference</a>)，然后使用一个生成器和字节大小。</p>
<p>当选择字节大小的时候，当前的最佳实践（从 NIST 参考）规定我们使用一个 <a href="https://cryptopp.com/wiki/Security_Level" target="_blank" rel="noopener">security level of 128</a> (80 and 112 <a href="https://cryptopp.com/wiki/Security_Level" target="_blank" rel="noopener">bits of security</a> 在新系统中不应该再使用)。这意味着 RSA 应该使用 3072 字节的模。这也意味着一个 DSS Version1 或 DSS version 2 的 DSA 密钥在当前的安全性要求太弱了(一 个 1024 字节的 DSA 提供了大概 80 个理论上的安全字节)。</p>
<p>下面的代码中，我们创建一个 3072 字节的 RSA 密钥，1024 字节的 DSA 密钥（DSS Version2 ）。</p>
<p><code>AutoSeededRandomPool</code> 是一个 PGP 伪随机数生成器。 如果需要更安全的生成器，使用 <code>X917RNG</code> (from ANSI 9.17 Appendix C and based on DES) 或 <code>AutoSeededX917RNG</code> based on the <code>AES</code> block cipher.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AutoSeededRandomPool rnd;</span><br><span class="line"></span><br><span class="line">RSA::PrivateKey rsaPrivate;</span><br><span class="line">rsaPrivate.GenerateRandomWithKeySize(rnd, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line">DSA::PrivateKey dsaPrivate;</span><br><span class="line">dsaPrivate.GenerateRandomWithKeySize(rnd, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>我们通过如下方式从私钥来生成公钥。<code>RSA::PublicKey</code>  允许我们在构造器中使用私钥。 <code>DSA::PublicKey</code> 需要我们手动执行 <code>MakePublicKey</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSA::PublicKey rsaPublic(rsaPrivate);</span><br><span class="line"></span><br><span class="line">DSA::PublicKey dsaPublic;</span><br><span class="line">dsaPrivate.MakePublicKey(dsaPublic);</span><br></pre></td></tr></table></figure>
<h3 id="Saving-Keys"><a href="#Saving-Keys" class="headerlink" title="Saving Keys"></a>Saving Keys</h3><p>Crypto++ 的文档很完善。如果我们查找 <strong>.Save</strong>（注意，这是一个方法，所以前面有 <code>.</code>），最少有 25 个文件使用了这个方法。关注一下 test.cpp, 它是 <em>cryptest.exe</em> 的一部分， 它将会生成和保存密钥。不幸的是， <code>GenerateRSAKey</code> 写出的是一个 <a href="https://cryptopp.com/wiki/HexEncoder" target="_blank" rel="noopener">hex encoded</a> 密钥, 这就不能被 <em>dumpasn1</em> 这样的工具来读取了。</p>
<p>再看 <em>validate2.cpp</em>，我们发现很多加载和保存到 <a href="https://cryptopp.com/w/index.php?title=ByteQueue&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">byte queues</a>.。一个 <code>ByteQueue</code> 相对于 <a href="https://cryptopp.com/wiki/Sink" target="_blank" rel="noopener">sink</a> 来说是一个和选择，因为它 使用了一个安全的分配器（allocator） - <a href="http://www.cryptopp.com/docs/ref/class_sec_block.html" target="_blank" rel="noopener">SecByteBlock</a> ——它保证当 <code>ByteQueue</code>  的析构器运行的时候将密钥的所有信息清 0。下面是其中的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteQueue queue;</span><br><span class="line">priv.AccessKey().SavePrecomputation(queue);</span><br></pre></td></tr></table></figure>
<p>先调用 <code>AccessKey</code> 再调用 <code>SavePrecomputation</code>，我们已经有密钥了(所以这里没必要调用 <code>AccessKey</code>)，而且我们只对保存密钥本身感兴趣 (而不是预计算过程和门函数相关的东西)。在库中我们保存 KEY 的代码如下，（私钥也是类似的）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SavePublicKey(const string&amp; filename, const PublicKey&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    ByteQueue queue;</span><br><span class="line">    key.Save(queue);</span><br><span class="line"></span><br><span class="line">    Save(filename, queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SavePublicKey</code> 和 <code>SavePrivateKey</code> 使用 Crypto++ <code>PublicKey</code> 和 <code>PrivateKey</code> ，简单的将密钥写到文件。在面向对象的精神下，<code>SavePublicKey</code> 和 <code>SavePrivateKey</code> 调用 <code>Save</code>。cryptopp-key-gen 对 <code>Save</code> 和库中对 <code>Save</code> 使用基本相同（之所以相同是因为，面向对象的接口编程有很多的函数调用，但并没有实际上做更多事情）。</p>
<p>如果我们从面向对象和接口编程换个个视角（复制 cryptopp-key-gen 的 <code>Save</code>），我们将会调用 <code>CopyTo</code> and <code>MessageEnd</code> ，这种搞法是严重禁止的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Save(const string&amp; filename, const BufferedTransformation&amp; bt)</span><br><span class="line">&#123;</span><br><span class="line">    FileSink file(filename.c_str());</span><br><span class="line"></span><br><span class="line">    bt.CopyTo(file);</span><br><span class="line">    file.MessageEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Loading-Keys"><a href="#Loading-Keys" class="headerlink" title="Loading Keys"></a>Loading Keys</h3><p>虽然我们想将加载密钥作为一个练习给读者，但有一个文档来演示如何加载一个 KEY 将会更好。</p>
<p><code>PKCS8PrivateKey</code> 和 <code>X509PublicKey</code> 提供了<code>Save</code>  和 <code>Load</code>。要使用 <code>Load</code>, 我们创建了三个短小的封装函数（下面展示了两个），它是我们的对 <code>Save</code>使用的对照。数据将会从一个 <code>FileSource</code> 流向 <code>BufferedTransformation</code>，最终被 KEY 加载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadPublicKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, PublicKey&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Load</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, BufferedTransformation&amp; bt)</span></span></span><br></pre></td></tr></table></figure>
<p>cryptopp-key-gen’s 底层函数 <code>Load</code> 用文件数据填充了调用者的 <code>BufferedTransformation</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Load</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, BufferedTransformation&amp; bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FileSource <span class="title">file</span><span class="params">(filename.c_str(), <span class="literal">true</span> <span class="comment">/*pumpAll*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    file.TransferTo(bt);</span><br><span class="line">    bt.MessageEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LoadPublicKey</code> 加载 Crypto++ key:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LoadPublicKey(const string&amp; filename, PublicKey&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    ByteQueue queue;</span><br><span class="line">    Load(filename, queue);</span><br><span class="line"></span><br><span class="line">    key.Load(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以验证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSA::PrivateKey key1, key2;</span><br><span class="line">key1.GenerateRandomWithKeySize(rnd, 3072);</span><br><span class="line"></span><br><span class="line">SavePrivateKey(&quot;rsa-roundtrip.key&quot;, key1);</span><br><span class="line">LoadPrivateKey(&quot;rsa-roundtrip.key&quot;, key2);</span><br><span class="line"></span><br><span class="line">if(key1.GetModulus() != key2.GetModulus() ||</span><br><span class="line">   key1.GetPublicExponent() != key2.GetPublicExponent() ||</span><br><span class="line">   key1.GetPrivateExponent() != key2.GetPrivateExponent())</span><br><span class="line">&#123;</span><br><span class="line">    throw runtime_error(&quot;key data did not round trip&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Validating-Keys"><a href="#Validating-Keys" class="headerlink" title="Validating Keys"></a>Validating Keys</h3><p>KEY 在加载后应该被验证，无论是库生成的还是故意如此，因为你并不知道是谁生成了 KEY，或者是生成 KEY 的工具是什么（KEY 可能会有一些缺陷）。<strong>决不要</strong>  在一个未经验证的 KEY 上应用密码，因为有可能这个 KEY 有允许密码恢复的 BUG 在。<strong>决不要</strong>  使用一个未经验证的 KEY （包括数字签名有效）恢复的数据。这些警告与 “糟糕的” 用例有关(例如，不诚实的参与者);而不是预期的 ”好“用例(人们与他人公平竞争)。</p>
<p><code>CryptoMaterial</code>，被 <code>PublicKey</code> and <code>PrivateKey</code> 继承，提供了 <code>Validate</code>。 <code>Validate</code> 需要一个 <code>RandomNumberGenerator</code> 和级别参数，返回一个布尔值。 <code>Validate</code> 的注释在 <code>CryptoMaterial</code> state (see the <a href="http://www.cryptopp.com/docs/ref/class_crypto_material.html" target="_blank" rel="noopener">CryptoMaterial Class Reference</a>):</p>
<blockquote>
<p>Level 表示验证严格性:</p>
<p>0 - 使用这个对象不会导致崩溃或者异常（rng 被忽略）</p>
<p>1 - 这个对象将能正确工作 (encrypt, sign, etc.) correctly (但可能不会检查弱 KEY 等等）</p>
<p>2 - 确认这个对象和正确工作，并检查安全性</p>
<p>3 - 做一个可能长时间的检查</p>
</blockquote>
<p>实际上，我们最少应该进行第二级别的校验，最好是级别三。级别三是首选的是因为有些应用不能容忍扩展处理。级别三可能会在一些场景下需要；如，数据是高度敏感的或它进行操作决策（解密或者验证之后）非常严格。在 KEY 生成或者加载后进行验证的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(!rsaPrivate.Validate(rnd, 3))</span><br><span class="line">    throw runtime_error(&quot;Rsa private key validation failed&quot;);</span><br><span class="line"></span><br><span class="line">if(!dsaPrivate.Validate(rnd, 3))</span><br><span class="line">    throw runtime_error(&quot;Dsa private key validation failed&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="GnuPG-ElGamal-Keys"><a href="#GnuPG-ElGamal-Keys" class="headerlink" title="GnuPG ElGamal Keys"></a>GnuPG ElGamal Keys</h3><p>GnuPG generated ElGamal keys will fail validation at level two and higher. This is because GnuPG ElGamal keys use Lim-Lee primes, and not strong or safe primes. GnuPG’s documentation on ElGamal and its keys is available at <em><a href="http://www.gnupg.org/documentation/manuals/gcrypt/Prime_002dNumber_002dGenerator-Subsystem-Architecture.html" target="_blank" rel="noopener">Prime-Number-Generator Subsystem Architecture</a></em>. The paper that discusses the problem that motivated GnuPG and its use of Lim-Lee primes is <em><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.5296" target="_blank" rel="noopener">A Key Recovery Attack on Discrete Log-based Schemes Using a Prime Order Subgroup</a></em> by Chae Hoon Lim and Pil Joong Lee.</p>
<p>To validate the GnuPG ElGamal key, you should obtain the unique factorization of p (from Section 4 of Lim and Lee’s paper: [math]\displaystyle{ p = q p_1 p_2 p_3 … p_n) }[/math]. Then ensure each [math]\displaystyle{ p_i }[/math] is prime and [math]\displaystyle{ |p_i| \gt l }[/math]. [math]\displaystyle{ l }[/math] is approximately the size of [math]\displaystyle{ q }[/math], and [math]\displaystyle{ q }[/math] is chosen due to Schnorr’s subgroup attacks. To obtain the unique factorization, you can get it from the peer or factor it. According to Werner Kock of GnuPG, the unique factorization was available in secring.gpg up to (and including) version 1.4.1. After version 1.4.1, you will have to factor the key. (Note: According to GnuPG’s <a href="http://www.gnupg.org/download/release_notes.en.html" target="_blank" rel="noopener">Release Notes</a>, version 1.4.1 was superseded in July, 2005).</p>
<p>If you find you need to use GnuPG and its ElGamal schemes, it is probably easiest to generate the keys using Crypto++ (since the key will validate in Crypto++ and other libraries), and then import the key into GnuPG for use.</p>
<h2 id="BER-and-DER-Encoding"><a href="#BER-and-DER-Encoding" class="headerlink" title="BER and DER Encoding"></a>BER and DER Encoding</h2><p><a href="https://cryptopp.com/wiki/File:Rsa-der-key.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/thumb/6/65/Rsa-der-key.png/300px-Rsa-der-key.png" alt="img"></a></p>
<p>DER 编码 RSA 的公钥和私钥。</p>
<p>在 <a href="https://cryptopp.com/wiki/Keys_and_Formats#Private_Key_Format" target="_blank" rel="noopener">Private Key Format</a> 和 <a href="https://cryptopp.com/wiki/Keys_and_Formats#Public_Key_Format" target="_blank" rel="noopener">Public Key Format</a> 两节中，我们知道 PKCS #8 和 X.509 有一个包围在外面的 <em>PrivateKeyInfo</em> 或 <em>SubjectPublicKeyInfo</em>。这个结构包含了如 OID 和版本等信息。在 ASN.1 中，这个结构就是算法进行操作的关键之处。 如，一个 <em>RsaPublicKey</em> 将会有一个公开的指数 ‘e’ 和模 ‘n’，而 <em>DsaPrivateKey</em> 将会有 ‘p’, ‘q’, ‘g’, and ‘x’.</p>
<p>Crypto++ <code>DEREncodePrivateKey</code>, <code>DEREncodePublicKey</code>, <code>BERDecodePrivateKey</code>, <code>BERDecodePublicKey</code> 函数来保存和加载 KEY 的真实序列化部分。当使用编码函数的时候，要记住，你将会失去与其他库的互操作性。</p>
<p>使用 DER 进行编码写出（严格的编码规则），使用 BER 进行解码读取（宽松的解码规则），这是 ITU 规定的，目的是为了推动互操作性，也有 <a href="https://en.wikipedia.org/wiki/Robustness_Principle" target="_blank" rel="noopener">Postel’s Law</a>  精神。</p>
<p>The code below is available in <a href="https://cryptopp.com/w/images/f/f7/Cryptopp-key-encode.zip" target="_blank" rel="noopener">cryptopp-key-encode.zip</a>.</p>
<h3 id="DER-Encoding"><a href="#DER-Encoding" class="headerlink" title="DER Encoding"></a>DER Encoding</h3><p>下面的代码展示了保存 RSA 公钥的 密钥部分。注意我们必须使用 <code>RSA::PrivateKey</code> and <code>RSA::PublicKey</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoSeededRandomPool rnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        RSA::PrivateKey rsaPrivate;</span><br><span class="line">        rsaPrivate.GenerateRandomWithKeySize(rnd, <span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line">        RSA::<span class="function">PublicKey <span class="title">rsaPublic</span><span class="params">(rsaPrivate)</span></span>;</span><br><span class="line"></span><br><span class="line">        EncodePrivateKey(<span class="string">"rsa-private.key"</span>, rsaPrivate);</span><br><span class="line">        EncodePublicKey(<span class="string">"rsa-public.key"</span>, rsaPublic);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Successfully generated and saved RSA keys"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span>(CryptoPP::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodePrivateKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> RSA::PrivateKey&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteQueue <span class="built_in">queue</span>;</span><br><span class="line">    key.DEREncodePrivateKey(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    Encode(filename, <span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodePublicKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> RSA::PublicKey&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteQueue <span class="built_in">queue</span>;</span><br><span class="line">    key.DEREncodePublicKey(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    Encode(filename, <span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> BufferedTransformation&amp; bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FileSink <span class="title">file</span><span class="params">(filename.c_str())</span></span>;</span><br><span class="line"></span><br><span class="line">    bt.CopyTo(file);</span><br><span class="line">    file.MessageEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BER-Decoding"><a href="#BER-Decoding" class="headerlink" title="BER Decoding"></a>BER Decoding</h3><p>BER 解码有点不灵活。 <code>DEREncodePrivateKey</code> and <code>DEREncodePublicKey</code> 的通用接口是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BERDecodePrivateKey (BufferedTransformation &amp;bt, bool parametersPresent, size_t size)</span><br><span class="line">BERDecodePublicKey (BufferedTransformation &amp;bt, bool parametersPresent, size_t size)</span><br></pre></td></tr></table></figure>
<p>查看 <code>rsa.cpp</code>  中的代码， <code>parametersPresent</code> 和 <code>size</code> 都没有被使用 (<code>parametersPresent</code> 只有 <code>DL_PrivateKey_EC&lt;EC&gt;</code>需要， 它是 elliptic curve key 的基类), 所以我们传递 false。 尽管没有使用，我们传递 queue 中的字节数作为 <code>size</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoSeededRandomPool rnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        RSA::PrivateKey k1;</span><br><span class="line">        DecodePrivateKey(<span class="string">"rsa-private.key"</span>, k1);</span><br><span class="line"></span><br><span class="line">        RSA::PublicKey k2;</span><br><span class="line">        DecodePublicKey(<span class="string">"rsa-public.key"</span>, k2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Successfully loaded RSA keys"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!k1.Validate(rnd, <span class="number">3</span>))</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"Rsa private key validation failed"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!k2.Validate(rnd, <span class="number">3</span>))</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"Rsa public key validation failed"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Successfully validated RSA keys"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k1.GetModulus() != k2.GetModulus() ||</span><br><span class="line">           k1.GetPublicExponent() != k2.GetPublicExponent())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"key data did not round trip"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Successfully round-tripped RSA keys"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span>(CryptoPP::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecodePrivateKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, RSA::PrivateKey&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteQueue <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    Decode(filename, <span class="built_in">queue</span>);</span><br><span class="line">    key.BERDecodePrivateKey(<span class="built_in">queue</span>, <span class="literal">false</span> <span class="comment">/*paramsPresent*/</span>, <span class="built_in">queue</span>.MaxRetrievable());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecodePublicKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, RSA::PublicKey&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteQueue <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    Decode(filename, <span class="built_in">queue</span>);</span><br><span class="line">    key.BERDecodePublicKey(<span class="built_in">queue</span>, <span class="literal">false</span> <span class="comment">/*paramsPresent*/</span>, <span class="built_in">queue</span>.MaxRetrievable());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, BufferedTransformation&amp; bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FileSource <span class="title">file</span><span class="params">(filename.c_str(), <span class="literal">true</span> <span class="comment">/*pumpAll*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    file.TransferTo(bt);</span><br><span class="line">    bt.MessageEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hex-and-Base64-Encoding"><a href="#Hex-and-Base64-Encoding" class="headerlink" title="Hex and Base64 Encoding"></a>Hex and Base64 Encoding</h2><p><a href="https://cryptopp.com/wiki/File:Rsa-raw-vs-cooked.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/thumb/8/87/Rsa-raw-vs-cooked.png/300px-Rsa-raw-vs-cooked.png" alt="img"></a></p>
<p>二进制和 Base64 编码的单个 RSA KEY。</p>
<p>二进制的 KEY，某些时候会被叫做 <code>raw</code> 或者 <code>uncooked</code>（通常这是应用在数据上，而不是特指 KEY）。</p>
<p>有时，这是有利（或者必须）于添加一些额外处理——如，16 进制编码或者 base64 编码。一个已经进行了额外处理的 <code>raw</code> KEY 有时会被程为 <code>cooked</code>  或 <code>baked</code>。</p>
<p>在上面的图片中，花点时间就可以看出来，二进制字符串 <code>0x30 0x82 ...</code> 可能表明这是一个 <code>raw</code> ASN.1 。类似，也能识别出一个以 ASCII 字符串 <code>MII...</code> 开头的可能是一个 Base64 编码的 ASN.1 文件。</p>
<p>下面是 16 进制或 Base64 编码的展示。如何解码就留给读者了。</p>
<h3 id="Hex-Encoding-and-Decoding"><a href="#Hex-Encoding-and-Decoding" class="headerlink" title="Hex Encoding and Decoding"></a>Hex Encoding and Decoding</h3><p>如果我们想要在保存 KEY 的过程中用 16 进制进行编码，我们将会添加如下签名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SaveHexPrivateKey(const string&amp; filename, const PrivateKey&amp; key);</span><br><span class="line">void SaveHexPublicKey(const string&amp; filename, const PublicKey&amp; key);</span><br><span class="line"></span><br><span class="line">void SaveHex(const string&amp; filename, const BufferedTransformation&amp; bt);</span><br></pre></td></tr></table></figure>
<p>最后，16 进制编码的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SaveHexPrivateKey(const string&amp; filename, const PrivateKey&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    ByteQueue queue;</span><br><span class="line">    key.Save(queue);</span><br><span class="line"></span><br><span class="line">    SaveHex(filename, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SaveHexPublicKey(const string&amp; filename, const PublicKey&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    ByteQueue queue;</span><br><span class="line">    key.Save(queue);</span><br><span class="line"></span><br><span class="line">    SaveHex(filename, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SaveHex(const string&amp; filename, const BufferedTransformation&amp; bt)</span><br><span class="line">&#123;</span><br><span class="line">    HexEncoder encoder;</span><br><span class="line"></span><br><span class="line">    bt.CopyTo(encoder);</span><br><span class="line">    encoder.MessageEnd();</span><br><span class="line"></span><br><span class="line">    Save(filename, encoder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Base64-Encoding-and-Decoding"><a href="#Base64-Encoding-and-Decoding" class="headerlink" title="Base64 Encoding and Decoding"></a>Base64 Encoding and Decoding</h3><p>如果要在保存的过程中进行 Base64 编码，添加如下签名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SaveBase64PrivateKey(const string&amp; filename, const PrivateKey&amp; key);</span><br><span class="line">void SaveBase64PublicKey(const string&amp; filename, const PublicKey&amp; key);</span><br><span class="line"></span><br><span class="line">void SaveBase64(const string&amp; filename, const BufferedTransformation&amp; bt);</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SaveBase64PrivateKey(const string&amp; filename, const PrivateKey&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    ByteQueue queue;</span><br><span class="line">    key.Save(queue);</span><br><span class="line"></span><br><span class="line">    SaveBase64(filename, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SaveBase64PublicKey(const string&amp; filename, const PublicKey&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    ByteQueue queue;</span><br><span class="line">    key.Save(queue);</span><br><span class="line"></span><br><span class="line">    SaveBase64(filename, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SaveBase64(const string&amp; filename, const BufferedTransformation&amp; bt)</span><br><span class="line">&#123;</span><br><span class="line">    Base64Encoder encoder;</span><br><span class="line"></span><br><span class="line">    bt.CopyTo(encoder);</span><br><span class="line">    encoder.MessageEnd();</span><br><span class="line"></span><br><span class="line">    Save(filename, encoder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PEM-Encoded-Keys"><a href="#PEM-Encoded-Keys" class="headerlink" title="PEM Encoded Keys"></a>PEM Encoded Keys</h2><p>Crypto++ 并不从 PEM 编码转换回来，或者转换出去。如果需要读写 PEM 编码的 KEY，有两种选择。</p>
<ol>
<li>添加 <a href="https://cryptopp.com/wiki/PEM_Pack" target="_blank" rel="noopener">PEM Pack</a> 到库中并重新编译。</li>
<li>使用下面的代码将 PEM 编码的 KEY 转换到 BER/DER 编码的 KEY，再使用 <code>BERDecodePrivateKey</code> 加载到 <code>PubliceKey</code> or <code>PrivateKey</code> 结构</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> RSA_PRIV_KEY =</span><br><span class="line">    <span class="string">"-----BEGIN RSA PRIVATE KEY-----\n"</span></span><br><span class="line">    <span class="string">"MIIBOgIBAAJBAK8Q+ToR4tWGshaKYRHKJ3ZmMUF6jjwCS/u1A8v1tFbQiVpBlxYB\n"</span></span><br><span class="line">    <span class="string">"paNcT2ENEXBGdmWqr8VwSl0NBIKyq4p0rhsCAQMCQHS1+3wL7I5ZzA8G62Exb6RE\n"</span></span><br><span class="line">    <span class="string">"INZRtCgBh/0jV91OeDnfQUc07SE6vs31J8m7qw/rxeB3E9h6oGi9IVRebVO+9zsC\n"</span></span><br><span class="line">    <span class="string">"IQDWb//KAzrSOo0P0yktnY57UF9Q3Y26rulWI6LqpsxZDwIhAND/cmlg7rUz34Pf\n"</span></span><br><span class="line">    <span class="string">"SmM61lJEmMEjKp8RB/xgghzmCeI1AiEAjvVVMVd8jCcItTdwyRO0UjWU4JOz0cnw\n"</span></span><br><span class="line">    <span class="string">"5BfB8cSIO18CIQCLVPbw60nOIpUClNxCJzmMLbsrbMcUtgVS6wFomVvsIwIhAK+A\n"</span></span><br><span class="line">    <span class="string">"YqT6WwsMW2On5l9di+RPzhDT1QdGyTI5eFNS+GxY\n"</span></span><br><span class="line">    <span class="string">"-----END RSA PRIVATE KEY-----"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> HEADER = <span class="string">"-----BEGIN RSA PRIVATE KEY-----"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> FOOTER = <span class="string">"-----END RSA PRIVATE KEY-----"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> pos1, pos2;</span><br><span class="line">pos1 = RSA_PRIV_KEY.find(HEADER);</span><br><span class="line"><span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"PEM header not found"</span>);</span><br><span class="line"></span><br><span class="line">pos2 = RSA_PRIV_KEY.find(FOOTER, pos1+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pos2 == <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"PEM footer not found"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start position and length</span></span><br><span class="line">pos1 = pos1 + HEADER.length();</span><br><span class="line">pos2 = pos2 - pos1;</span><br><span class="line"><span class="built_in">string</span> keystr = RSA_PRIV_KEY.substr(pos1, pos2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 decode, place in a ByteQueue</span></span><br><span class="line">ByteQueue <span class="built_in">queue</span>;</span><br><span class="line">Base64Decoder decoder;</span><br><span class="line"></span><br><span class="line">decoder.Attach(<span class="keyword">new</span> Redirector(<span class="built_in">queue</span>));</span><br><span class="line">decoder.Put((<span class="keyword">const</span> byte*)keystr.data(), keystr.length());</span><br><span class="line">decoder.MessageEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to file for inspection</span></span><br><span class="line"><span class="function">FileSink <span class="title">fs</span><span class="params">(<span class="string">"decoded-key.der"</span>)</span></span>;</span><br><span class="line"><span class="built_in">queue</span>.CopyTo(fs);</span><br><span class="line">fs.MessageEnd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    CryptoPP::RSA::PrivateKey rsaPrivate;</span><br><span class="line">    rsaPrivate.BERDecodePrivateKey(<span class="built_in">queue</span>, <span class="literal">false</span> <span class="comment">/*paramsPresent*/</span>, <span class="built_in">queue</span>.MaxRetrievable());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BERDecodePrivateKey is a void function. Here's the only check</span></span><br><span class="line">    <span class="comment">// we have regarding the DER bytes consumed.</span></span><br><span class="line">    ASSERT(<span class="built_in">queue</span>.IsEmpty());</span><br><span class="line"></span><br><span class="line">    AutoSeededRandomPool prng;</span><br><span class="line">    <span class="keyword">bool</span> valid = rsaPrivate.Validate(prng, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(!valid)</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"RSA private key is not valid"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N:"</span> &lt;&lt; rsaPrivate.GetModulus() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"E:"</span> &lt;&lt; rsaPrivate.GetPublicExponent() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"D:"</span> &lt;&lt; rsaPrivate.GetPrivateExponent() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> Exception&amp; ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 KEY 是用密码保护的，使用下面的 <a href="https://cryptopp.com/wiki/Keys_and_Formats#OpenSSL_Commands" target="_blank" rel="noopener">OpenSSL commands</a> 来移除密码并转换到 PKCS #8。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkcs8 -nocrypt -<span class="keyword">in</span> rsa-key.pem -inform PEM -topk8 -outform DER -out rsa-key.der</span><br></pre></td></tr></table></figure>
<h2 id="High-Level-Objects"><a href="#High-Level-Objects" class="headerlink" title="High Level Objects"></a>High Level Objects</h2><p>使用 Crypto++’s 的高级对象会显得很简单，如 <code>RSAES_PKCS1v15_Decryptor</code>, <code>RSAES_OAEP_SHA_Decryptor</code>, and <code>RSASSA_PKCS1v15_SHA_Signer</code> 来生成密钥对， 而不是使用 <code>RSA::PrivateKey</code>。这是因为高级的对象将拥有域相关问题的信息（及相关的逻辑），比如使用 <em>safe primes</em> versus <em>random primes</em>。有疑问的时候，就使用高级对象。</p>
<h3 id="Decryptors-and-Signers"><a href="#Decryptors-and-Signers" class="headerlink" title="Decryptors and Signers"></a>Decryptors and Signers</h3><p>通常来说， Crypto++的高级对象，如 <code>RSAES_OAEP_SHA_Decryptor</code> and <code>RSASSA_PKCS1v15_SHA_Signer</code> 拥有一个 <em>PrivateKey</em>。更正确点，decryptors 继承自 <code>PK_Decryptor</code> ， signers 继承自 <code>PK_Signer</code>，最终都是从 <code>PrivateKeyAlgorithm</code>  继承。See <a href="http://www.cryptopp.com/docs/ref/class_p_k___decryptor.html" target="_blank" rel="noopener">PK_Decryptor Class Reference</a>, <a href="http://www.cryptopp.com/docs/ref/class_p_k___signer.html" target="_blank" rel="noopener">PK_Signer Class Reference</a>, and <a href="http://www.cryptopp.com/docs/ref/class_private_key_algorithm.html" target="_blank" rel="noopener">PrivateKeyAlgorithm Class Reference</a>.</p>
<h3 id="Encryptors-and-Verifiers"><a href="#Encryptors-and-Verifiers" class="headerlink" title="Encryptors and Verifiers"></a>Encryptors and Verifiers</h3><p>类似于 decryptors and signers, Crypto++ 高级对象如 <code>RSAES_OAEP_SHA_Encryptor</code> and <code>RSASSA_PKCS1v15_SHA_Verifier</code> 拥有一个 <em>PublicKey</em>。Encryptors 继承自 <code>PK_Encryptor</code> ，verifiers 继承自<code>PK_Verifier</code>，它们最终都继承自 <code>PublicKeyAlgorithm</code>. See <a href="http://www.cryptopp.com/docs/ref/annotated.html" target="_blank" rel="noopener">PK_Encryptor Class Reference</a>, <a href="http://www.cryptopp.com/docs/ref/class_p_k___verifier.html" target="_blank" rel="noopener">PK_Verifier Class Reference</a>, and <a href="http://www.cryptopp.com/docs/ref/class_public_key_algorithm.html" target="_blank" rel="noopener">PublicKeyAlgorithm Class Reference</a>.</p>
<h3 id="RSAESOAEP-SHA-Encryptor-Decryptor"><a href="#RSAESOAEP-SHA-Encryptor-Decryptor" class="headerlink" title="RSAESOAEP_SHA{Encryptor|Decryptor}"></a>RSAES<em>OAEP_SHA</em>{Encryptor|Decryptor}</h3><p>下面展示了如何使用 <code>RSAES_OAEP_SHA_Decryptor</code> and <code>RSAES_OAEP_SHA_Encryptor</code>来创建一个公私钥对。 高级对象使用组合 (“HAS A”)，我们在 KEY 上调用方法前使用 <code>AccessKey</code> 来获取 KEY。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAES_OAEP_SHA_Decryptor rsaPrivate;</span><br><span class="line">rsaPrivate.AccessKey().GenerateRandomWithKeySize(rnd, 3072);</span><br><span class="line">RSAES_OAEP_SHA_Encryptor rsaPublic(rsaPrivate);</span><br><span class="line"></span><br><span class="line">SavePrivateKey(&quot;rsa-private.key&quot;, rsaPrivate.AccessKey());</span><br><span class="line">SavePublicKey(&quot;rsa-public.key&quot;, rsaPublic.AccessKey());</span><br></pre></td></tr></table></figure>
<h3 id="RSASSAPKCS1v15-SHA-Signer-Verifier"><a href="#RSASSAPKCS1v15-SHA-Signer-Verifier" class="headerlink" title="RSASSAPKCS1v15_SHA{Signer|Verifier}"></a>RSASSA<em>PKCS1v15_SHA</em>{Signer|Verifier}</h3><p>下面是介绍如何使用 <code>RSASSA_PKCS1v15_SHA_Signer</code> and <code>RSASSA_PKCS1v15_SHA_Verifier</code>建立公私钥对。这些对象也使用组合 (“HAS A”)，我们在 KEY 上调用方法前使用 <code>AccessKey</code> 来获取 KEY。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSASSA_PKCS1v15_SHA_Signer rsaPrivate;</span><br><span class="line">rsaPrivate.AccessKey().GenerateRandomWithKeySize(rnd, 3072);</span><br><span class="line">RSASSA_PKCS1v15_SHA_Verifier rsaPublic(rsaPrivate);</span><br><span class="line"></span><br><span class="line">SavePrivateKey(&quot;rsa-private.key&quot;, rsaPrivate.AccessKey());</span><br><span class="line">SavePublicKey(&quot;rsa-public.key&quot;, rsaPublic.AccessKey());</span><br></pre></td></tr></table></figure>
<h2 id="Dumping-PKCS-8-and-X-509-Keys"><a href="#Dumping-PKCS-8-and-X-509-Keys" class="headerlink" title="Dumping PKCS #8 and X.509 Keys"></a>Dumping PKCS #8 and X.509 Keys</h2><p>现在我们已经对 KEY 的格式有了点了解了，现在我们该更深入一些了。如果要 dump KEY， Peter Guttman’s <em><a href="http://www.cs.auckland.ac.nz/~pgut001/" target="_blank" rel="noopener">dumpasn1</a></em> 在命令行上工作得很好。 visual world, <a href="http://www.obj-sys.com/" target="_blank" rel="noopener">Objective Systems</a> has a free <a href="http://www.obj-sys.com/asn1-viewer.php" target="_blank" rel="noopener">ASN.1 Viewer</a>.</p>
<h3 id="RSA-PublicKey"><a href="#RSA-PublicKey" class="headerlink" title="RSA PublicKey"></a>RSA PublicKey</h3><p>重看 cryptopp-key-gen 保存 rsa-public.key 为 X.509 <em>PublicKeyInfo</em> 类型。在编程术语中，下面就是 <em>PublicKeyInfo</em> 大概的样子 (定义直接从 X.509 来)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PublicKeyInfo ::= SEQUENCE &#123;</span><br><span class="line">  algorithm AlgorithmIdentifier,</span><br><span class="line">  PublicKey BIT STRING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlgorithmIdentifier ::= SEQUENCE &#123;</span><br><span class="line">  algorithm ALGORITHM.id,</span><br><span class="line">  parameters ALGORITHM.type OPTIONAL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>X.509 规定，这个格式包含了一个内围的 <em>PublicKey</em>, 但并没有指定这个 <em>PublicKey</em>  是什么。因为 OID 的存在，对于 RSA 公钥，类型实际上是<em>RSAPublicKey</em>。在这个情况下，我们可以从 X.509 或 PKCS #1 获取定义 (他们是一样的):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAPublicKey ::= SEQUENCE &#123;</span><br><span class="line">  modulus INTEGER,</span><br><span class="line">  publicExponent INTEGER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数时候，公钥指数 <code>e</code>工作为一个库的标识符（使用默认值情况下）： Crypto++ 使用 17, GnuTLS, Java, and OpenSSL 使用 65537, and Microsoft’s .Net 使用 3。注意，<code>e</code>  在公钥中一般会是比较低的权重，这是为了加快计算速度。</p>
<p><a href="https://cryptopp.com/wiki/File:Rsa-public-dump.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/7/77/Rsa-public-dump.png" alt="ASN.1 dump of rsa-public.key"></a></p>
<p>上面就是一个 rsa 公钥的 dump 截图。<em>PublicKeyInfo</em> 从 0 字节开始，有 221 字节长，这是一个 ASN.1 序列。一个嵌套的序列从 偏移 3 开始，隐含表明第一个序列是 3 字节。第二个序列保存一个 OID: 1.2.840.113549.1.1.1,，这是一个 RSA KEY，还有一个 ASN.1 NULL (算法类型)。</p>
<p>从 偏移 18 开始（ 203 字节）， <em>RSAPublicKey</em> 开始。从上面的图上我们可以看出公钥的模，<code>n</code> 是 <code>00 F8 54 F4 ... D9 D2 15 CC ... DB 7C 5F 2D</code> (<em>dumpasn</em> -a 会将所有字节列出)。后面的就代表了公钥中的<code>e</code>，指数。</p>
<p>当无法解析某些 OID 的时候，可以通过 <a href="http://www.oid-info.com/" target="_blank" rel="noopener">OID Repository</a> 有的时候还需要搜索一下网页，才知道具体是什么。</p>
<h3 id="RSA-PrivateKey"><a href="#RSA-PrivateKey" class="headerlink" title="RSA PrivateKey"></a>RSA PrivateKey</h3><p><a href="https://cryptopp.com/wiki/File:Rsa-private-dump.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/thumb/b/b9/Rsa-private-dump.png/300px-Rsa-private-dump.png" alt="img"></a></p>
<p>使用 dumpasn1 dump RSA 私钥。</p>
<p>Dumping 一个 ASN.1 编码的私钥和公钥类似。. 格式是一个<em>PrivateKeyInfo</em> (不是 * <em>PublicKeyInfo</em>)。结构如下，包含了一个版本及可选的属性字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PrivateKeyInfo ::= SEQUENCE &#123;</span><br><span class="line">  version Version,</span><br><span class="line">  privateKeyAlgorithm PrivateKeyAlgorithmIdentifier,</span><br><span class="line">  privateKey PrivateKey,</span><br><span class="line">  attributes [0] IMPLICIT Attributes OPTIONAL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们关心的是被 <em>PrivateKeyInfo</em> 包围的 <em>PrivateKey</em> 。和 <em>PublicKey</em>  类似，, 因为 <em>PrivateKey</em> 有一个 RSA OID 在 <em>PrivateKeyInfo</em>，类型就是 <em>RSAPrivateKey</em>.</p>
<p>先就是包含一些我们常见概念的结构了：<code>e, d, p, q</code>。指数用来预计算一些东西，这样的话，KEY 的拥有者就不需要使用 <code>e, d, n</code>  和中国剩余定理来重新计算一些拥有的内部值了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAPrivateKey ::= SEQUENCE &#123;</span><br><span class="line">  version Version,</span><br><span class="line">  modulus INTEGER,</span><br><span class="line">  publicExponent INTEGER,</span><br><span class="line">  privateExponent INTEGER,</span><br><span class="line">  prime1 INTEGER,</span><br><span class="line">  prime2 INTEGER,</span><br><span class="line">  exponent1 INTEGER,</span><br><span class="line">  exponent2 INTEGER,</span><br><span class="line">  coefficient INTEGER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DSA-PublicKey"><a href="#DSA-PublicKey" class="headerlink" title="DSA PublicKey"></a>DSA PublicKey</h3><p><a href="https://cryptopp.com/wiki/File:Dsa-public-key.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/thumb/a/aa/Dsa-public-key.png/300px-Dsa-public-key.png" alt="img"></a>DSA public key</p>
<p>dump a DSA 的步骤和 RSA 类似。 DSA 的 OID 是 1.2.840.10040.4.1。DSA 会在 可选参数中包含 DSS 的域参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PublicKeyInfo ::= SEQUENCE &#123;</span><br><span class="line">  algorithm AlgorithmIdentifier,</span><br><span class="line">  PublicKey BIT STRING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlgorithmIdentifier ::= SEQUENCE &#123;</span><br><span class="line">  algorithm ALGORITHM.id,</span><br><span class="line">  parameters Dss-Parms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dss-Parms ::= SEQUENCE &#123;</span><br><span class="line">  p INTEGER,</span><br><span class="line">  q INTEGER,</span><br><span class="line">  g INTEGER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DSA 的公钥只是一个简单的指数 <code>Y</code>，通过 bit string 编码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DSAPublicKey ::= BITSTRING &#123;</span><br><span class="line">  publicExponent INTEGER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DSA-PrivateKey"><a href="#DSA-PrivateKey" class="headerlink" title="DSA PrivateKey"></a>DSA PrivateKey</h3><p><a href="https://cryptopp.com/wiki/File:Dsa-private-key.png" target="_blank" rel="noopener"><img src="https://cryptopp.com/w/images/thumb/5/58/Dsa-private-key.png/300px-Dsa-private-key.png" alt="img"></a>DSA private key</p>
<p>DSA 也使用 OID 1.2.840.10040.4.1 。公钥使用的是 <code>bit string</code>（编码公钥指数），私钥使用的是 <code>octect string</code>  来编码私钥指数 <code>X</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PrivateKeyInfo ::= SEQUENCE &#123;</span><br><span class="line">  version Version,</span><br><span class="line">  algorithm AlgorithmIdentifier,</span><br><span class="line">  PrivateKey OCTETSTRING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlgorithmIdentifier ::= SEQUENCE &#123;</span><br><span class="line">  algorithm ALGORITHM.id,</span><br><span class="line">  parameters Dss-Parms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dss-Parms ::= SEQUENCE &#123;</span><br><span class="line">  p INTEGER,</span><br><span class="line">  q INTEGER,</span><br><span class="line">  g INTEGER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DSAPrivateKey ::= OCTETSTRING &#123;</span><br><span class="line">  privateExponent INTEGER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OpenSSL-Commands"><a href="#OpenSSL-Commands" class="headerlink" title="OpenSSL Commands"></a>OpenSSL Commands</h2><p>下面提供的命令是为了让需要与 OpenSSL 库互操作的同学们使用。</p>
<p>默认情况下，Crypto++ 使用 DER 编码，而 OpenSSL 使用 PEM 编码。PEM 编码是一个 base64 编码，包括了头部和尾部。我们可以用 <code>-inform</code>  和 <code>-outform</code>  来在 DER 和 PEM 间转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out rsa-openssl.pem 256</span><br><span class="line">Generating RSA private key, 256 bit long modulus</span><br><span class="line">...</span><br><span class="line">$ cat rsa-openssl.pem</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIGrAgEAAiEA1+FPfSd+EaXYYU0LlPZ0K+k3uWFUb+s/8NxV9PEl1psCAwEAAQIg</span><br><span class="line">RjBfY9W/S4WcgKZIKbqnsjYuQO5nEAGAjx/XY9za48ECEQD2EpdAXBwXDBC9NQGD</span><br><span class="line">yUAJAhEA4JblIvDA6WOWr4KO79oCgwIQUfoFi3pkHUV2uiHTfFzqSQIRAJOcWamn</span><br><span class="line">VwOOgwGD6/JU9YUCEQDUVTl+0TNEiA3SbsvbRya7</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p><code>genpkey(1)</code> can also be used.</p>
<h3 id="RSA-Public-Key-SubjectPublicKeyInfo"><a href="#RSA-Public-Key-SubjectPublicKeyInfo" class="headerlink" title="RSA Public Key (SubjectPublicKeyInfo)"></a>RSA Public Key (<em>SubjectPublicKeyInfo</em>)</h3><p>下面的命令创建一个 PKCS #1/X.509 格式的公钥，它可以被 Crypto++ 使用。复习一下它的格式是 <em>SubjectPublicKeyInfo</em> 内含一个 OID (1.2.840.113549.1.1.1), 以及 <em>RSAPublicKey</em> (the inner key material).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out rsa-openssl.pem 3072</span><br><span class="line">$ openssl rsa -in rsa-openssl.pem -pubout -outform DER -out rsa-openssl.der</span><br></pre></td></tr></table></figure>
<h3 id="RSA-Private-Key-PrivateKeyInfo"><a href="#RSA-Private-Key-PrivateKeyInfo" class="headerlink" title="RSA Private Key (PrivateKeyInfo)"></a>RSA Private Key (<em>PrivateKeyInfo</em>)</h3><p>下面的命令创建一个未加密的 PKCS #8 格式 RSA 私钥，可以被 Crypto++ 使用。格式是 <em>PrivateKeyInfo</em> 加一个 OID (1.2.840.113549.1.1.1), version, and the <em>RSAPrivateKey</em> (the inner key material).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out rsa-openssl.pem 3072</span><br><span class="line">$ openssl pkcs8 -nocrypt -in rsa-openssl.pem -inform PEM -topk8 -outform DER -out rsa-openssl.der</span><br></pre></td></tr></table></figure>
<h3 id="DSA-Public-Key-SubjectPublicKeyInfo"><a href="#DSA-Public-Key-SubjectPublicKeyInfo" class="headerlink" title="DSA Public Key (SubjectPublicKeyInfo)"></a>DSA Public Key (<em>SubjectPublicKeyInfo</em>)</h3><p>PKCS #1/X.509 格式的 DSA 公钥，Crypto++ 可用。</p>
<p>格式：<em>SubjectPublicKeyInfo</em> 内有一个 OID (1.2.840.10040.4.1), DSS parameters, and the <em>DSAPublicKey</em> (the inner key material).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl dsaparam -out dsa-param-openssl.pem 1024</span><br><span class="line">$ openssl gendsa -out dsa-openssl.pem dsa-param-openssl.pem</span><br><span class="line">$ openssl dsa -in dsa-openssl.pem -pubout -outform DER -out dsa-openssl.der</span><br></pre></td></tr></table></figure>
<h3 id="DSA-Private-Key-PrivateKeyInfo"><a href="#DSA-Private-Key-PrivateKeyInfo" class="headerlink" title="DSA Private Key (PrivateKeyInfo)"></a>DSA Private Key (<em>PrivateKeyInfo</em>)</h3><p>PKCS #1/X.509 格式未加密的 DSA 私钥，Crypto++ 可用。</p>
<p>格式：<em>PrivateKeyInfo</em> 内一个 OID (1.2.840.10040.4.1), version, DSS parameters, and the <em>DSAPrivateKey</em> (the inner key material).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl dsaparam -out dsa-param-openssl.pem 1024</span><br><span class="line">$ openssl gendsa -out dsa-openssl.pem dsa-param-openssl.pem</span><br><span class="line">$ openssl pkcs8 -nocrypt -in dsa-openssl.pem -inform PEM -topk8 -outform DER -out dsa-openssl.der</span><br></pre></td></tr></table></figure>
<h3 id="ECC-Public-Key-SubjectPublicKeyInfo"><a href="#ECC-Public-Key-SubjectPublicKeyInfo" class="headerlink" title="ECC Public Key (SubjectPublicKeyInfo)"></a>ECC Public Key (<em>SubjectPublicKeyInfo</em>)</h3><p>The following commands create a ECC public key in PKCS #1/X.509 format which Crypto++ can consume. The curve is SEC’s prime 256.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl ecparam -param_enc explicit -name secp256k1 -genkey -outform PEM -out ec-openssl.pem</span><br><span class="line">$ openssl ec -param_enc explicit -inform PEM -in ec-openssl.pem -pubout -outform DER -out ec-openssl.der</span><br></pre></td></tr></table></figure>
<h3 id="ECC-Private-Key-PrivateKeyInfo"><a href="#ECC-Private-Key-PrivateKeyInfo" class="headerlink" title="ECC Private Key (PrivateKeyInfo)"></a>ECC Private Key (<em>PrivateKeyInfo</em>)</h3><p>The following command creates an unencrypted ECC private key in PKCS #8 format which Crypto++ can consume. The curve is SEC’s prime 256.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl ecparam -name secp256k1 -genkey -param_enc explicit -outform DER -out ec-openssl.der</span><br></pre></td></tr></table></figure>
<h2 id="GnuTLS-Commands"><a href="#GnuTLS-Commands" class="headerlink" title="GnuTLS Commands"></a>GnuTLS Commands</h2><p>The following GnuTLS commands should help those who use Gnu’s secure transport library, <a href="http://www.gnu.org/software/gnutls/" target="_blank" rel="noopener">GnuTLS</a>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gnutls-cli --version</span><br><span class="line">gnutls-cli (GnuTLS) 2.8.5</span><br><span class="line">Copyright (C) 2009 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">...</span><br><span class="line">Written by Nikos Mavrogiannopoulos.</span><br></pre></td></tr></table></figure>
<h3 id="RSA-Public-Key-SubjectPublicKeyInfo-1"><a href="#RSA-Public-Key-SubjectPublicKeyInfo-1" class="headerlink" title="RSA Public Key (SubjectPublicKeyInfo)"></a>RSA Public Key (<em>SubjectPublicKeyInfo</em>)</h3><p>According to Nikos Mavrogiannopoulos, GnuTLS 2.11 and above can use <code>certtool</code>‘s <code>--certificate-pubkey</code> switch. See <em><a href="http://lists.gnu.org/archive/html/help-gnutls/2010-11/msg00009.html" target="_blank" rel="noopener">How to Create/Derive DER Encoded Public Keys (PKCS #1/X.509 SubjectPublicKeyInfo)?</a></em>.</p>
<h3 id="RSA-Private-Key-PrivateKeyInfo-1"><a href="#RSA-Private-Key-PrivateKeyInfo-1" class="headerlink" title="RSA Private Key (PrivateKeyInfo)"></a>RSA Private Key (<em>PrivateKeyInfo</em>)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ certtool --generate-privkey --pkcs8 --outder --bits 3072 --outfile rsa-gnutls.der</span><br></pre></td></tr></table></figure>
<h3 id="DSA-Public-Key-SubjectPublicKeyInfo-1"><a href="#DSA-Public-Key-SubjectPublicKeyInfo-1" class="headerlink" title="DSA Public Key (SubjectPublicKeyInfo)"></a>DSA Public Key (<em>SubjectPublicKeyInfo</em>)</h3><p>According to Nikos Mavrogiannopoulos, GnuTLS 2.11 and above can use <code>certtool</code>‘s <code>--certificate-pubkey</code> switch. See <em><a href="http://lists.gnu.org/archive/html/help-gnutls/2010-11/msg00009.html" target="_blank" rel="noopener">How to Create/Derive DER Encoded Public Keys (PKCS #1/X.509 SubjectPublicKeyInfo)?</a></em>.</p>
<h3 id="DSA-Private-Key-PrivateKeyInfo-1"><a href="#DSA-Private-Key-PrivateKeyInfo-1" class="headerlink" title="DSA Private Key (PrivateKeyInfo)"></a>DSA Private Key (<em>PrivateKeyInfo</em>)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ certtool --dsa --generate-privkey --pkcs8 --outder --bits 1024 --outfile dsa-gnutls.der</span><br></pre></td></tr></table></figure>
<script src="https://unpkg.com/viz.js@2.1.2/viz.js"></script><script src="https://unpkg.com/viz.js@2.1.2/full.render.js"></script>                <script>
                // graphviz init
                let graphviz_engines = ["circo",
                    "dot",
                    "fdp",
                    "neato",
                    "osage",
                    "twopi"];

                function doGraphviz(engine) {
                    let domAllDot = document.querySelectorAll('.language-' + engine);
                    for (let i = 0; i < domAllDot.length; i++) {
                        let dom = domAllDot[i];
                        let graphSource = dom.innerText || dom.textContent;

                        try {
                           let viz = new Viz();
                             viz.renderSVGElement(graphSource, {engine: engine})
                                 .then(r => {
                            dom.innerHTML ='';dom.append(r); });
                        } catch (e) {
                            console.error("Error when parsing node:", dom, e);
                        } 
                    }
                } 

                let init = function () {
                    for (let i = 0; i < graphviz_engines.length; i++) {
                        doGraphviz(graphviz_engines[i]);
                    }
                };
                if (typeof window.addEventListener != "undefined") {
                    window.addEventListener("load", init, false);
                } else {
                    window.attachEvent("onload", init);
                }
                </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Cpp/" rel="tag"># Cpp</a>
              <a href="/tags/Crypto/" rel="tag"># Crypto++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Cpp/C++中的流式IO-StreamIO.html" rel="next" title="C++中的流式IO-StreamIO">
                  <i class="fa fa-chevron-left"></i> C++中的流式IO-StreamIO
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RAS-简单介绍"><span class="nav-number">1.</span> <span class="nav-text">RAS 简单介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Crypto-实现"><span class="nav-number">2.</span> <span class="nav-text">Crypto++ 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Keys"><span class="nav-number">2.1.</span> <span class="nav-text">Keys</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加密-Encryption"><span class="nav-number">2.2.</span> <span class="nav-text">加密 Encryption</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#签名-Signature"><span class="nav-number">2.3.</span> <span class="nav-text">签名 Signature</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子"><span class="nav-number">2.4.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#密钥生成"><span class="nav-number">2.4.1.</span> <span class="nav-text">密钥生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#密钥生成的性能"><span class="nav-number">2.4.2.</span> <span class="nav-text">密钥生成的性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Encryption-Scheme-OAEP-using-SHA"><span class="nav-number">2.4.3.</span> <span class="nav-text">Encryption Scheme (OAEP using SHA)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signature-Scheme-PKCS-v1-5"><span class="nav-number">2.4.4.</span> <span class="nav-text">Signature Scheme (PKCS v1.5)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Keys-and-Formats"><span class="nav-number">3.</span> <span class="nav-text">Keys and Formats</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Crypto-Key-Formats"><span class="nav-number">3.1.</span> <span class="nav-text">Crypto++ Key Formats</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Private-Key-Format"><span class="nav-number">3.1.1.</span> <span class="nav-text">Private Key Format</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Key-Format"><span class="nav-number">3.1.2.</span> <span class="nav-text">Public Key Format</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Crypto-PKCS8PrivateKey"><span class="nav-number">3.1.3.</span> <span class="nav-text">Crypto++ PKCS8PrivateKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Crypto-X509PublicKey"><span class="nav-number">3.1.4.</span> <span class="nav-text">Crypto++ X509PublicKey</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generating-Validating-Saving-and-Loading-Keys"><span class="nav-number">3.2.</span> <span class="nav-text">Generating, Validating, Saving, and Loading Keys</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Generating-Keys"><span class="nav-number">3.2.1.</span> <span class="nav-text">Generating Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Saving-Keys"><span class="nav-number">3.2.2.</span> <span class="nav-text">Saving Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loading-Keys"><span class="nav-number">3.2.3.</span> <span class="nav-text">Loading Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Validating-Keys"><span class="nav-number">3.2.4.</span> <span class="nav-text">Validating Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GnuPG-ElGamal-Keys"><span class="nav-number">3.2.5.</span> <span class="nav-text">GnuPG ElGamal Keys</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BER-and-DER-Encoding"><span class="nav-number">3.3.</span> <span class="nav-text">BER and DER Encoding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DER-Encoding"><span class="nav-number">3.3.1.</span> <span class="nav-text">DER Encoding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BER-Decoding"><span class="nav-number">3.3.2.</span> <span class="nav-text">BER Decoding</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hex-and-Base64-Encoding"><span class="nav-number">3.4.</span> <span class="nav-text">Hex and Base64 Encoding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hex-Encoding-and-Decoding"><span class="nav-number">3.4.1.</span> <span class="nav-text">Hex Encoding and Decoding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base64-Encoding-and-Decoding"><span class="nav-number">3.4.2.</span> <span class="nav-text">Base64 Encoding and Decoding</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PEM-Encoded-Keys"><span class="nav-number">3.5.</span> <span class="nav-text">PEM Encoded Keys</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#High-Level-Objects"><span class="nav-number">3.6.</span> <span class="nav-text">High Level Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Decryptors-and-Signers"><span class="nav-number">3.6.1.</span> <span class="nav-text">Decryptors and Signers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Encryptors-and-Verifiers"><span class="nav-number">3.6.2.</span> <span class="nav-text">Encryptors and Verifiers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSAESOAEP-SHA-Encryptor-Decryptor"><span class="nav-number">3.6.3.</span> <span class="nav-text">RSAESOAEP_SHA{Encryptor|Decryptor}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSASSAPKCS1v15-SHA-Signer-Verifier"><span class="nav-number">3.6.4.</span> <span class="nav-text">RSASSAPKCS1v15_SHA{Signer|Verifier}</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dumping-PKCS-8-and-X-509-Keys"><span class="nav-number">3.7.</span> <span class="nav-text">Dumping PKCS #8 and X.509 Keys</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-PublicKey"><span class="nav-number">3.7.1.</span> <span class="nav-text">RSA PublicKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-PrivateKey"><span class="nav-number">3.7.2.</span> <span class="nav-text">RSA PrivateKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSA-PublicKey"><span class="nav-number">3.7.3.</span> <span class="nav-text">DSA PublicKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSA-PrivateKey"><span class="nav-number">3.7.4.</span> <span class="nav-text">DSA PrivateKey</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenSSL-Commands"><span class="nav-number">3.8.</span> <span class="nav-text">OpenSSL Commands</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-Public-Key-SubjectPublicKeyInfo"><span class="nav-number">3.8.1.</span> <span class="nav-text">RSA Public Key (SubjectPublicKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-Private-Key-PrivateKeyInfo"><span class="nav-number">3.8.2.</span> <span class="nav-text">RSA Private Key (PrivateKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSA-Public-Key-SubjectPublicKeyInfo"><span class="nav-number">3.8.3.</span> <span class="nav-text">DSA Public Key (SubjectPublicKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSA-Private-Key-PrivateKeyInfo"><span class="nav-number">3.8.4.</span> <span class="nav-text">DSA Private Key (PrivateKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECC-Public-Key-SubjectPublicKeyInfo"><span class="nav-number">3.8.5.</span> <span class="nav-text">ECC Public Key (SubjectPublicKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECC-Private-Key-PrivateKeyInfo"><span class="nav-number">3.8.6.</span> <span class="nav-text">ECC Private Key (PrivateKeyInfo)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GnuTLS-Commands"><span class="nav-number">3.9.</span> <span class="nav-text">GnuTLS Commands</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-Public-Key-SubjectPublicKeyInfo-1"><span class="nav-number">3.9.1.</span> <span class="nav-text">RSA Public Key (SubjectPublicKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-Private-Key-PrivateKeyInfo-1"><span class="nav-number">3.9.2.</span> <span class="nav-text">RSA Private Key (PrivateKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSA-Public-Key-SubjectPublicKeyInfo-1"><span class="nav-number">3.9.3.</span> <span class="nav-text">DSA Public Key (SubjectPublicKeyInfo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSA-Private-Key-PrivateKeyInfo-1"><span class="nav-number">3.9.4.</span> <span class="nav-text">DSA Private Key (PrivateKeyInfo)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gowa2017 Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">375</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">159</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gowa2017" title="GitHub → https://github.com/gowa2017" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shouzheng.zhang@gmail.com" title="E-Mail → mailto:shouzheng.zhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-json"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gowa2017 Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>














  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gowa-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://gowa.club/Cpp/RSA及相关库实现.html",
            identifier: "Cpp/RSA及相关库实现.html",
            title: "RSA及相关库实现"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gowa-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
</script>

</body>
</html>
