<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>skynet中sproto使用示例 | 退思园</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">skynet中sproto使用示例</h1><a id="logo" href="/.">退思园</a><p class="description">烦恼一般都是想太多了。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/workflow"><i class="fa fa-rss"> workflow</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">skynet中sproto使用示例</h1><div class="post-meta"><a href="/Lua/skynet中sproto使用示例.html#comments" class="comment-count"><i data-disqus-identifier="Lua/skynet中sproto使用示例.html" class="disqus-comment-count"></i>留言</a><p><span class="date">Feb 16, 2018</span><span><a href="/categories/Lua/" class="category">Lua</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>Sproto是一个用C编写的高效序列化库，主要是想用来做Lua绑定。类似Google的 protocol buffers，但是速度更快。其设计得非常简单。只支持Lua支持的几种数据类型，其可以很容易的绑定到其他动态语言，或者直接在C中使用。<br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>其项目开源到 <a href="https://github.com/cloudwu/sproto" target="_blank" rel="noopener">github.com/cloudwu/sproto</a></p>
<p>其主要包含一些提供给 Lua 使用的 API，一个语法解析模块(parser) <code>sprotoparser</code>，还有一个RPC API，加上 C库。</p>
<h1 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> parser = <span class="built_in">require</span> <span class="string">"sprotoparser"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>parser.parse</code> 把一个sproto 协议框架解析为一个二进制字符串</li>
</ul>
<p>在解析的时候需要用到这个。可以用它来产生二进制字符串。框架文本和解析器在程序运行的时候并不需要</p>
<h1 id="Lua-API"><a href="#Lua-API" class="headerlink" title="Lua API"></a>Lua API</h1><p>我们先看看看它提供给 Lua 使用的API。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> sproto = <span class="built_in">require</span> <span class="string">"sproto"</span></span><br><span class="line"><span class="keyword">local</span> sprotocore = <span class="built_in">require</span> <span class="string">"sproto.core"</span> <span class="comment">-- optional</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>sproto.parse(schema)</strong> 通过一个 文本字符串 的框架生成一个 sproto 对象。</li>
<li><strong>sproto.new(spbin)</strong> 通过一个 二进制的字符串（parser生成） 生成一个 sproto 对象。</li>
<li><strong>sprotocore.newproto(spbin)</strong> 通过一个 二进制的字符串（parser生成） 生成一个 C sproto 对象。</li>
<li><strong>sproto.sharenew(spbin)</strong> 从一个 sproto C 对象（sprotocore.newproto()生成）共享一个 sproto 对象。</li>
<li><strong>sproto:exist_type(typename)</strong> 检查sproto对象中是否存在此类型。</li>
<li><strong>sproto:encode(typename, luatable)</strong> 把一个Lua表以 <em>typename</em> 编码到二进制字符串内。</li>
<li><strong>sproto:decode(typename, blob [,sz])</strong> 以<em>typename</em>来解码一个 <code>sproto:encode()</code>产生的二进制字符串。如果 <em>blob</em> 是一个 lightuserdata (C 指针），<em>sz</em> 是必须的。</li>
<li><strong>sproto:pencode(typename, luatable)</strong> 类似<code>sproto:encode</code>，但是会压缩结果。</li>
<li><strong>sproto:pdecode(typename, blob [,sz])</strong> 类似 <code>sproto.decode</code>，但是会先解压缩对象。</li>
<li><strong>sproto:default(typename, type)</strong> 以类型名的默认值来建立一个表。类型可以是 <em>nil, REQUEST, RESPONSE</em>。</li>
</ul>
<h1 id="RPC-API"><a href="#RPC-API" class="headerlink" title="RPC API"></a>RPC API</h1><p>这些API是对 core API的封装。</p>
<p><strong><code>sproto:host([packagename])</code></strong> 以 <em>packagename</em> 建立一个宿主对象 <em>host</em> 来传输RPC消息。</p>
<p><strong><code>host:dispatch(blob [,sz])</code></strong> 以 <em>host</em> 对象内的（packagename）来解压并解码（<code>sproto:pdecode</code>）二进制字符串。</p>
<p>如果 <em>.type</em> 存在，这是一个 有<em>.type</em> <code>REQUEST</code> 消息，返回<em>REQUEST, protoname, message, responser, .ud</em>。<em>responser</em>是一个用来编码 响应消息的函数。 当<em>.session</em>不存在时，<em>responser</em>将会是 <em>nil</em>。</p>
<p>如果 <em>.type</em> 不存在，这是一个给 <em>.session</em> 的 <code>RESPONSE</code>消息。返回 <em>REPONSE, .session, message, .ud</em>。</p>
<p><strong><code>host:attach(sprotoobj)</code></strong> 建立一个以 <em>sprotoobj</em> 来压缩和编码请求消息的函数 <code>function(protoname, message, session, ud)</code>。</p>
<p>如果不想使用主机对象，可以用下面的API来编码和解码RPC消息。</p>
<p><strong><code>sproto:request_encode(protoname, tbl)</code></strong> 以<em>protoname</em> 来编码一个请求消息。</p>
<p><strong><code>sproto:response_encode(protoname, tbl)</code></strong> 以<em>protoname</em> 来编码一个响应消息。</p>
<p><strong><code>sproto:request_decode(protoname, blob [,sz])</code></strong> 解码一个请求消息。</p>
<p><strong><code>sproto:response_decode(protoname, blob [,sz]</code></strong> 解码一个响应消息</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li><strong>string</strong> : string</li>
<li><strong>binary</strong> : binary string (字符串的子类型)</li>
<li><strong>integer</strong> : 整型，最大整型是有符号64位的。 可以是一个不动点的特定精度的数字。</li>
<li><strong>boolean</strong> : true or false</li>
</ul>
<p>在类型前面添加一个 <code>*</code> 来表示一个数组。</p>
<p>可以指定一个主索引，数组将会被编码成一个无序的 map。</p>
<p>用户定义的类型可以是任何非保留的名字，也支持嵌套类型。</p>
<p>没有双精度或者实数类型。作者认为，这些类型非常少使用。如果果真需要的话，可以用字符串来序列化双精度数。如果需要十进制数，可以指定固定的精度。</p>
<p>枚举类型并不十分实用。我们在Lua定义一个 enum 表来实现。</p>
<h1 id="协议定义"><a href="#协议定义" class="headerlink" title="协议定义"></a>协议定义</h1><p>sproto是一个协议封装库。所以我们要定义我们自己的协议格式(schema)。</p>
<p>sproto消息是强类型的，而且不是自描述的。所以必须用一个特殊的语言来定义我们自己的消息结构。</p>
<p>然后调用 <em>sprotoparser</em> 来把 协议格式 解析为二进制字符串，这样 sproto 库就可以使用它。</p>
<p>可以离线解析，然后保存这些字符串，或者可以在程序运行的时候解析。</p>
<p>一个协议框架可能会像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注释</span><br><span class="line"></span><br><span class="line">.Person &#123;	# . 表示一个用户定义数据类型</span><br><span class="line">    name 0 : string	# 内建数据类型 string</span><br><span class="line">    id 1 : integer</span><br><span class="line">    email 2 : string</span><br><span class="line"></span><br><span class="line">    .PhoneNumber &#123;	# 可以嵌套用户自定义数据类型</span><br><span class="line">        number 0 : string</span><br><span class="line">        type 1 : integer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    phone 3 : *PhoneNumber	# *PhoneNumber 表示数组</span><br><span class="line">    height 4 : integer(2)	# (2) means a 1/100 精度的数    data 5 : binary		# 二进制数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.AddressBook &#123;</span><br><span class="line">    person 0 : *Person(id)	# (id) 可选， Person.id 是一个主索引&#125;</span><br><span class="line"></span><br><span class="line">foobar 1 &#123;	# 定义一个新协议  (for RPC used)  tag 1</span><br><span class="line">    request Person	# 把数据类型 Person与 foobar.request 相关联 </span><br><span class="line">    response &#123;	# 定义 foobar.response 的数据类型 </span><br><span class="line">        ok 0 : boolean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个框架可以是 被 sproto 框架语言自描述的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.type &#123;</span><br><span class="line">    .field &#123;</span><br><span class="line">        name 0 : string</span><br><span class="line">        buildin	1 : integer</span><br><span class="line">        type 2 : integer	# type is fixed-point number precision when buildin is SPROTO_TINTEGER; When buildin is SPROTO_TSTRING, it means binary string when type is 1.</span><br><span class="line">        tag 3 : integer</span><br><span class="line">        array 4	: boolean</span><br><span class="line">        key 5 : integer # If key exists, array must be true, and it&apos;s a map.</span><br><span class="line">    &#125;</span><br><span class="line">    name 0 : string</span><br><span class="line">    fields 1 : *field</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.protocol &#123;</span><br><span class="line">    name 0 : string</span><br><span class="line">    tag 1 : integer</span><br><span class="line">    request 2 : integer # index</span><br><span class="line">    response 3 : integer # index</span><br><span class="line">    confirm 4 : boolean # response nil where confirm == true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.group &#123;</span><br><span class="line">    type 0 : *type</span><br><span class="line">    protocol 1 : *protocol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Wire-protocol"><a href="#Wire-protocol" class="headerlink" title="Wire protocol"></a>Wire protocol</h1><p>每个整数以小端（little endian）格式序列化。</p>
<p>sproto消息必须是一个用户定义类型结构，每个结构编码成三个部分。<em>header, field, data</em>（头部，字段，数据）。标签（tag）和 小的整数 或 布尔值 会被编码到 field 部分，其他的都在 data 部分。</p>
<p>所有的字段必须以升序编码（通过 标签 tag，从0开始）。当有字段是 <em>nil</em>的时候（lua中的默认值），不要在消息中进行编码。 字段的标签因此可能是不连续的。</p>
<p>头部（header）是一个16bit整数。就是字段数两。</p>
<p>字段部分的所有字段都是一个 16bit 整数(n)。如果 <em>n</em> 为0，表示这个字段的数据编码在数据部分；</p>
<p>如果 <em>n</em> 是不为0的偶数，字段的值是 <em>n/2-1</em>，tag（标签）会增加1；<br>如果 <em>n</em> 是奇数，表示标签是不连续的，我们应该把当前标签 增加 <em>(n+1)/2</em>。</p>
<p>数组总是被编码到数据部分，4 bytes来表示大小，接下来的字节就是内容。（len-value)二元组。查看 例子2 来了解 结构数组； 例子 3/4 展示整数数组； 例子5 是布尔数组。</p>
<p>对于一个整型数组，一个额外的字节(4 or 8)来表示这个值是 32bit还是 64bit。</p>
<p>查看下面的例子。</p>
<blockquote>
<p>注意：如果 标签没有在 框架内声明，解码器为了协议版本的兼容，会忽略那些字段。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.Person &#123;</span><br><span class="line">    name 0 : string</span><br><span class="line">    age 1 : integer</span><br><span class="line">    marital 2 : boolean</span><br><span class="line">    children 3 : *Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Data &#123;</span><br><span class="line">	numbers 0 : *integer</span><br><span class="line">	bools 1 : *boolean</span><br><span class="line">	number 2 : integer</span><br><span class="line">	bignumber 3 : integer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person &#123; name = &quot;Alice&quot; ,  age = 13, marital = false &#125; </span><br><span class="line"></span><br><span class="line">03 00 (fn = 3)</span><br><span class="line">00 00 (id = 0, value in data part)</span><br><span class="line">1C 00 (id = 1, value = 13)</span><br><span class="line">02 00 (id = 2, value = false)</span><br><span class="line">05 00 00 00 (sizeof &quot;Alice&quot;)</span><br><span class="line">41 6C 69 63 65 （“Alice)</span><br></pre></td></tr></table></figure>
<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person &#123;</span><br><span class="line">    name = &quot;Bob&quot;,</span><br><span class="line">    age = 40,</span><br><span class="line">    children = &#123;</span><br><span class="line">        &#123; name = &quot;Alice&quot; ,  age = 13 &#125;,</span><br><span class="line">        &#123; name = &quot;Carol&quot; ,  age = 5 &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">04 00 (fn = 4)</span><br><span class="line">00 00 (id = 0, value in data part)</span><br><span class="line">52 00 (id = 1, value = 40)</span><br><span class="line">01 00 (skip id = 2)</span><br><span class="line">00 00 (id = 3, value in data part)</span><br><span class="line"></span><br><span class="line">03 00 00 00 (sizeof &quot;Bob&quot;)</span><br><span class="line">42 6F 62 (&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">26 00 00 00 (sizeof children)</span><br><span class="line"></span><br><span class="line">0F 00 00 00 (sizeof child 1)</span><br><span class="line">02 00 (fn = 2)</span><br><span class="line">00 00 (id = 0, value in data part)</span><br><span class="line">1C 00 (id = 1, value = 13)</span><br><span class="line">05 00 00 00 (sizeof &quot;Alice&quot;)</span><br><span class="line">41 6C 69 63 65 (&quot;Alice&quot;)</span><br><span class="line"></span><br><span class="line">0F 00 00 00 (sizeof child 2)</span><br><span class="line">02 00 (fn = 2)</span><br><span class="line">00 00 (id = 0, value in data part)</span><br><span class="line">0C 00 (id = 1, value = 5)</span><br><span class="line">05 00 00 00 (sizeof &quot;Carol&quot;)</span><br><span class="line">43 61 72 6F 6C (&quot;Carol&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#123;</span><br><span class="line">    numbers = &#123; 1,2,3,4,5 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">01 00 (fn = 1)</span><br><span class="line">00 00 (id = 0, value in data part)</span><br><span class="line"></span><br><span class="line">15 00 00 00 (sizeof numbers)</span><br><span class="line">04 ( sizeof int32 )</span><br><span class="line">01 00 00 00 (1)</span><br><span class="line">02 00 00 00 (2)</span><br><span class="line">03 00 00 00 (3)</span><br><span class="line">04 00 00 00 (4)</span><br><span class="line">05 00 00 00 (5)</span><br></pre></td></tr></table></figure>
<h2 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#123;</span><br><span class="line">    numbers = &#123;</span><br><span class="line">        (1&lt;&lt;32)+1,</span><br><span class="line">        (1&lt;&lt;32)+2,</span><br><span class="line">        (1&lt;&lt;32)+3,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">01 00 (fn = 1)</span><br><span class="line">00 00 (id = 0, value in data part)</span><br><span class="line"></span><br><span class="line">19 00 00 00 (sizeof numbers)</span><br><span class="line">08 ( sizeof int64 )</span><br><span class="line">01 00 00 00 01 00 00 00 ( (1&lt;32) + 1)</span><br><span class="line">02 00 00 00 01 00 00 00 ( (1&lt;32) + 2)</span><br><span class="line">03 00 00 00 01 00 00 00 ( (1&lt;32) + 3)</span><br></pre></td></tr></table></figure>
<h1 id="例子-5"><a href="#例子-5" class="headerlink" title="例子 5:"></a>例子 5:</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#123;</span><br><span class="line">    bools = &#123; false, true, false &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">02 00 (fn = 2)</span><br><span class="line">01 00 (skip id = 0)</span><br><span class="line">00 00 (id = 1, value in data part)</span><br><span class="line"></span><br><span class="line">03 00 00 00 (sizeof bools)</span><br><span class="line">00 (false)</span><br><span class="line">01 (true)</span><br><span class="line">00 (false)</span><br></pre></td></tr></table></figure>
<h1 id="例子-6"><a href="#例子-6" class="headerlink" title="例子 6:"></a>例子 6:</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#123;</span><br><span class="line">    number = 100000,</span><br><span class="line">    bignumber = -10000000000,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">03 00 (fn = 3)</span><br><span class="line">03 00 (skip id = 1)</span><br><span class="line">00 00 (id = 2, value in data part)</span><br><span class="line">00 00 (id = 3, value in data part)</span><br><span class="line"></span><br><span class="line">04 00 00 00 (sizeof number, data part)</span><br><span class="line">A0 86 01 00 (100000, 32bit integer)</span><br><span class="line"></span><br><span class="line">08 00 00 00 (sizeof bignumber, data part)</span><br><span class="line">00 1C F4 AB FD FF FF FF (-10000000000, 64bit integer)</span><br></pre></td></tr></table></figure>
<h1 id="0-Packing"><a href="#0-Packing" class="headerlink" title="0 Packing"></a>0 Packing</h1><p>算法类似 <a href="http://kentonv.github.io/capnproto/" target="_blank" rel="noopener">Cap’n proto</a>,但是不特别对待 <em>0x00</em>。</p>
<p>在打包的格式中，消息会被填充到8。每个标签背后的都是8字节的倍数。</p>
<p>标签字节的位对应了未打包字的字节数，最不重要的位对应第一个字节。</p>
<p>每个为0的位表示对应的字节是0。而非0的字节被打包到 标签后面。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unpacked (hex):  08 00 00 00 03 00 02 00   19 00 00 00 aa 01 00 00</span><br><span class="line">packed (hex):  51 08 03 02   31 19 aa 01</span><br></pre></td></tr></table></figure>
<p><em>0xff</em> 标签会被特别对待。一个数字 <em>N</em> 会跟在 <em>0xff</em> 标签后面，表示 <em>(N+1)\</em>8* 字节应该被直接复制。</p>
<p>字节可能包含也可能不包含0值。因为这个规则，最行的空间浪费就是每2 KB输入只打包了 2字节数据。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unpacked (hex):  8a (x 30 bytes)</span><br><span class="line">packed (hex):  ff 03 8a (x 30 bytes) 00 00</span><br></pre></td></tr></table></figure>
<h1 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct sproto * <span class="title">sproto_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * proto, <span class="keyword">size_t</span> sz)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以一个被 sprotoparser 编码的 框架字符串来建立一个 sproto 对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sproto_release</span><span class="params">(struct sproto *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>释放sproto object:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sproto_prototag</span><span class="params">(struct sproto *, <span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">sproto_protoname</span><span class="params">(struct sproto *, <span class="keyword">int</span> proto)</span></span>;</span><br><span class="line"><span class="comment">// SPROTO_REQUEST(0) : request, SPROTO_RESPONSE(1): response</span></span><br><span class="line"><span class="function">struct sproto_type * <span class="title">sproto_protoquery</span><span class="params">(struct sproto *, <span class="keyword">int</span> proto, <span class="keyword">int</span> what)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在一个协议的 标签和名字间转换，并查询对象的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct sproto_type * <span class="title">sproto_type</span><span class="params">(struct sproto *, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">typename</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从一个sproto对象查询类型对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sproto_arg</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *ud;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *tagname;</span><br><span class="line">	<span class="keyword">int</span> tagid;</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sproto_type</span> *<span class="title">subtype</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *value;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> index;	<span class="comment">// array base 1</span></span><br><span class="line">	<span class="keyword">int</span> mainindex;	<span class="comment">// for map</span></span><br><span class="line">	<span class="keyword">int</span> extra; <span class="comment">// SPROTO_TINTEGER: fixed-point presision ; SPROTO_TSTRING 0:utf8 string 1:binary</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*sproto_callback)</span><span class="params">(<span class="keyword">const</span> struct sproto_arg *args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sproto_decode</span><span class="params">(struct sproto_type *, <span class="keyword">const</span> <span class="keyword">void</span> * data, <span class="keyword">int</span> size, sproto_callback cb, <span class="keyword">void</span> *ud)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sproto_encode</span><span class="params">(struct sproto_type *, <span class="keyword">void</span> * buffer, <span class="keyword">int</span> size, sproto_callback cb, <span class="keyword">void</span> *ud)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以一个用户定义的回调函数编码和解码 sproto 消息。查看 lsproto.c的实现来看更多的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sproto_pack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">int</span> srcsz, <span class="keyword">void</span> * buffer, <span class="keyword">int</span> bufsz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sproto_unpack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">int</span> srcsz, <span class="keyword">void</span> * buffer, <span class="keyword">int</span> bufsz)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以 0 packing 算法来打包和解包消息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在TCP连接上，我们发送和读取的的数据，都是连续的字节流。我们无法知道我应该读取的内容到底是什么，内容到底是什么，是由我们自己定义的协议所确定的。</p>
<p>而在基本的套接字编程示例中，我们都是调用系统的 <code>read(int fd, void * buffer, ssize_t sz)</code> 来将从文件描述符上将内存缓冲区的数据，读到我们自己的缓冲区内。</p>
<p>对此，在skynet的使用示例中，其把每个消息的前两个字节定义为 消息的长度，后面跟上真正的消息内容。</p>
<p>然后在我们以我们指定的协议进行解码。协议内容总是会包含一个协议头部：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.package &#123;</span><br><span class="line">    type 0 : integer--消息类型</span><br><span class="line">    session 1 : integer--回应消息对应的关系</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟上真正的协议内容，然后以 <code>0-packing</code>方式打包。</p>
<p>?type 的值，表明了我们定义的协议中类型的标签值？</p>
<h1 id="消息类型与请求类型"><a href="#消息类型与请求类型" class="headerlink" title="消息类型与请求类型"></a>消息类型与请求类型</h1><p>在<a href="https://blog.codingnow.com/2015/04/sproto_rpc.html" target="_blank" rel="noopener">云风的博客上</a>提到：</p>
<blockquote>
<p>对于 request/response 的 RPC 方案，除了消息本身打包外，还有两个重要的信息需要传输。它们分别是请求的类型以及请求的 session 。<br>不要把请求的类型和消息的类型混为一谈。因为不同的请求可以用相同的消息类型，所以在 sproto 中，需要对 rpc 请求额外编码。你也不一定为每个请求额外设计一个消息类型，可以直接在定义 rpc 协议时内联写上请求（以及回应）的消息结构。</p>
<p>通常，我们用数字作为消息类型的标识，当然你也可以使用字符串。在用类 json 的无 schema 的协议中使用字符串多一些，但在 sproto 这种带 schema 的协议中，使用数字会更高效。同样，session 作为一条消息的唯一标识，你也可以用数字或字符串。而生成唯一数字 session 更容易，编码也更高效。</p>
<p>所以，每当我们发送一次远程请求，需要传输的数据就有三项：请求的类型、一个请求方自己保证唯一的 session id 以及请求的数据内容。</p>
<p>服务方收到请求后，应根据请求的类型对请求的数据内容解码，并根据类型分发给相应的处理器。同时应该把 session id 记录下来。等处理器处理完毕后，根据类型去打包回应的消息，并附加上 session id ，发送回客户端。</p>
<p>注意：回应是不需要传输消息类型的。这是因为 session id 就唯一标识了这是对哪一条请求的回应。而 session id 是客户端保证唯一的，它在产生 session id 时，就保存了这个 session 对应的请求的类型，所以也就有能力对回应消息解码。</p>
<p>btw ，如果只是单向推送消息（也就是 publish/subscribe 模式），直接省略 session 就可以了，也不需要回应。</p>
</blockquote>
<p>在上面一节中，我们说道  <code>.package</code> 就是一个我们定义的消息类型，而其中的 <code>type</code> 字段，定义了我们的请求类型。</p>
<p>对于每个包，都以这个 package 开头，后面接上 (padding）消息体。最后连在一起，用 sproto 自带的 0-pack 方式压缩。</p>
<p>我们可以这样理解：</p>
<p>消息类型 <code>.package</code> 定义了我们消息包含的内容。</p>
<p>而 <code>.type</code> 定义了我们消息内容是怎么表示的。</p>
<h1 id="client-lua-使用示例"><a href="#client-lua-使用示例" class="headerlink" title="client.lua 使用示例"></a>client.lua 使用示例</h1><p>我们先来看一下一般性的代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加载 socket, proto, sproto 库</span></span><br><span class="line"><span class="keyword">local</span> socket = <span class="built_in">require</span> <span class="string">"client.socket"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- proto是我们自己定义的协议库（模块）</span></span><br><span class="line"><span class="keyword">local</span> proto = <span class="built_in">require</span> <span class="string">"proto"</span></span><br><span class="line"><span class="keyword">local</span> sproto = <span class="built_in">require</span> <span class="string">"sproto"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> host = sproto.new(proto.s2c):host <span class="string">"package"</span></span><br><span class="line"><span class="keyword">local</span> request = host:attach(sproto.new(proto.c2s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> fd = <span class="built_in">assert</span>(socket.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br></pre></td></tr></table></figure>
<p>首先，我们先要定义我们的协议，然后通过 parser来解析成为一个二进制字符串，最后，调用 <code>sproto.new</code>来建立一个 sproto 对象。</p>
<h2 id="协议定义-1"><a href="#协议定义-1" class="headerlink" title="协议定义"></a>协议定义</h2><p>这是通过 <code>parser.parse</code>来解析一个我们用 schema 语言定义的框架，然后生成的字符串保存在 表中进行了返回。</p>
<p>其中对于 <code>c2s</code> 的协议，我们定义了一个 消息类型 <code>.package</code>，四个请求（协议）类型。</p>
<p>而对于 <code>s2c</code>的协议，我们只定义了一个请求（协议）类型。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">proto.c2s = sprotoparser.parse <span class="string">[[</span></span><br><span class="line"><span class="string">.package &#123;</span></span><br><span class="line"><span class="string">        type 0 : integer  -- 消息类型</span></span><br><span class="line"><span class="string">        session 1 : integer  -- 会话ID</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">handshake 1 &#123;</span></span><br><span class="line"><span class="string">        response &#123;</span></span><br><span class="line"><span class="string">                msg 0  : string</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">get 2 &#123;</span></span><br><span class="line"><span class="string">        request &#123;</span></span><br><span class="line"><span class="string">                what 0 : string</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        response &#123;</span></span><br><span class="line"><span class="string">                result 0 : string</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set 3 &#123;</span></span><br><span class="line"><span class="string">        request &#123;</span></span><br><span class="line"><span class="string">                what 0 : string</span></span><br><span class="line"><span class="string">                value 1 : string</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">quit 4 &#123;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line">proto.s2c = sprotoparser.parse <span class="string">[[</span></span><br><span class="line"><span class="string">.package &#123;</span></span><br><span class="line"><span class="string">        type 0 : integer</span></span><br><span class="line"><span class="string">        session 1 : integer</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">heartbeat 1 &#123;&#125;</span></span><br><span class="line"><span class="string">]]</span></span><br></pre></td></tr></table></figure>
<h2 id="对象建立"><a href="#对象建立" class="headerlink" title="对象建立"></a>对象建立</h2><p>我们先来看看第一个调用：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> host = sproto.new(proto.s2c):host <span class="string">"package"</span></span><br></pre></td></tr></table></figure>
<p>这个调用实际上就是：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> sobj = sproto.new(proto.s2c)</span><br><span class="line"><span class="keyword">local</span> host = sobj:host <span class="string">"package"</span></span><br></pre></td></tr></table></figure>
<p>我们先看看第一步 <code>sproto.new</code>的定义：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> weak_mt = &#123; <span class="built_in">__mode</span> = <span class="string">"kv"</span> &#125;</span><br><span class="line"><span class="keyword">local</span> sproto_mt = &#123; <span class="built_in">__index</span> = sproto &#125;</span><br><span class="line"><span class="keyword">local</span> sproto_nogc = &#123; <span class="built_in">__index</span> = sproto &#125;</span><br><span class="line"><span class="keyword">local</span> host_mt = &#123; <span class="built_in">__index</span> = host &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sproto.new</span><span class="params">(bin)</span></span></span><br><span class="line">        <span class="keyword">local</span> cobj = <span class="built_in">assert</span>(core.newproto(bin))</span><br><span class="line">        <span class="keyword">local</span> self = &#123;</span><br><span class="line">                __cobj = cobj,</span><br><span class="line">                __tcache = <span class="built_in">setmetatable</span>( &#123;&#125; , weak_mt ),</span><br><span class="line">                __pcache = <span class="built_in">setmetatable</span>( &#123;&#125; , weak_mt ),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setmetatable</span>(self, sproto_mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其实是调用 注册出的的 core.newproto API，来建立了一个 sproto 对象。返回值就是 一个表 ，此表中的 <code>__cobj</code> 引用了 这个建立的 对象。这个表的元表已经被设置为  <code>sproto_mt</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">sobj = &#123;</span><br><span class="line">        __cobj = cobj,</span><br><span class="line">        __tcache = <span class="built_in">setmetatable</span>( &#123;&#125; , weak_mt ),</span><br><span class="line">        __pcache = <span class="built_in">setmetatable</span>( &#123;&#125; , weak_mt ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们调用的<code>sobj:host</code>，在 sobj 表内并不存在方法 <code>host</code>，所以其转而去寻找去 <code>__index</code>事件的元方法，这是一个表，就是 <em>sproto</em>，其实其调用的就是下面的这个方法。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sproto:host</span><span class="params">( packagename )</span></span></span><br><span class="line">        packagename = packagename <span class="keyword">or</span>  <span class="string">"package"</span></span><br><span class="line">        <span class="keyword">local</span> obj = &#123;</span><br><span class="line">                __proto = self,</span><br><span class="line">                __package = <span class="built_in">assert</span>(core.querytype(self.__cobj, packagename), <span class="string">"type package not found"</span>),</span><br><span class="line">                __session = &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setmetatable</span>(obj, host_mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>会根据我们给定的 <em>packagename</em> 消息类型来建立一个表对象 <em>obj</em>，这个表内的 <code>__proto</code> 事件就指向了我们的 <em>sproto</em>表，然后<code>__package</code>事件引用了 <em>packagename</em> 在 建立的 sproto对象中的位置。<em>host</em>对象的元表被设置成了 <code>host_mt</code>，其中具有 <code>dispatch, attach</code>两个方法。所以当 <em>host</em>，不存在对应方法时会调用元表中的方法。</p>
<p>最终我们可以得到一个表，也可以说是一个对象。<em>host</em>，</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">host =  &#123;</span><br><span class="line">         __proto = sobj,</span><br><span class="line">         __package = <span class="built_in">assert</span>(core.querytype(self.__cobj, packagename), <span class="string">"type package not found"</span>),</span><br><span class="line">         __session = &#123;&#125;,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息分发器"><a href="#消息分发器" class="headerlink" title="消息分发器"></a>消息分发器</h2><p>实际上，我们对一个 sproto 对象调用 <code>:host</code>方法，就是为它绑定一个有两个方法  <code>dispatch, attach</code> 的元表。这样当访问这两个方法的时候就会直接访问我们绑定的方法。</p>
<h3 id="host-attach"><a href="#host-attach" class="headerlink" title="host:attach"></a>host:attach</h3><p>我们来看一下 <code>attach</code> 方法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">host:attach</span><span class="params">(sp)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(name, args, session, ud)</span></span></span><br><span class="line">        			// 在 sproto 对象内查找 name 协议</span><br><span class="line">                <span class="keyword">local</span> proto = queryproto(sp, name)</span><br><span class="line">                // 消息头部 &#123; <span class="built_in">type</span>, session, ud&#125;</span><br><span class="line">                header_tmp.<span class="built_in">type</span> = proto.tag</span><br><span class="line">                header_tmp.session = session</span><br><span class="line">                header_tmp.ud = ud</span><br><span class="line">                // 头部进行 <span class="number">0</span> packing</span><br><span class="line">                <span class="keyword">local</span> header = core.encode(self.__package, header_tmp)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> session <span class="keyword">then</span></span><br><span class="line">                        self.__session[session] = proto.response <span class="keyword">or</span> <span class="literal">true</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                </span><br><span class="line">                // 封装请求内容</span><br><span class="line">                <span class="keyword">if</span> proto.request <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">local</span> content = core.encode(proto.request, args)</span><br><span class="line">                        <span class="keyword">return</span> core.pack(header ..  content)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> core.pack(header)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个函数会返回一个函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(name, args, session, ud)</span></span> ... <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其会根据 <code>name</code>（协议类型/请求类型）来把 代表内容的 <em>args, session</em> 打包。</p>
<h3 id="host-dispatch"><a href="#host-dispatch" class="headerlink" title="host:dispatch"></a>host:dispatch</h3><p>我们先来看一下 <code>dispatch</code>方法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">host:dispatch</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> bin = core.<span class="built_in">unpack</span>(...)</span><br><span class="line">        header_tmp.<span class="built_in">type</span> = <span class="literal">nil</span></span><br><span class="line">        header_tmp.session = <span class="literal">nil</span></span><br><span class="line">        header_tmp.ud = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">local</span> header, size = core.decode(self.__package, bin, header_tmp)</span><br><span class="line">        <span class="keyword">local</span> content = bin:<span class="built_in">sub</span>(size + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> header.<span class="built_in">type</span> <span class="keyword">then</span></span><br><span class="line">                <span class="comment">-- request</span></span><br><span class="line">                <span class="keyword">local</span> proto = queryproto(self.__proto, header.<span class="built_in">type</span>)</span><br><span class="line">                <span class="keyword">local</span> result</span><br><span class="line">                <span class="keyword">if</span> proto.request <span class="keyword">then</span></span><br><span class="line">                        result = core.decode(proto.request, content)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> header_tmp.session <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"REQUEST"</span>, proto.name, result, gen_response(self, proto.response, header_tmp.session), header.ud</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"REQUEST"</span>, proto.name, result, <span class="literal">nil</span>, header.ud</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">-- response</span></span><br><span class="line">                <span class="keyword">local</span> session = <span class="built_in">assert</span>(header_tmp.session, <span class="string">"session not found"</span>)</span><br><span class="line">                <span class="keyword">local</span> response = <span class="built_in">assert</span>(self.__session[session], <span class="string">"Unknown session"</span>)</span><br><span class="line">                self.__session[session] = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">if</span> response == <span class="literal">true</span> <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"RESPONSE"</span>, session, <span class="literal">nil</span>, header.ud</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">local</span> result = core.decode(response, content)</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"RESPONSE"</span>, session, result, header.ud</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>在调用  <code>local request = host:attach(sproto.new(proto.c2s))</code>后，建立了一个消息封装函数<em>request</em>。</p>
<p>函数 ：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">send_request</span><span class="params">(name, args)</span></span></span><br><span class="line">        session = session + <span class="number">1</span></span><br><span class="line">        <span class="keyword">local</span> str = request(name, args, session)</span><br><span class="line">        send_package(fd, str)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Request:"</span>, session)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>会将 会话ID，协议名，参数传递给 消息封装函数。之后，函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">send_package</span><span class="params">(fd, pack)</span></span></span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">package</span> = <span class="built_in">string</span>.pack(<span class="string">"&gt;s2"</span>, pack)</span><br><span class="line">        socket.send(fd, <span class="built_in">package</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>会将打包好的消息，进行大端封装后发送到套接字去。</p>
<h2 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h2><p>服务端使用了 <code>snax.gateserver</code> 的实例 <code>gate</code>来实现连接管理，当收到一个消息时，如果有agent，就会将消息转发到agent去：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- services/gate.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler.message</span><span class="params">(fd, msg, sz)</span></span></span><br><span class="line">        <span class="comment">-- recv a package, forward it</span></span><br><span class="line">        <span class="keyword">local</span> c = connection[fd]</span><br><span class="line">        <span class="keyword">local</span> agent = c.agent</span><br><span class="line">        <span class="keyword">if</span> agent <span class="keyword">then</span></span><br><span class="line">                skynet.redirect(agent, c.client, <span class="string">"client"</span>, <span class="number">1</span>, msg, sz)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                skynet.send(watchdog, <span class="string">"lua"</span>, <span class="string">"socket"</span>, <span class="string">"data"</span>, fd, netpack.<span class="built_in">tostring</span>(msg, sz))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们的 agent 服务在启动时即注册了 <em>client</em> 类型的消息：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- examples/agent.lua</span></span><br><span class="line">skynet.register_protocol &#123;</span><br><span class="line">        name = <span class="string">"client"</span>,</span><br><span class="line">        id = skynet.PTYPE_CLIENT,</span><br><span class="line">        <span class="built_in">unpack</span> = <span class="function"><span class="keyword">function</span> <span class="params">(msg, sz)</span></span></span><br><span class="line">                <span class="keyword">return</span> host:dispatch(msg, sz)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">        dispatch = <span class="function"><span class="keyword">function</span> <span class="params">(_, _, type, ...)</span></span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">"REQUEST"</span> <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">local</span> ok, result  = <span class="built_in">pcall</span>(request, ...)</span><br><span class="line">                        <span class="keyword">if</span> ok <span class="keyword">then</span></span><br><span class="line">                                <span class="keyword">if</span> result <span class="keyword">then</span></span><br><span class="line">                                        send_package(result)</span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                skynet.<span class="built_in">error</span>(result)</span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">assert</span>(<span class="built_in">type</span> == <span class="string">"RESPONSE"</span>)</span><br><span class="line">                        <span class="built_in">error</span> <span class="string">"This example doesn't support request client"</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其会使用 <code>host:dispatch</code>来解压消息，然后注册了自己的消息回调函数。</p>
<p>我们注意到，在服务端中，建立消息消息分发器的方式同客户端似乎都不一样：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- examples/agent.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CMD.start</span><span class="params">(conf)</span></span></span><br><span class="line">        <span class="keyword">local</span> fd = conf.client</span><br><span class="line">        <span class="keyword">local</span> gate = conf.gate</span><br><span class="line">        WATCHDOG = conf.watchdog</span><br><span class="line">        <span class="comment">-- slot 1,2 set at main.lua</span></span><br><span class="line">        host = sprotoloader.<span class="built_in">load</span>(<span class="number">1</span>):host <span class="string">"package"</span></span><br><span class="line">        send_request = host:attach(sprotoloader.<span class="built_in">load</span>(<span class="number">2</span>))</span><br><span class="line">        skynet.fork(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">                        send_package(send_request <span class="string">"heartbeat"</span>)</span><br><span class="line">                        skynet.sleep(<span class="number">500</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">        client_fd = fd</span><br><span class="line">        skynet.call(gate, <span class="string">"lua"</span>, <span class="string">"forward"</span>, fd)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其是通过 <code>sprotoloader.load(1):host &quot;package&quot;</code>来建立的。我们有理由去猜测，这个其实应该等价与：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">sproto.new(proto.c2s):host <span class="string">"package"</span></span><br></pre></td></tr></table></figure>
<p>因为其处理的，是从客户端到服务端的消息。</p>
<h2 id="sprotoloader"><a href="#sprotoloader" class="headerlink" title="sprotoloader"></a>sprotoloader</h2><p>如果想要在程序中，各个服务中共享同样的消息类型和协议类型，为每个服务都单独的保存这些协议信息似乎是非常浪费的。所以就有了把共享的协议由一个服务来提供的想法。</p>
<p>其先启动了一个全局唯一的协议加载服务：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.uniqueservice(<span class="string">"protoloader"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        sprotoloader.save(proto.c2s, <span class="number">1</span>)</span><br><span class="line">        sprotoloader.save(proto.s2c, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">-- don't call skynet.exit() , because sproto.core may unload and the global slot become invalid</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>把 客户端到服务端的消息类型保存为索引 1。</p>
<p>这样当我们通过 <code>sprotoloader.load(1)</code>，就得出了这个索引对应的对象指针，在通过 <code>sproto.sharenew()</code>来把这个对象给返回给调用者。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/sprotoloader.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader.load</span><span class="params">(index)</span></span></span><br><span class="line">        <span class="keyword">local</span> sp = core.loadproto(index)</span><br><span class="line">        <span class="comment">--  no __gc in metatable</span></span><br><span class="line">        <span class="keyword">return</span> sproto.sharenew(sp)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> loader</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/sproto.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sproto.sharenew</span><span class="params">(cobj)</span></span></span><br><span class="line">        <span class="keyword">local</span> self = &#123;</span><br><span class="line">                __cobj = cobj,</span><br><span class="line">                __tcache = <span class="built_in">setmetatable</span>( &#123;&#125; , weak_mt ),</span><br><span class="line">                __pcache = <span class="built_in">setmetatable</span>( &#123;&#125; , weak_mt ),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setmetatable</span>(self, sproto_nogc)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个函数其实是 <code>sproto.new</code>返回的值一样，不过其是直接传过去的对象，而不是二进制的字符串。</p>
<p>如此，我们的消息处理流程就完美了。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Gowa2017 Zhang</p><p>原文链接: <a href="https://gowa.club/Lua/skynet中sproto使用示例.html">https://gowa.club/Lua/skynet中sproto使用示例.html</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Lua/">Lua</a><a href="/tags/Skynet/">Skynet</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/Lua/PIL.22-Lua中的环境.html" class="pre">PIL.22-Lua中的环境</a><a href="/Linux-Unix/IO的阻塞与多路复用.html" class="next">IO的阻塞与多路复用</a></div><div id="comments"><div id="disqus_thread"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解析器"><span class="toc-text">解析器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-API"><span class="toc-text">Lua API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC-API"><span class="toc-text">RPC API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议定义"><span class="toc-text">协议定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Wire-protocol"><span class="toc-text">Wire protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#例子1"><span class="toc-text">例子1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子2"><span class="toc-text">例子2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子3"><span class="toc-text">例子3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子4"><span class="toc-text">例子4</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例子-5"><span class="toc-text">例子 5:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例子-6"><span class="toc-text">例子 6:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0-Packing"><span class="toc-text">0 Packing</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-API"><span class="toc-text">C API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#消息类型与请求类型"><span class="toc-text">消息类型与请求类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#client-lua-使用示例"><span class="toc-text">client.lua 使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#协议定义-1"><span class="toc-text">协议定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象建立"><span class="toc-text">对象建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息分发器"><span class="toc-text">消息分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#host-attach"><span class="toc-text">host:attach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#host-dispatch"><span class="toc-text">host:dispatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息发送"><span class="toc-text">消息发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息接收"><span class="toc-text">消息接收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sprotoloader"><span class="toc-text">sprotoloader</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Android/Hooking-Linux中的共享库函数.html">Hooking-Linux中的共享库函数</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Riru来注入Zygote进程.html">Riru来注入Zygote进程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Android的权限检查过程.html">Android的权限检查过程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Android的服务管理.html">Android的服务管理</a></li><li class="post-list-item"><a class="post-list-link" href="/Cpp/使用Clang进行交叉编译.html">使用Clang进行交叉编译</a></li><li class="post-list-item"><a class="post-list-link" href="/Cocos-Creator/Cocos-Creator安卓下的启动流程.html">Cocos-Creator安卓下的启动流程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Android中模拟输入的实现.html">Android中模拟输入的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/Lua中的协程.html">Lua中的协程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Auto.js截图后在相册无法立即显示.html">Auto.js截图后在相册无法立即显示</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/luasocket中的http实现.html">luasocket中的http实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Asm/">Asm</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos-Creator/">Cocos Creator</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-X/">Cocos2d-X</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Device/">Device</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GTD/">GTD</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kindle/">Kindle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Unix/">Linux/Unix</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS/">macOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">25</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Curl/" style="font-size: 15px;">Curl</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/brew/" style="font-size: 15px;">brew</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SED/" style="font-size: 15px;">SED</a> <a href="/tags/SHELL/" style="font-size: 15px;">SHELL</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/Cocos2d-X/" style="font-size: 15px;">Cocos2d-X</a> <a href="/tags/LVM/" style="font-size: 15px;">LVM</a> <a href="/tags/The-Java-Tutorial/" style="font-size: 15px;">The Java Tutorial</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Svn/" style="font-size: 15px;">Svn</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Docx/" style="font-size: 15px;">Docx</a> <a href="/tags/CentOS/" style="font-size: 15px;">CentOS</a> <a href="/tags/REST/" style="font-size: 15px;">REST</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/VNC/" style="font-size: 15px;">VNC</a> <a href="/tags/Poi/" style="font-size: 15px;">Poi</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/X5/" style="font-size: 15px;">X5</a> <a href="/tags/Tbs/" style="font-size: 15px;">Tbs</a> <a href="/tags/Cocos-Creator/" style="font-size: 15px;">Cocos Creator</a> <a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/ML/" style="font-size: 15px;">ML</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/KVM/" style="font-size: 15px;">KVM</a> <a href="/tags/Sqlplus/" style="font-size: 15px;">Sqlplus</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/Dagger/" style="font-size: 15px;">Dagger</a> <a href="/tags/PAC/" style="font-size: 15px;">PAC</a> <a href="/tags/Pandas/" style="font-size: 15px;">Pandas</a> <a href="/tags/NFS/" style="font-size: 15px;">NFS</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/Pomelo/" style="font-size: 15px;">Pomelo</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Gson/" style="font-size: 15px;">Gson</a> <a href="/tags/GTD/" style="font-size: 15px;">GTD</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Room/" style="font-size: 15px;">Room</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/MFC/" style="font-size: 15px;">MFC</a> <a href="/tags/Cpp/" style="font-size: 15px;">Cpp</a> <a href="/tags/ffmpeg/" style="font-size: 15px;">ffmpeg</a> <a href="/tags/PIL/" style="font-size: 15px;">PIL</a> <a href="/tags/Asm/" style="font-size: 15px;">Asm</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/Auto-js/" style="font-size: 15px;">Auto.js</a> <a href="/tags/Hooking/" style="font-size: 15px;">Hooking</a> <a href="/tags/Aix/" style="font-size: 15px;">Aix</a> <a href="/tags/RegEx/" style="font-size: 15px;">RegEx</a> <a href="/tags/Kindle/" style="font-size: 15px;">Kindle</a> <a href="/tags/F5/" style="font-size: 15px;">F5</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/AWK/" style="font-size: 15px;">AWK</a> <a href="/tags/Iptables/" style="font-size: 15px;">Iptables</a> <a href="/tags/Apue/" style="font-size: 15px;">Apue</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/OSPF/" style="font-size: 15px;">OSPF</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Oralce/" style="font-size: 15px;">Oralce</a> <a href="/tags/Device/" style="font-size: 15px;">Device</a> <a href="/tags/Raid/" style="font-size: 15px;">Raid</a> <a href="/tags/磁盘阵列/" style="font-size: 15px;">磁盘阵列</a> <a href="/tags/Syslog/" style="font-size: 15px;">Syslog</a> <a href="/tags/Tcpdump/" style="font-size: 15px;">Tcpdump</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Php/" style="font-size: 15px;">Php</a> <a href="/tags/设备信息查看/" style="font-size: 15px;">设备信息查看</a> <a href="/tags/Skynet/" style="font-size: 15px;">Skynet</a> <a href="/tags/Rsync/" style="font-size: 15px;">Rsync</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/networksetup/" style="font-size: 15px;">networksetup</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/VIM/" style="font-size: 15px;">VIM</a> <a href="/tags/DHCP/" style="font-size: 15px;">DHCP</a> <a href="/tags/PPPoE/" style="font-size: 15px;">PPPoE</a> <a href="/tags/launchd/" style="font-size: 15px;">launchd</a> <a href="/tags/So/" style="font-size: 15px;">So</a> <a href="/tags/Docx4j/" style="font-size: 15px;">Docx4j</a> <a href="/tags/Lsyncd/" style="font-size: 15px;">Lsyncd</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/Activiti/" style="font-size: 15px;">Activiti</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Gowa2017 Zhang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-137245514-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><<<<<<< Updated upstream<script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>var disqus_shortname = 'gowa-1';
var disqus_identifier = 'Lua/skynet中sproto使用示例.html';
var disqus_title = 'skynet中sproto使用示例';
var disqus_url = 'https://gowa.club/Lua/skynet中sproto使用示例.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//gowa-1.disqus.com/count.js" async></script><script type="text/javascript" src="//gowa-1.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></body></html>