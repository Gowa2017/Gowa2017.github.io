<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="退思园" type="application/atom+xml">
  <meta name="google-site-verification" content="EDvvZZUFkxy_QUzZTaqwsG_9VHqFthY-NhQE4j6WL-s">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '8LQ0Z7JZKO',
      apiKey: '5d3485c20d60066c59575f644f5b3da9',
      indexName: 'gowa.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="通过将配置文件传入skynet后，其就会根据我们的脚本逻辑业务单元来启动对应的服务，然后把收到的消息进行分发处理。一般来说，这个框架针对的是网络游戏服务器，所以肯定会面向网络套接字信息这样的，但是也有进程间消息传递的处理机制。下面我们来看一下。">
<meta name="keywords" content="Lua,Skynet">
<meta property="og:type" content="article">
<meta property="og:title" content="skynet-任务调度及消息处理">
<meta property="og:url" content="https:&#x2F;&#x2F;gowa.club&#x2F;Lua&#x2F;skynet-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%8A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html">
<meta property="og:site_name" content="退思园">
<meta property="og:description" content="通过将配置文件传入skynet后，其就会根据我们的脚本逻辑业务单元来启动对应的服务，然后把收到的消息进行分发处理。一般来说，这个框架针对的是网络游戏服务器，所以肯定会面向网络套接字信息这样的，但是也有进程间消息传递的处理机制。下面我们来看一下。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-02-04T04:40:19.000Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gowa.club/Lua/skynet-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%8A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>skynet-任务调度及消息处理 | 退思园</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137245514-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-137245514-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">退思园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">烦恼一般都是想太多了。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gowa.club/Lua/skynet-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%8A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gowa2017 Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="退思园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          skynet-任务调度及消息处理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-04 12:40:19" itemprop="dateCreated datePublished" datetime="2018-02-04T12:40:19+08:00">2018-02-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index">
                    <span itemprop="name">Lua</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/Lua/skynet-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%8A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Lua/skynet-任务调度及消息处理.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>通过将配置文件传入skynet后，其就会根据我们的脚本逻辑业务单元来启动对应的服务，然后把收到的消息进行分发处理。一般来说，这个框架针对的是网络游戏服务器，所以肯定会面向网络套接字信息这样的，但是也有进程间消息传递的处理机制。下面我们来看一下。</p>
<a id="more"></a>

<h1 id="skyent-main"><a href="#skyent-main" class="headerlink" title="skyent main()"></a>skyent main()</h1><p>在文件<code>skynet_main.c</code>文件中，定义了一个<em>main()</em>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * config_file = <span class="literal">NULL</span> ;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		config_file = argv[<span class="number">1</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Need a config file. Please read skynet wiki : https://github.com/cloudwu/skynet/wiki/Config\n"</span></span><br><span class="line">			<span class="string">"usage: skynet configfilename\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skynet_globalinit();</span><br><span class="line">	skynet_env_init();</span><br><span class="line"></span><br><span class="line">	sigign();</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LUA_CACHELIB</span></span><br><span class="line">	<span class="comment">// init the lock of code cache</span></span><br><span class="line">	luaL_initcodecache();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">L</span> = <span class="title">luaL_newstate</span>();</span></span><br><span class="line">	luaL_openlibs(L);	<span class="comment">// link lua lib</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err =  luaL_loadbufferx(L, load_config, <span class="built_in">strlen</span>(load_config), <span class="string">"=[skynet config]"</span>, <span class="string">"t"</span>);</span><br><span class="line">	assert(err == LUA_OK);</span><br><span class="line">	lua_pushstring(L, config_file);</span><br><span class="line"></span><br><span class="line">	err = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">		lua_close(L);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_init_env(L);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">config</span>.thread =  optint(<span class="string">"thread"</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">config</span>.module_path = optstring(<span class="string">"cpath"</span>,<span class="string">"./cservice/?.so"</span>);</span><br><span class="line">	<span class="built_in">config</span>.harbor = optint(<span class="string">"harbor"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">config</span>.bootstrap = optstring(<span class="string">"bootstrap"</span>,<span class="string">"snlua bootstrap"</span>);</span><br><span class="line">	<span class="built_in">config</span>.daemon = optstring(<span class="string">"daemon"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">config</span>.logger = optstring(<span class="string">"logger"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">config</span>.logservice = optstring(<span class="string">"logservice"</span>, <span class="string">"logger"</span>);</span><br><span class="line">	<span class="built_in">config</span>.profile = optboolean(<span class="string">"profile"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	lua_close(L);</span><br><span class="line"></span><br><span class="line">	skynet_start(&amp;<span class="built_in">config</span>);</span><br><span class="line">	skynet_globalexit();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数做了几件事情：</p>
<ol>
<li>初始化全局环境。<code>skynet_globalinit()</code>  </li>
<li>初始化环境变量。<code>skynet_env_init()</code>  </li>
<li>使用 Lua 加载代码来来加载我们的配置文件。<code>luaL_loadbufferx()</code>  </li>
<li>就是读取传入的配置文件，解析参数，然后以<code>skynet_start(&amp;config)</code>进行启动。</li>
</ol>
<h1 id="skynet-globalinit-全局节点初始化"><a href="#skynet-globalinit-全局节点初始化" class="headerlink" title="skynet_globalinit() - 全局节点初始化"></a>skynet_globalinit() - 全局节点初始化</h1><p>这个函数，会初始化全局的节点信息，被设置主线程内的控制键值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> total;</span><br><span class="line">        <span class="keyword">int</span> init;</span><br><span class="line">        <span class="keyword">uint32_t</span> monitor_exit;</span><br><span class="line">        <span class="keyword">pthread_key_t</span> handle_key;</span><br><span class="line">        <span class="keyword">bool</span> profile;   <span class="comment">// default is off</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">skynet_node</span> <span class="title">G_NODE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_globalinit(<span class="keyword">void</span>) &#123;</span><br><span class="line">        G_NODE.total = <span class="number">0</span>;</span><br><span class="line">        G_NODE.monitor_exit = <span class="number">0</span>;</span><br><span class="line">        G_NODE.init = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pthread_key_create(&amp;G_NODE.handle_key, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_key_create failed"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set mainthread's key</span></span><br><span class="line">        skynet_initthread(THREAD_MAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_initthread(<span class="keyword">int</span> m) &#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> v = (<span class="keyword">uint32_t</span>)(-m);</span><br><span class="line">	pthread_setspecific(G_NODE.handle_key, (<span class="keyword">void</span> *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来，在主线程上创建了一个线程存储键，并初始化为 THREAD_MAIN,这个常量定义为 1。</p>
<p>初始化全局的节点信息，这个应该是为了分布式或多节点而来的。</p>
<h1 id="skynet-env-init-－全局环境变量"><a href="#skynet-env-init-－全局环境变量" class="headerlink" title="skynet_env_init()－全局环境变量"></a>skynet_env_init()－全局环境变量</h1><p>这个文件，初始化一个全局的环境变量<strong>E</strong>，可以看到这个全局变量其实也是用一个 lua_State 来保存我们的配置的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_env.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_env</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">        lua_State *L;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">skynet_env</span> *<span class="title">E</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_env_init() &#123;</span><br><span class="line">        E = skynet_malloc(<span class="keyword">sizeof</span>(*E));</span><br><span class="line">        SPIN_INIT(E)</span><br><span class="line">        E-&gt;L = luaL_newstate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>spinlock 就是一个整型，不知道是做什么用处的，可能是和锁相关的内容。<br>想要对全局环境进行修改的时候，势必要获取这个锁。</p>
<h1 id="luaL-initcodecache"><a href="#luaL-initcodecache" class="headerlink" title="luaL_initcodecache"></a>luaL_initcodecache</h1><p>这个函数，原生的 Lua 是不具备的，是在 lauxlib.c 内增加 的这么一个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3rd/lua/lauxlib.c</span></span><br><span class="line"></span><br><span class="line">LUALIB_API <span class="keyword">void</span></span><br><span class="line">luaL_initcodecache(<span class="keyword">void</span>) &#123;</span><br><span class="line">	SPIN_INIT(&amp;CC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">codecache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">	lua_State *L;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">codecache</span> <span class="title">CC</span>;</span></span><br></pre></td></tr></table></figure>

<p>一个 CC 静态变量，用来存储一些需要有多个 lua_State 公用的代码，当然也是加了锁的。</p>
<h1 id="配置加载"><a href="#配置加载" class="headerlink" title="配置加载"></a>配置加载</h1><p>一些库的载入，是打开一个虚拟机，然后通过Lua脚本的形式载入的。我们看主函数中的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_main.c </span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">L</span> = <span class="title">luaL_newstate</span>();</span></span><br><span class="line">        luaL_openlibs(L);       <span class="comment">// link lua lib</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> err =  luaL_loadbufferx(L, load_config, <span class="built_in">strlen</span>(load_config), <span class="string">"=[skynet config]"</span>, <span class="string">"t"</span>);</span><br><span class="line">        assert(err == LUA_OK);</span><br><span class="line">        lua_pushstring(L, config_file);</span><br><span class="line"></span><br><span class="line">        err = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">                lua_close(L);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要注意的是 <code>luaL_loadbufferx</code>会将字符串压入栈上，第三个参数一般用来做调试的时候打印信息用，第四个参数表示加载的是 二进制（<strong>b</strong>） 还是 文本 (<strong>t</strong>)，或者两者都有（<strong>bt</strong>）。</p>
<p>先是建立一个新的Lua State，然后把 下面的代码载入其内；接着，把配置文件压入栈，然后执行配置文件。这个是我们的 config.lua 配置文件的加载逻辑。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">static const <span class="built_in">char</span> * load_config = <span class="string">"\</span></span><br><span class="line"><span class="string">	local result = &#123;&#125;\n\</span></span><br><span class="line"><span class="string">	local function getenv(name) return assert(os.getenv(name), [[os.getenv() failed: ]] .. name) end\n\</span></span><br><span class="line"><span class="string">	local sep = package.config:sub(1,1)\n\</span></span><br><span class="line"><span class="string">	local current_path = [[.]]..sep\n\</span></span><br><span class="line"><span class="string">	local function include(filename)\n\</span></span><br><span class="line"><span class="string">		local last_path = current_path\n\</span></span><br><span class="line"><span class="string">		local path, name = filename:match([[(.*]]..sep..[[)(.*)$]])\n\</span></span><br><span class="line"><span class="string">		if path then\n\</span></span><br><span class="line"><span class="string">			if path:sub(1,1) == sep then	-- root\n\</span></span><br><span class="line"><span class="string">				current_path = path\n\</span></span><br><span class="line"><span class="string">			else\n\</span></span><br><span class="line"><span class="string">				current_path = current_path .. path\n\</span></span><br><span class="line"><span class="string">			end\n\</span></span><br><span class="line"><span class="string">		else\n\</span></span><br><span class="line"><span class="string">			name = filename\n\</span></span><br><span class="line"><span class="string">		end\n\</span></span><br><span class="line"><span class="string">		local f = assert(io.open(current_path .. name))\n\</span></span><br><span class="line"><span class="string">		local code = assert(f:read [[*a]])\n\</span></span><br><span class="line"><span class="string">		code = string.gsub(code, [[%$([%w_%d]+)]], getenv)\n\</span></span><br><span class="line"><span class="string">		f:close()\n\</span></span><br><span class="line"><span class="string">		assert(load(code,[[@]]..filename,[[t]],result))()\n\</span></span><br><span class="line"><span class="string">		current_path = last_path\n\</span></span><br><span class="line"><span class="string">	end\n\</span></span><br><span class="line"><span class="string">	setmetatable(result, &#123; __index = &#123; include = include &#125; &#125;)\n\</span></span><br><span class="line"><span class="string">	local config_name = ...\n\</span></span><br><span class="line"><span class="string">	include(config_name)\n\</span></span><br><span class="line"><span class="string">	setmetatable(result, nil)\n\</span></span><br><span class="line"><span class="string">	return result\n\</span></span><br><span class="line"><span class="string">"</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们的配置，这个时候是加载在一在个本地的 Lua State 里面的，需要在后面进行配置到全局。</p>
<p>这段代码的运行逻辑看起来有点累哈，实际就是设置了一个 <code>include</code> 函数，这个函数会把我们指定的配置文件以 result 为环境加 load 到栈上，但是并不执行，返回值就是我们建立的 result。这即是加载后的配置表。</p>
<h1 id="init-env-L"><a href="#init-env-L" class="headerlink" title="__init_env(L)"></a>__init_env(L)</h1><p>接下来的事情就比较奇妙了，在先前建立的Lua State内，已经保存了我们的配置信息，已经载入的库等。接下来就是把这个Lua State内的配置，都设置到全局变量内（事实上这些完全可以在C代码内完成的，为什么要用Lua呢）。</p>
<p>关于就在于我们的 skynet_setenv()  函数，会将我们 Lua 内配置的内容都设置到全局配置 <strong>E</strong> 内去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_init_env(lua_State *L) &#123;</span><br><span class="line">        lua_pushnil(L);  <span class="comment">/* first key */</span></span><br><span class="line">        <span class="keyword">while</span> (lua_next(L, <span class="number">-2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> keyt = lua_type(L, <span class="number">-2</span>);</span><br><span class="line">                <span class="keyword">if</span> (keyt != LUA_TSTRING) &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid config table\n"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> * key = lua_tostring(L,<span class="number">-2</span>);</span><br><span class="line">                <span class="keyword">if</span> (lua_type(L,<span class="number">-1</span>) == LUA_TBOOLEAN) &#123;</span><br><span class="line">                        <span class="keyword">int</span> b = lua_toboolean(L,<span class="number">-1</span>);</span><br><span class="line">                        skynet_setenv(key,b ? <span class="string">"true"</span> : <span class="string">"false"</span> );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> * value = lua_tostring(L,<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid config table key = %s\n"</span>, key);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        skynet_setenv(key,value);</span><br><span class="line">                &#125;</span><br><span class="line">                lua_pop(L,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua_pop(L,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码就是要理解 <code>lua_next(L,index)</code> 这个函数会从栈顶 弹出一个键，然后从 Index 的表处，压入两个值，key_value 对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">skynet_setenv(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">char</span> *value) &#123;</span><br><span class="line">	SPIN_LOCK(E)</span><br><span class="line">	</span><br><span class="line">	lua_State *L = E-&gt;L;</span><br><span class="line">	lua_getglobal(L, key);</span><br><span class="line">	assert(lua_isnil(L, <span class="number">-1</span>));</span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushstring(L,value);</span><br><span class="line">	lua_setglobal(L,key);</span><br><span class="line"></span><br><span class="line">	SPIN_UNLOCK(E)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们的配置文件信息，其实是放在全局环境的注册表内的。</p>
<h1 id="skynet-start-amp-config"><a href="#skynet-start-amp-config" class="headerlink" title="skynet_start(&amp;config)"></a>skynet_start(&amp;config)</h1><p>当我们把我们的 config.lua 内的内容加载到全局环境变量 E 中后，就会根据配置来构造我们的启动了。</p>
<p>类似 <code>optint(), optstring()</code> 这些函数其实都是使用 skynet_getenv 了从 E 内取内容。</p>
<p>在<code>skynet_start.c</code>中，我们可以看到代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">skynet_start(struct skynet_config * <span class="built_in">config</span>) &#123;</span><br><span class="line">        <span class="comment">// register SIGHUP for log file reopen</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">        sa.sa_handler = &amp;handle_hup;</span><br><span class="line">        sa.sa_flags = SA_RESTART;</span><br><span class="line">        sigfillset(&amp;sa.sa_mask);</span><br><span class="line">        sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;daemon) &#123;</span><br><span class="line">                <span class="keyword">if</span> (daemon_init(<span class="built_in">config</span>-&gt;daemon)) &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        skynet_harbor_init(<span class="built_in">config</span>-&gt;harbor);</span><br><span class="line">        skynet_handle_init(<span class="built_in">config</span>-&gt;harbor);</span><br><span class="line">        skynet_mq_init();</span><br><span class="line">        skynet_module_init(<span class="built_in">config</span>-&gt;module_path);</span><br><span class="line">        skynet_timer_init();</span><br><span class="line">        skynet_socket_init();</span><br><span class="line">        skynet_profile_enable(<span class="built_in">config</span>-&gt;profile);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, <span class="built_in">config</span>-&gt;logservice);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bootstrap(ctx, <span class="built_in">config</span>-&gt;bootstrap);</span><br><span class="line"></span><br><span class="line">        start(<span class="built_in">config</span>-&gt;thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// harbor_exit may call socket send, so it should exit before socket_free</span></span><br><span class="line">        skynet_harbor_exit();</span><br><span class="line">        skynet_socket_free();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;daemon) &#123;</span><br><span class="line">                daemon_exit(<span class="built_in">config</span>-&gt;daemon);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要工作为：</p>
<ol>
<li>设置<code>SIGHUP</code>的信号处理程序。  </li>
<li>初始化句柄。<code>skynet_handle_init()</code>  </li>
<li>初始化消息队列。<code>skynet_mq_init()</code>  </li>
<li>模块加载。<code>skynet_module_init(config-&gt;module_path)</code> 我们指定的 C 编译的 so 库的目录下的内容。  </li>
<li>定时器设置。<code>skynet_timer_init()</code>  </li>
<li>套接字初始化。<code>skynet_socket_ini()</code>  </li>
<li>开启日志服务。  </li>
<li>启动<strong>bootstrap</strong>脚本。<code>bootstrap(ctr, confit-&gt;bootstrap)</code>  </li>
<li>启动线程。<code>start(config-&gt;thread)</code>。  </li>
</ol>
<h2 id="skynet-harbor-init-int-harbor"><a href="#skynet-harbor-init-int-harbor" class="headerlink" title="skynet_harbor_init(int harbor)"></a>skynet_harbor_init(int harbor)</h2><p>初始化节点化的ID。</p>
<blockquote>
<p>harbor 可以是 1-255 间的任意整数。一个 skynet 网络最多支持 255 个节点。每个节点有必须有一个唯一的编号。  </p>
<p>如果 harbor 为 0 ，skynet 工作在单节点模式下。此时 master 和 address 以及 standalone 都不必设置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_harbor_init(<span class="keyword">int</span> harbor) &#123;</span><br><span class="line">	HARBOR = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)harbor &lt;&lt; HANDLE_REMOTE_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="skynet-handle-init"><a href="#skynet-handle-init" class="headerlink" title="skynet_handle_init()"></a>skynet_handle_init()</h2><p>handle是什么我一直没有搞清楚，这是干什么的我也没有弄明白。只有参考了一下作者的博客 。</p>
<blockquote>
<p>把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。模块被称为服务（Service），服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。每个服务都是被一个个消息包驱动，当没有包到来的时候，它们就会处于挂起状态，对 CPU 资源零消耗。如果需要自主逻辑，则可以利用 Skynet 系统提供的 timeout 消息，定期触发。</p>
</blockquote>
<p>模块的实例是服务，实例的ID是 handle，每个服务都对应一个唯一的handle_id。</p>
<p>也就是对于很多类型的服务，都是首先加载进来，然后注册，为服务模块，可以启动多个实例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_handle.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rwlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> harbor;</span><br><span class="line">        <span class="keyword">uint32_t</span> handle_index;</span><br><span class="line">        <span class="keyword">int</span> slot_size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> ** <span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> name_cap;</span><br><span class="line">        <span class="keyword">int</span> name_count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">handle_name</span> *<span class="title">name</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> *<span class="title">H</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_handle_init(<span class="keyword">int</span> harbor) &#123;</span><br><span class="line">        assert(H==<span class="literal">NULL</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> * <span class="title">s</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">H</span>));</span></span><br><span class="line">        s-&gt;slot_size = DEFAULT_SLOT_SIZE;</span><br><span class="line">        s-&gt;slot = skynet_malloc(s-&gt;slot_size * <span class="keyword">sizeof</span>(struct skynet_context *));</span><br><span class="line">        <span class="built_in">memset</span>(s-&gt;slot, <span class="number">0</span>, s-&gt;slot_size * <span class="keyword">sizeof</span>(struct skynet_context *));</span><br><span class="line"></span><br><span class="line">        rwlock_init(&amp;s-&gt;lock);</span><br><span class="line">        <span class="comment">// reserve 0 for system</span></span><br><span class="line">        s-&gt;harbor = (<span class="keyword">uint32_t</span>) (harbor &amp; <span class="number">0xff</span>) &lt;&lt; HANDLE_REMOTE_SHIFT;</span><br><span class="line">        s-&gt;handle_index = <span class="number">1</span>;</span><br><span class="line">        s-&gt;name_cap = <span class="number">2</span>;</span><br><span class="line">        s-&gt;name_count = <span class="number">0</span>;</span><br><span class="line">        s-&gt;name = skynet_malloc(s-&gt;name_cap * <span class="keyword">sizeof</span>(struct handle_name));</span><br><span class="line"></span><br><span class="line">        H = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't need to free H</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置一个全局控制柄变量<strong>H</strong>，默认有四个位置可以存储四个 <code>skynet_context</code>服务结构的指针。</p>
<h2 id="skynet-module-init"><a href="#skynet-module-init" class="headerlink" title="skynet_module_init()"></a>skynet_module_init()</h2><p>服务表已经有了，现在我们需要把我们的模块加载进来。</p>
<p>这个函数定义在<code>skynet_module.c</code>中，其作用，就是载入配置文件中<code>lua_cpath= ...</code>指定的动态库路径。同时，将全局的模块变量<strong>M</strong>指像这个路径。</p>
<p>每个模块的结构定义在<code>skynet_module.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_module.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">        <span class="keyword">void</span> * <span class="keyword">module</span>;</span><br><span class="line">        skynet_dl_create create;</span><br><span class="line">        skynet_dl_init init;</span><br><span class="line">        skynet_dl_release <span class="built_in">release</span>;</span><br><span class="line">        skynet_dl_signal signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，后面四个函数是由动态库提供的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_modlue.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">modules</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * path;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> <span class="title">m</span>[<span class="title">MAX_MODULE_TYPE</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">modules</span> * <span class="title">M</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_module_init(<span class="keyword">const</span> <span class="keyword">char</span> *path) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">modules</span> *<span class="title">m</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">m</span>));</span></span><br><span class="line">        m-&gt;count = <span class="number">0</span>;</span><br><span class="line">        m-&gt;path = skynet_strdup(path);</span><br><span class="line"></span><br><span class="line">        SPIN_INIT(m)</span><br><span class="line"></span><br><span class="line">        M = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="skynet-mq-init"><a href="#skynet-mq-init" class="headerlink" title="skynet_mq_init()"></a>skynet_mq_init()</h2><p>在文件<code>skynet_mq.c</code>中，定义了这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_mq_init() &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> *<span class="title">q</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">q</span>));</span></span><br><span class="line">        <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(*q));</span><br><span class="line">        SPIN_INIT(q);</span><br><span class="line">        Q=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是建立了一个全局的消息队列 <strong>Q</strong>，此队列保存了每个服务的消息队列。</p>
<h2 id="skynet-timer-init"><a href="#skynet-timer-init" class="headerlink" title="skynet_timer_init();"></a>skynet_timer_init();</h2><p>定时器初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_timer_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">	TI = timer_create_timer();</span><br><span class="line">	<span class="keyword">uint32_t</span> current = <span class="number">0</span>;</span><br><span class="line">	systime(&amp;TI-&gt;starttime, &amp;current);</span><br><span class="line">	TI-&gt;current = current;</span><br><span class="line">	TI-&gt;current_point = gettime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="skynet-socket-init"><a href="#skynet-socket-init" class="headerlink" title="skynet_socket_init();"></a>skynet_socket_init();</h2><p>套接字服务器初始化，这个的作用是当需要启动网络服务的时候，由这个服务器来启动对应的监听。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_socket_init() &#123;</span><br><span class="line">	SOCKET_SERVER = socket_server_create(skynet_now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> * </span></span><br><span class="line"><span class="class"><span class="title">socket_server_create</span>(<span class="title">uint64_t</span> <span class="title">time</span>) &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	poll_fd efd = sp_create();</span><br><span class="line">	<span class="keyword">if</span> (sp_invalid(efd)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: create event pool failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd)) &#123;</span><br><span class="line">		sp_release(efd);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: create socket pair failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sp_add(efd, fd[<span class="number">0</span>], <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">// add recvctrl_fd to event poll</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: can't add server fd to event pool.\n"</span>);</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		sp_release(efd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> = <span class="title">MALLOC</span>(<span class="title">sizeof</span>(*<span class="title">ss</span>));</span></span><br><span class="line">	ss-&gt;time = time;</span><br><span class="line">	ss-&gt;event_fd = efd;</span><br><span class="line">	ss-&gt;recvctrl_fd = fd[<span class="number">0</span>];</span><br><span class="line">	ss-&gt;sendctrl_fd = fd[<span class="number">1</span>];</span><br><span class="line">	ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAX_SOCKET;i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">slot</span>[<span class="title">i</span>];</span></span><br><span class="line">		s-&gt;type = SOCKET_TYPE_INVALID;</span><br><span class="line">		clear_wb_list(&amp;s-&gt;high);</span><br><span class="line">		clear_wb_list(&amp;s-&gt;low);</span><br><span class="line">		spinlock_init(&amp;s-&gt;dw_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	ss-&gt;alloc_id = <span class="number">0</span>;</span><br><span class="line">	ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">	ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ss-&gt;soi, <span class="number">0</span>, <span class="keyword">sizeof</span>(ss-&gt;soi));</span><br><span class="line">	FD_ZERO(&amp;ss-&gt;rfds);</span><br><span class="line">	assert(ss-&gt;recvctrl_fd &lt; FD_SETSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="skynet-context-结构"><a href="#skynet-context-结构" class="headerlink" title="skynet_context 结构"></a>skynet_context 结构</h1><p>在skynet.c中，结构<code>skynet_context</code>为每个服务保存了一个内部结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> * instance;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span>;</span></span><br><span class="line">        <span class="keyword">void</span> * cb_ud;</span><br><span class="line">        skynet_cb cb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">        FILE * logfile;</span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_cost;      <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_start;     <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> handle;</span><br><span class="line">        <span class="keyword">int</span> session_id;</span><br><span class="line">        <span class="keyword">int</span> ref;</span><br><span class="line">        <span class="keyword">int</span> message_count;</span><br><span class="line">        <span class="keyword">bool</span> init;</span><br><span class="line">        <span class="keyword">bool</span> endless;</span><br><span class="line">        <span class="keyword">bool</span> profile;</span><br><span class="line"></span><br><span class="line">        CHECKCALLING_DECL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构定义了每个服务的<em>实例地址，模块地址，消息队列，日志文件，会话ID，引用数，消息数</em>等字段。</p>
<h1 id="服务-H-表"><a href="#服务-H-表" class="headerlink" title="服务 H 表"></a>服务 H 表</h1><p>我们第一个启动的服务就是 logger 服务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, <span class="built_in">config</span>-&gt;logservice);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet_handle_namehandle(skynet_context_handle(ctx), <span class="string">"logger"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="skynet-create-new"><a href="#skynet-create-new" class="headerlink" title="skynet_create_new()"></a>skynet_create_new()</h2><p><code>skynet.c</code>中，<code>skynet_create_new()</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_context_new</span>(<span class="title">const</span> <span class="title">char</span> * <span class="title">name</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">param</span>) &#123;</span></span><br><span class="line">		  <span class="comment">// 查询模块是否加载</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span> = <span class="title">skynet_module_query</span>(<span class="title">name</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		  <span class="comment">// 用模块建立一个实例 返回的是实例地址</span></span><br><span class="line">        <span class="keyword">void</span> *inst = skynet_module_instance_create(mod);</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 建立一个服务结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">ctx</span>));</span></span><br><span class="line">        CHECKCALLING_INIT(ctx)</span><br><span class="line"></span><br><span class="line">        ctx-&gt;mod = mod;</span><br><span class="line">        ctx-&gt;instance = inst;</span><br><span class="line">        ctx-&gt;ref = <span class="number">2</span>;</span><br><span class="line">        ctx-&gt;cb = <span class="literal">NULL</span>;</span><br><span class="line">        ctx-&gt;cb_ud = <span class="literal">NULL</span>;</span><br><span class="line">        ctx-&gt;session_id = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;logfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ctx-&gt;init = <span class="literal">false</span>;</span><br><span class="line">        ctx-&gt;endless = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ctx-&gt;cpu_cost = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;cpu_start = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;message_count = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;profile = G_NODE.profile;</span><br><span class="line">        <span class="comment">// Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle</span></span><br><span class="line">        ctx-&gt;handle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注册一个handle</span></span><br><span class="line">        ctx-&gt;handle = skynet_handle_register(ctx);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">queue</span> = <span class="title">ctx</span>-&gt;<span class="title">queue</span> = <span class="title">skynet_mq_create</span>(<span class="title">ctx</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">        <span class="comment">// init function maybe use ctx-&gt;handle, so it must init at last</span></span><br><span class="line">        context_inc();</span><br><span class="line"></span><br><span class="line">        CHECKCALLING_BEGIN(ctx)</span><br><span class="line">        <span class="comment">// 初始化服务</span></span><br><span class="line">        <span class="keyword">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);</span><br><span class="line">        CHECKCALLING_END(ctx)</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ret</span> = <span class="title">skynet_context_release</span>(<span class="title">ctx</span>);</span></span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        ctx-&gt;init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                skynet_globalmq_push(<span class="built_in">queue</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        skynet_error(ret, <span class="string">"LAUNCH %s %s"</span>, name, param ? param : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"FAILED launch %s"</span>, name);</span><br><span class="line">                <span class="keyword">uint32_t</span> handle = ctx-&gt;handle;</span><br><span class="line">                skynet_context_release(ctx);</span><br><span class="line">                skynet_handle_retire(handle);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> = &#123;</span> handle &#125;;</span><br><span class="line">                skynet_mq_release(<span class="built_in">queue</span>, drop_message, &amp;d);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数，</p>
<ol>
<li>首先会查看一下全局服务变量<strong>M</strong>中是否存在对应模块，如果存在，就初始化一个实例；  </li>
<li>初始化 服务的 skynet_context 结构，包括会分配一个唯一的 handle。<code>skynet_handle_register(ctx)</code>  ，然后将服务注册到  <strong>H</strong> 中。</li>
<li>建立服务的消息队列。<code>skynet_mq_create</code>  </li>
<li>初始化服务。<code>skynet_module_instance_init(mod, inst, ctx, param);</code>  其结果是调用模块自身的 <code>init</code>函数。  </li>
<li>然后把消息队列放在全局消息队列中。  </li>
</ol>
<h2 id="skynet-module-instance-create"><a href="#skynet-module-instance-create" class="headerlink" title="skynet_module_instance_create"></a>skynet_module_instance_create</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * </span><br><span class="line">skynet_module_instance_create(struct skynet_module *m) &#123;</span><br><span class="line">	<span class="keyword">if</span> (m-&gt;create) &#123;</span><br><span class="line">		<span class="keyword">return</span> m-&gt;create();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>)(~<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块实例的建立，实际上就是C 服务中的 create 函数的调用，其结果，一般都是返回一个服务需要的数据结构。如 logger, snlua, gate 服务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate</span> *</span></span><br><span class="line"><span class="class"><span class="title">gate_create</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gate</span> * <span class="title">g</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">g</span>));</span></span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(*g));</span><br><span class="line">	g-&gt;listen_id = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logger</span> *</span></span><br><span class="line"><span class="class"><span class="title">logger_create</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">logger</span> * <span class="title">inst</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">inst</span>));</span></span><br><span class="line">	inst-&gt;handle = <span class="literal">NULL</span>;</span><br><span class="line">	inst-&gt;<span class="built_in">close</span> = <span class="number">0</span>;</span><br><span class="line">	inst-&gt;filename = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *</span></span><br><span class="line"><span class="class"><span class="title">snlua_create</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> * <span class="title">l</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">l</span>));</span></span><br><span class="line">	<span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(*l));</span><br><span class="line">	l-&gt;mem_report = MEMORY_WARNING_REPORT;</span><br><span class="line">	l-&gt;mem_limit = <span class="number">0</span>;</span><br><span class="line">	l-&gt;L = lua_newstate(lalloc, l);</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="skynet-handle-register"><a href="#skynet-handle-register" class="headerlink" title="skynet_handle_register"></a>skynet_handle_register</h2><p>我们通过模块建立了一个服务后，事实上对于 skynet 来说，这个服务，就是一个 skynet_context ，其对具体的模块实际上是不关心的。</p>
<p>在  <strong>H</strong> 表中 slot 是服务的插槽，每个插槽都指向一个 skynet_context 结构。</p>
<p>下面这个逻辑会首先看一下插槽够用不，不够用就增大插槽，然后再注册后返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span></span><br><span class="line">skynet_handle_register(struct skynet_context *ctx) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> *<span class="title">s</span> = <span class="title">H</span>;</span></span><br><span class="line"></span><br><span class="line">	rwlock_wlock(&amp;s-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">uint32_t</span> handle = s-&gt;handle_index;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s-&gt;slot_size;i++,handle++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (handle &gt; HANDLE_MASK) &#123;</span><br><span class="line">				<span class="comment">// 0 is reserved</span></span><br><span class="line">				handle = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> hash = handle &amp; (s-&gt;slot_size<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;slot[hash] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				s-&gt;slot[hash] = ctx;</span><br><span class="line">				s-&gt;handle_index = handle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				rwlock_wunlock(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">				handle |= s-&gt;harbor;</span><br><span class="line">				<span class="keyword">return</span> handle;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		assert((s-&gt;slot_size*<span class="number">2</span> - <span class="number">1</span>) &lt;= HANDLE_MASK);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> ** <span class="title">new_slot</span> = <span class="title">skynet_malloc</span>(<span class="title">s</span>-&gt;<span class="title">slot_size</span> * 2 * <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">skynet_context</span> *));</span></span><br><span class="line">		<span class="built_in">memset</span>(new_slot, <span class="number">0</span>, s-&gt;slot_size * <span class="number">2</span> * <span class="keyword">sizeof</span>(struct skynet_context *));</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s-&gt;slot_size;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> hash = skynet_context_handle(s-&gt;slot[i]) &amp; (s-&gt;slot_size * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">			assert(new_slot[hash] == <span class="literal">NULL</span>);</span><br><span class="line">			new_slot[hash] = s-&gt;slot[i];</span><br><span class="line">		&#125;</span><br><span class="line">		skynet_free(s-&gt;slot);</span><br><span class="line">		s-&gt;slot = new_slot;</span><br><span class="line">		s-&gt;slot_size *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块（服务）的初始化"><a href="#模块（服务）的初始化" class="headerlink" title="模块（服务）的初始化"></a>模块（服务）的初始化</h2><p>每个模块的实例建立了以后，就会调用模块自己的初始化函数进行初始化设置。对于我们所有的Lua服务来说，其都是 <code>snlua</code>模块的一个实例。对于 <code>skyent_context_new()</code>中调用的函数<code>skynet_module_instance_init()</code>，我们看一下它的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_module.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_module_instance_init(struct skynet_module *m, <span class="keyword">void</span> * inst, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * parm) &#123;</span><br><span class="line">        <span class="keyword">return</span> m-&gt;init(inst, ctx, parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个其实就是 <code>c server</code>模块中的 <code>init</code>函数。</p>
<p>现在框架提供的服务有 :logger, gate,snlua, harbor,默认4个，所以 H 表流了四个 slot 在。</p>
<h2 id="snlua"><a href="#snlua" class="headerlink" title="snlua"></a>snlua</h2><p>snlua 实际上已经建立了一个 lua_State。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service_src/service_snlua.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> &#123;</span></span><br><span class="line">        lua_State * L;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> mem;</span><br><span class="line">        <span class="keyword">size_t</span> mem_report;</span><br><span class="line">        <span class="keyword">size_t</span> mem_limit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">snlua_init(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="built_in">strlen</span>(args);</span><br><span class="line">        <span class="keyword">char</span> * tmp = skynet_malloc(sz);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, args, sz);</span><br><span class="line">        <span class="comment">// 设置 ctx 回调函数为 launch_cb</span></span><br><span class="line">        skynet_callback(ctx, l , launch_cb);</span><br><span class="line">        <span class="comment">// 这个就是返回一个自己的服务名字。如果我们传入 最后一个参数不是NULL，不是空字符，也不是以 . 开头就会出错。因为不以 . 开头的是系统服务。这个命令，是向 **H** 注册一个名字的意思。默认我 NULL，就是返回一个 : handleId 这样的值。 [:00000009]</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * self = skynet_command(ctx, <span class="string">"REG"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">uint32_t</span> handle_id = strtoul(self+<span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// it must be first message</span></span><br><span class="line">        <span class="comment">// 模块向服务发送消息。参数：ctx, 源（0代表自己），目标handle，类型，seesionId,数据，大小。第一条消息会被发送给设置的回调。这个消息，会发送到 handle_Id 标识的 ctx 消息队列中。由消息调度线程查询消息后分发。</span></span><br><span class="line">        skynet_send(ctx, <span class="number">0</span>, handle_id, PTYPE_TAG_DONTCOPY,<span class="number">0</span>, tmp, sz);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">launch_cb(struct skynet_context * context, <span class="keyword">void</span> *ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source , <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        assert(type == <span class="number">0</span> &amp;&amp; session == <span class="number">0</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *<span class="title">l</span> = <span class="title">ud</span>;</span></span><br><span class="line">        skynet_callback(context, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> err = init_cb(l, context, msg, sz);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                skynet_command(context, <span class="string">"EXIT"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">init_cb(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        lua_State *L = l-&gt;L;</span><br><span class="line">        l-&gt;ctx = ctx;</span><br><span class="line">        lua_gc(L, LUA_GCSTOP, <span class="number">0</span>);</span><br><span class="line">        lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">        lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"LUA_NOENV"</span>);</span><br><span class="line">        luaL_openlibs(L);</span><br><span class="line">        lua_pushlightuserdata(L, ctx);</span><br><span class="line">        lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>);</span><br><span class="line">        luaL_requiref(L, <span class="string">"skynet.codecache"</span>, codecache , <span class="number">0</span>);</span><br><span class="line">        lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path = optstring(ctx, <span class="string">"lua_path"</span>,<span class="string">"./lualib/?.lua;./lualib/?/init.lua"</span>);</span><br><span class="line">        lua_pushstring(L, path);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_PATH"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *cpath = optstring(ctx, <span class="string">"lua_cpath"</span>,<span class="string">"./luaclib/?.so"</span>);</span><br><span class="line">        lua_pushstring(L, cpath);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_CPATH"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *service = optstring(ctx, <span class="string">"luaservice"</span>, <span class="string">"./service/?.lua"</span>);</span><br><span class="line">        lua_pushstring(L, service);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_SERVICE"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *preload = skynet_command(ctx, <span class="string">"GETENV"</span>, <span class="string">"preload"</span>);</span><br><span class="line">        lua_pushstring(L, preload);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_PRELOAD"</span>);</span><br><span class="line"></span><br><span class="line">        lua_pushcfunction(L, traceback);</span><br><span class="line">        assert(lua_gettop(L) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = luaL_loadfile(L,loader);</span><br><span class="line">        <span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">                report_launcher_error(ctx);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                lua_pushlstring(L, args, sz);</span><br><span class="line">        r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"lua loader error : %s"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">                report_launcher_error(ctx);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lua_settop(L,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">                <span class="keyword">size_t</span> limit = lua_tointeger(L, <span class="number">-1</span>);</span><br><span class="line">                l-&gt;mem_limit = limit;</span><br><span class="line">                skynet_error(ctx, <span class="string">"Set memory limit to %.2f M"</span>, (<span class="keyword">float</span>)limit / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">                lua_pushnil(L);</span><br><span class="line">                lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua_pop(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        lua_gc(L, LUA_GCRESTART, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，每个snlua结构都有自己的 Lua State，所以所有的代码都是snlua自己的内部执行的，不会影响其他的Lua State。</p>
<p>这个函数都干了什么：</p>
<ol>
<li>设置对应服务 ctx 的回调函数为 <code>launch_cb</code>；  </li>
<li>注册自身；  </li>
<li>向 ctx 发送消息（入列）。</li>
<li>收到消息后会回调 <code>launch_cb</code>，而这个函数会又取消调回调函数。转而调用 <code>init_cb</code>函数。进行初始化 snlua中的 Lua State;  </li>
<li>这个函数才调用<code>loader.lua</code>来真正的加载服务脚本等操作。</li>
</ol>
<h1 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap()"></a>bootstrap()</h1><p>之前我们只启动了一个 logger 服务。现在我们要开始启动新的服务了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line">      <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, <span class="built_in">config</span>-&gt;logservice);</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，会以<em>logger, NULL</em>为参数调用 <code>skynet_context_new(“logger”, NULL)</code>函数，建立一个关于 <em>logger</em>服务的<code>skynet_context</code>的结构，其实就是启动了 <em>logger</em>服务。</p>
<p>然后调用<code>bootstrap(ctx, config-&gt;bootstrap)</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//skynet_start.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bootstrap(struct skynet_context * logger, <span class="keyword">const</span> <span class="keyword">char</span> * cmdline) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="built_in">strlen</span>(cmdline);</span><br><span class="line">        <span class="keyword">char</span> name[sz+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">char</span> args[sz+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sscanf</span>(cmdline, <span class="string">"%s %s"</span>, name, args);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">name</span>, <span class="title">args</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                skynet_error(<span class="literal">NULL</span>, <span class="string">"Bootstrap error : %s\n"</span>, cmdline);</span><br><span class="line">                skynet_context_dispatchall(logger);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>config-&gt;bootstrap</code>是<code>snlua bootstrap</code>。事实上最终执行的函数是<code>skynet_context_new(&quot;snlua&quot;, &quot;bootstrap&quot;)</code>，如此又建立一个服务结构，并用<em>bootstrap</em>参数进行初始化。如果服务建立失败，就会将所有的信息发送到 <em>logger</em>，并处理全部的 <em>logger</em>服务的消息。</p>
<p><strong>snlua</strong>作为沙盒服务，会再入<code>lua</code>脚本并进行执行。</p>
<p>实际上 snlua 会利用  lualib/loader.lua 来加载我们的 bootstrap 脚本。然后进行启动。</p>
<blockquote>
<p>bootstrap 这个配置项关系着 skynet 运行的第二个服务。通常通过这个服务把整个系统启动起来。默认的 bootstrap 配置项为 “snlua bootstrap” ，这意味着，skynet 会启动 snlua 这个服务，并将 bootstrap 作为参数传给它。snlua 是 lua 沙盒服务，bootstrap 会根据配置的 luaservice 匹配到最终的 lua 脚本。如果按默认配置，这个脚本应该是 service/bootstrap.lua 。</p>
</blockquote>
<blockquote>
<p>如无必要，你不需要更改 bootstrap 配置项，让默认的 bootstrap 脚本工作。</p>
</blockquote>
<blockquote>
<p>最后，它从 config 中读取 start 这个配置项，作为用户定义的服务启动入口脚本运行。成功后，把自己退出。</p>
</blockquote>
<blockquote>
<p>这个 start 配置项，才是用户定义的启动脚本，默认值为 “main” 。如果你只是试玩一下 skynet ，可能有多份不同的启动脚本，那么建议你多写几份 config 文件，在里面配置不同的 start 项。examples 目录下有很多这样的例子。</p>
</blockquote>
<p>最终，bootstrap 会将我们配置在配置文件中的 start 脚本加载进来，启动。其他服务。</p>
<h1 id="start-thread-config-gt-thread"><a href="#start-thread-config-gt-thread" class="headerlink" title="start_thread(config-&gt;thread)"></a>start_thread(config-&gt;thread)</h1><p>此函数用来启动我们设置的线程数。一共启动了<em>config-&gt;thread + 3</em>个线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> ** <span class="title">m</span>;</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">        <span class="keyword">int</span> sleep;</span><br><span class="line">        <span class="keyword">int</span> quit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start(<span class="keyword">int</span> thread) &#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> pid[thread+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">m</span>));</span></span><br><span class="line">        <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line">        m-&gt;count = thread;</span><br><span class="line">        m-&gt;sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m-&gt;m = skynet_malloc(thread * <span class="keyword">sizeof</span>(struct skynet_monitor *));</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">                m-&gt;m[i] = skynet_monitor_new();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;m-&gt;mutex, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Init mutex error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pthread_cond_init(&amp;m-&gt;cond, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Init cond error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> weight[] = &#123;</span><br><span class="line">                <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;;</span><br><span class="line">                 <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">                wp[i].m = m;</span><br><span class="line">                wp[i].id = i;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;</span><br><span class="line">                        wp[i].weight= weight[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        wp[i].weight = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread+<span class="number">3</span>;i++) &#123;</span><br><span class="line">                pthread_join(pid[i], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free_monitor(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，函数先建立了一个监控器<strong>m</strong>，并初始化了<em>线程数，睡眠数分别为(8, 0)</em>，然后，再为每个线程建立了skynet自己的监控数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_monitor.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> version;</span><br><span class="line">        <span class="keyword">int</span> check_version;</span><br><span class="line">        <span class="keyword">uint32_t</span> source;</span><br><span class="line">        <span class="keyword">uint32_t</span> destination;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们可以看到，是通过 互斥量 和条件变量来进行线程的抢占使用的。接着建立了三个线程和<em>thread(默认是8)</em>个工作线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span>;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">        create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> weight[] = &#123;</span><br><span class="line">                <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">                wp[i].m = m;</span><br><span class="line">                wp[i].id = i;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;</span><br><span class="line">                        wp[i].weight= weight[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        wp[i].weight = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>建立了一个工作线程参数表<code>struct worker_parm wp[thread];</code>，并设置每个线程的权重，然后启动线程，线程ID保存在<em>pid</em>数组内。</p>
<h2 id="thread-worker"><a href="#thread-worker" class="headerlink" title="thread_worker"></a>thread_worker</h2><p>工作线程循环从队列内取出消息进行处理，如果没有消息，就从全局消息队列去取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">thread_worker(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> *<span class="title">wp</span> = <span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">int</span> id = wp-&gt;id;</span><br><span class="line">        <span class="keyword">int</span> weight = wp-&gt;weight;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> = <span class="title">wp</span>-&gt;<span class="title">m</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span> = <span class="title">m</span>-&gt;<span class="title">m</span>[<span class="title">id</span>];</span></span><br><span class="line">        skynet_initthread(THREAD_WORKER);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">q</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (!m-&gt;quit) &#123;</span><br><span class="line">                q = skynet_context_message_dispatch(sm, q, weight);</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pthread_mutex_lock(&amp;m-&gt;mutex) == <span class="number">0</span>) &#123;</span><br><span class="line">                                ++ m-&gt;sleep;</span><br><span class="line">                                <span class="comment">// "spurious wakeup" is harmless,</span></span><br><span class="line">                                <span class="comment">// because skynet_context_message_dispatch() can be call at any time.</span></span><br><span class="line">                                <span class="keyword">if</span> (!m-&gt;quit)</span><br><span class="line">                                        pthread_cond_wait(&amp;m-&gt;cond, &amp;m-&gt;mutex);</span><br><span class="line">                                -- m-&gt;sleep;</span><br><span class="line">                                <span class="keyword">if</span> (pthread_mutex_unlock(&amp;m-&gt;mutex)) &#123;</span><br><span class="line">                                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unlock mutex error"</span>);</span><br><span class="line">                                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>skynet_initthread(THREAD_WORKER);</code>用于在线程特定数据内保存自己的<em>handlekey</em>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_initthread(<span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> v = (<span class="keyword">uint32_t</span>)(-m);</span><br><span class="line">        pthread_setspecific(G_NODE.handle_key, (<span class="keyword">void</span> *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个工作线程，都是调用<code>skynet_context_message_dispatch(sm, q, wight)</code>来从消息队列获取信息，如果获取不到，就进入睡眠状态。直到条件变量条件满足，才进行唤醒。</p>
<p>当线程的消息队列不存在的时候，就会从全局消息队列获取一个消息队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_mq.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> handle;</span><br><span class="line">        <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">int</span> head;</span><br><span class="line">        <span class="keyword">int</span> tail;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">release</span>;</span><br><span class="line">        <span class="keyword">int</span> in_global;</span><br><span class="line">        <span class="keyword">int</span> overload;</span><br><span class="line">        <span class="keyword">int</span> overload_threshold;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> *<span class="title">queue</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">head</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">tail</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_globalmq_pop</span>() &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> *<span class="title">q</span> = <span class="title">Q</span>;</span></span><br><span class="line"></span><br><span class="line">        SPIN_LOCK(q)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">mq</span> = <span class="title">q</span>-&gt;<span class="title">head</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(mq) &#123;</span><br><span class="line">                q-&gt;head = mq-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(q-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        assert(mq == q-&gt;tail);</span><br><span class="line">                        q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mq-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SPIN_UNLOCK(q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_context_message_dispatch</span>(<span class="title">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span>, <span class="title">struct</span> <span class="title">message_queue</span> *<span class="title">q</span>, <span class="title">int</span> <span class="title">weight</span>) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q = skynet_globalmq_pop();</span><br><span class="line">                <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> handle = skynet_mq_handle(q);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_handle_grab</span>(<span class="title">handle</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> = &#123;</span> handle &#125;;</span><br><span class="line">                skynet_mq_release(q, drop_message, &amp;d);</span><br><span class="line">                <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i,n=<span class="number">1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;</span><br><span class="line">                        skynet_context_release(ctx);</span><br><span class="line">                        <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        n = skynet_mq_length(q);</span><br><span class="line">                        n &gt;&gt;= weight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> overload = skynet_mq_overload(q);</span><br><span class="line">                <span class="keyword">if</span> (overload) &#123;</span><br><span class="line">                        skynet_error(ctx, <span class="string">"May overload, message queue length = %d"</span>, overload);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                skynet_monitor_trigger(sm, msg.source , handle);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        skynet_free(msg.data);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dispatch_message(ctx, &amp;msg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(q == ctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">nq</span> = <span class="title">skynet_globalmq_pop</span>();</span></span><br><span class="line">        <span class="keyword">if</span> (nq) &#123;</span><br><span class="line">                <span class="comment">// If global mq is not empty , push q back, and return next queue (nq)</span></span><br><span class="line">                <span class="comment">// Else (global mq is empty or block, don't push q back, and return q again (for next dispatch)</span></span><br><span class="line">                skynet_globalmq_push(q);</span><br><span class="line">                q = nq;</span><br><span class="line">        &#125;</span><br><span class="line">        skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理消息最主要的就是这个函数了：</p>
<ol>
<li>如果传入的消息队列<em>q</em>为空，就会重新从全局队列弹出一个。  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = skynet_globalmq_pop();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获得弹出消息队列的 handle，根据handle来找到对应的 服务 ctx； </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> handle = skynet_mq_handle(q);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从队列取消息。  如果从特定的消息队列弹出消息失败，就会从全局队列返回一个新的消息队列。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,n=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;</span><br><span class="line">                skynet_context_release(ctx);</span><br><span class="line">                <span class="comment">// 弹出消息失败，返回一个新的消息队列</span></span><br><span class="line">                <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">                <span class="comment">// 根据线程权重设置来获取消息数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                n = skynet_mq_length(q);</span><br><span class="line">                n &gt;&gt;= weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> overload = skynet_mq_overload(q);</span><br><span class="line">        <span class="keyword">if</span> (overload) &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"May overload, message queue length = %d"</span>, overload);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skynet_monitor_trigger(sm, msg.source , handle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                skynet_free(msg.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_message(ctx, &amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>调用<code>dispatch_message(ctx, &amp;msg)</code>；  此函数会调用注册的回调函数处理消息。   </li>
<li>消息处理完毕后，检查全局消息队列是否为空，如果为空的话，就继续返回当前队列；如果全局消息队列不为空， 就返回一个新的消息队列。</li>
</ol>
<p><strong>也就是说，默认情况下，每个线程每次只会处理全局消息队列中，某一消息队列的一条消息。</strong></p>
<h2 id="thread-socket"><a href="#thread-socket" class="headerlink" title="thread_socket"></a>thread_socket</h2><p>这个线程，会轮询所有的的套接字，具体的工作在<code>skynet_socket_poll()</code>内完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">thread_socket(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> * <span class="title">m</span> = <span class="title">p</span>;</span></span><br><span class="line">        skynet_initthread(THREAD_SOCKET);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = skynet_socket_poll();</span><br><span class="line">                <span class="keyword">if</span> (r==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                        CHECK_ABORT</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup(m,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数会获取获取消息类型和消息内容，并进行消息转发。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_socket.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_socket_poll() &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> = <span class="title">SOCKET_SERVER</span>;</span></span><br><span class="line">        assert(ss);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_message</span> <span class="title">result</span>;</span></span><br><span class="line">        <span class="keyword">int</span> more = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> type = socket_server_poll(ss, &amp;result, &amp;more);</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_EXIT:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_DATA:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_DATA, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_CLOSE:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_CLOSE, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_OPEN:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_CONNECT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_ERR:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_ERROR, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_ACCEPT:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_ACCEPT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_UDP:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_UDP, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_WARNING:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_WARNING, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                skynet_error(<span class="literal">NULL</span>, <span class="string">"Unknown socket message type %d."</span>,type);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的主要工作还是由 <code>socket_service_poll(ss, &amp;result, &amp;more)</code>来完成的。该函数会返回套接字消息的类型，消息本身及是否有更多消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket_server.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">socket_server_poll(struct socket_server *ss, struct socket_message * result, <span class="keyword">int</span> * more) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;checkctrl) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (has_cmd(ss)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type = ctrl_cmd(ss, result);</span><br><span class="line">                                <span class="keyword">if</span> (type != <span class="number">-1</span>) &#123;</span><br><span class="line">                                        clear_closed_event(ss, result, type);</span><br><span class="line">                                        <span class="keyword">return</span> type;</span><br><span class="line">                                &#125; <span class="keyword">else</span></span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ss-&gt;checkctrl = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;event_index == ss-&gt;event_n) &#123;</span><br><span class="line">                        ss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);</span><br><span class="line">                        ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                                *more = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ss-&gt;event_n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">ev</span>[<span class="title">ss</span>-&gt;<span class="title">event_index</span>++];</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = <span class="title">e</span>-&gt;<span class="title">s</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="comment">// dispatch pipe message at beginning</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">                socket_lock_init(s, &amp;l);</span><br><span class="line">                <span class="keyword">switch</span> (s-&gt;type) &#123;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_CONNECTING:</span><br><span class="line">                        <span class="keyword">return</span> report_connect(ss, s, &amp;l, result);</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_LISTEN: &#123;</span><br><span class="line">                        <span class="keyword">int</span> ok = report_accept(ss, s, result);</span><br><span class="line">                        <span class="keyword">if</span> (ok &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ACCEPT;</span><br><span class="line">                        &#125; <span class="keyword">if</span> (ok &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// when ok == 0, retry</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_INVALID:</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: invalid socket\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;<span class="built_in">read</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type;</span><br><span class="line">                                <span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">                                                                        type = forward_message_tcp(ss, s, &amp;l, result);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        type = forward_message_udp(ss, s, &amp;l, result);</span><br><span class="line">                                        <span class="keyword">if</span> (type == SOCKET_UDP) &#123;</span><br><span class="line">                                                <span class="comment">// try read again</span></span><br><span class="line">                                                --ss-&gt;event_index;</span><br><span class="line">                                                <span class="keyword">return</span> SOCKET_UDP;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (e-&gt;<span class="built_in">write</span> &amp;&amp; type != SOCKET_CLOSE &amp;&amp; type != SOCKET_ERR) &#123;</span><br><span class="line">                                        <span class="comment">// Try to dispatch write message next step if write flag set.</span></span><br><span class="line">                                        e-&gt;<span class="built_in">read</span> = <span class="literal">false</span>;</span><br><span class="line">                                        --ss-&gt;event_index;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;<span class="built_in">write</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type = send_buffer(ss, s, &amp;l, result);</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;error) &#123;</span><br><span class="line">                                <span class="comment">// close when error</span></span><br><span class="line">                                <span class="keyword">int</span> error;</span><br><span class="line">                                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">                                <span class="keyword">int</span> code = getsockopt(s-&gt;fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span> * err = <span class="literal">NULL</span>;</span><br><span class="line">                                <span class="keyword">if</span> (code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(errno);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(error);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        err = <span class="string">"Unknown error"</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                                                force_close(ss, s, &amp;l, result);</span><br><span class="line">                                result-&gt;data = (<span class="keyword">char</span> *)err;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forward_message</code>会被对应类型的消息，压入到对应服务结构中的消息队列去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_socket.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forward_message(<span class="keyword">int</span> type, <span class="keyword">bool</span> padding, struct socket_message * result) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_socket_message</span> *<span class="title">sm</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(*sm);</span><br><span class="line">        <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result-&gt;data) &#123;</span><br><span class="line">                        <span class="keyword">size_t</span> msg_sz = <span class="built_in">strlen</span>(result-&gt;data);</span><br><span class="line">                        <span class="keyword">if</span> (msg_sz &gt; <span class="number">128</span>) &#123;</span><br><span class="line">                                msg_sz = <span class="number">128</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sz += msg_sz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result-&gt;data = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sm = (struct skynet_socket_message *)skynet_malloc(sz);</span><br><span class="line">        sm-&gt;type = type;</span><br><span class="line">        sm-&gt;id = result-&gt;id;</span><br><span class="line">        sm-&gt;ud = result-&gt;ud;</span><br><span class="line">        <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">                        sm-&gt;<span class="built_in">buffer</span> = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(sm+<span class="number">1</span>, result-&gt;data, sz - <span class="keyword">sizeof</span>(*sm));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sm-&gt;<span class="built_in">buffer</span> = result-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">message</span>;</span></span><br><span class="line">        message.source = <span class="number">0</span>;</span><br><span class="line">        message.session = <span class="number">0</span>;</span><br><span class="line">        message.data = sm;</span><br><span class="line">        message.sz = sz | ((<span class="keyword">size_t</span>)PTYPE_SOCKET &lt;&lt; MESSAGE_TYPE_SHIFT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skynet_context_push((<span class="keyword">uint32_t</span>)result-&gt;opaque, &amp;message)) &#123;</span><br><span class="line">                <span class="comment">// todo: report somewhere to close socket</span></span><br><span class="line">                <span class="comment">// don't call skynet_socket_close here (It will block mainloop)</span></span><br><span class="line">                skynet_free(sm-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">                skynet_free(sm);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其是通过 <code>skynet_context_push()</code>函数实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_context_push(<span class="keyword">uint32_t</span> handle, struct skynet_message *message) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_handle_grab</span>(<span class="title">handle</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        skynet_mq_push(ctx-&gt;<span class="built_in">queue</span>, message);</span><br><span class="line">        skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过handle来找到服务的ctx-&gt;queue，然后压进去。</p>
<h1 id="从服务的注册看起。"><a href="#从服务的注册看起。" class="headerlink" title="从服务的注册看起。"></a>从服务的注册看起。</h1><p>我们通过Lua编写的所有服务，都是通过 <code>skynet.newservice</code>函数注册的。这是一个Lua函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.newservice</span><span class="params">(name, ...)</span></span></span><br><span class="line">        <span class="keyword">return</span> skynet.call(<span class="string">".launcher"</span>, <span class="string">"lua"</span> , <span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> p = proto[typename]</span><br><span class="line">        <span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))</span><br><span class="line">        <span class="keyword">if</span> session == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">error</span>(<span class="string">"call to invalid address "</span> .. skynet.address(addr))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>其本质，是通过 <code>skynet.call</code>函数向 <em>.launcher</em>服务，发送 <em>lua</em>类型的消息，加上一系列参数实现的。</p>
<p>而<code>skynet.call</code>则调用的是导出的C函数 <code>skynet_core.send</code>，更具体的C函数就是<code>lsend</code>。具体函数的导出参看另外一篇文章<a href="https://gowa2017.github.io/Lua/skynet%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%BD%BD%E5%85%A5%E6%B5%81%E7%A8%8B.html" target="_blank" rel="noopener">skynet的启动与服务载入流程</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lualib-src/lua-skynet.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lsend(lua_State *L) &#123;</span><br><span class="line">        <span class="keyword">return</span> send_message(L, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_message(lua_State *L, <span class="keyword">int</span> source, <span class="keyword">int</span> idx_type) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">        <span class="keyword">uint32_t</span> dest = (<span class="keyword">uint32_t</span>)lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * dest_string = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (dest == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lua_type(L,<span class="number">1</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">                        <span class="keyword">return</span> luaL_error(L, <span class="string">"Invalid service address 0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dest_string = get_dest_string(L, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> type = luaL_checkinteger(L, idx_type+<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> session = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lua_isnil(L,idx_type+<span class="number">1</span>)) &#123;</span><br><span class="line">                type |= PTYPE_TAG_ALLOCSESSION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                session = luaL_checkinteger(L,idx_type+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mtype = lua_type(L,idx_type+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">switch</span> (mtype) &#123;</span><br><span class="line">                <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">                <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">void</span> * msg = (<span class="keyword">void</span> *)lua_tolstring(L,idx_type+<span class="number">2</span>,&amp;len);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                        msg = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dest_string) &#123;</span><br><span class="line">                        session = skynet_sendname(context, source, dest_string, type, session , msg, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        session = skynet_send(context, source, dest, type, session , msg, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> LUA_TLIGHTUSERDATA: &#123;</span><br><span class="line">                <span class="keyword">void</span> * msg = lua_touserdata(L,idx_type+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">size</span> = luaL_checkinteger(L,idx_type+<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (dest_string) &#123;</span><br><span class="line">                        session = skynet_sendname(context, source, dest_string, type | PTYPE_TAG_DONTCOPY, session, msg, <span class="built_in">size</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        session = skynet_send(context, source, dest, type | PTYPE_TAG_DONTCOPY, session, msg, <span class="built_in">size</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                luaL_error(L, <span class="string">"invalid param %s"</span>, lua_typename(L, lua_type(L,idx_type+<span class="number">2</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// send to invalid address</span></span><br><span class="line">                <span class="comment">// todo: maybe throw an error would be better</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                lua_pushinteger(L,session);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，是通过<code>skynet_server.c</code>中的的 <code>skynet_context_push</code>函数将消息推到对应的<code>skynet_context</code>结构中的消息队列中去，接着就返回 sessionId。</p>
<h2 id="消息分发函数"><a href="#消息分发函数" class="headerlink" title="消息分发函数"></a>消息分发函数</h2><p>每个业务脚本都会注册一个消息处理函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">        c.callback(skynet.dispatch_message)</span><br><span class="line">        skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                skynet.init_service(start_func)</span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>每次收到消息的时候就会调用这个消息处理函数。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Lua/" rel="tag"># Lua</a>
              <a href="/tags/Skynet/" rel="tag"># Skynet</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Lua/skynet%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%BD%BD%E5%85%A5%E6%B5%81%E7%A8%8B.html" rel="next" title="Skynet的启动与服务载入流程">
                  <i class="fa fa-chevron-left"></i> Skynet的启动与服务载入流程
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/Lua/PIL.29Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E5%87%BD%E6%95%B0.html" rel="prev" title="PIL.29Lua中调用C函数">
                  PIL.29Lua中调用C函数 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#skyent-main"><span class="nav-number">1.</span> <span class="nav-text">skyent main()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skynet-globalinit-全局节点初始化"><span class="nav-number">2.</span> <span class="nav-text">skynet_globalinit() - 全局节点初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skynet-env-init-－全局环境变量"><span class="nav-number">3.</span> <span class="nav-text">skynet_env_init()－全局环境变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#luaL-initcodecache"><span class="nav-number">4.</span> <span class="nav-text">luaL_initcodecache</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置加载"><span class="nav-number">5.</span> <span class="nav-text">配置加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#init-env-L"><span class="nav-number">6.</span> <span class="nav-text">__init_env(L)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skynet-start-amp-config"><span class="nav-number">7.</span> <span class="nav-text">skynet_start(&amp;config)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-harbor-init-int-harbor"><span class="nav-number">7.1.</span> <span class="nav-text">skynet_harbor_init(int harbor)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-handle-init"><span class="nav-number">7.2.</span> <span class="nav-text">skynet_handle_init()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-module-init"><span class="nav-number">7.3.</span> <span class="nav-text">skynet_module_init()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-mq-init"><span class="nav-number">7.4.</span> <span class="nav-text">skynet_mq_init()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-timer-init"><span class="nav-number">7.5.</span> <span class="nav-text">skynet_timer_init();</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-socket-init"><span class="nav-number">7.6.</span> <span class="nav-text">skynet_socket_init();</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skynet-context-结构"><span class="nav-number">8.</span> <span class="nav-text">skynet_context 结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务-H-表"><span class="nav-number">9.</span> <span class="nav-text">服务 H 表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-create-new"><span class="nav-number">9.1.</span> <span class="nav-text">skynet_create_new()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-module-instance-create"><span class="nav-number">9.2.</span> <span class="nav-text">skynet_module_instance_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-handle-register"><span class="nav-number">9.3.</span> <span class="nav-text">skynet_handle_register</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块（服务）的初始化"><span class="nav-number">9.4.</span> <span class="nav-text">模块（服务）的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#snlua"><span class="nav-number">9.5.</span> <span class="nav-text">snlua</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bootstrap"><span class="nav-number">10.</span> <span class="nav-text">bootstrap()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#start-thread-config-gt-thread"><span class="nav-number">11.</span> <span class="nav-text">start_thread(config-&gt;thread)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-worker"><span class="nav-number">11.1.</span> <span class="nav-text">thread_worker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-socket"><span class="nav-number">11.2.</span> <span class="nav-text">thread_socket</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从服务的注册看起。"><span class="nav-number">12.</span> <span class="nav-text">从服务的注册看起。</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#消息分发函数"><span class="nav-number">12.1.</span> <span class="nav-text">消息分发函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gowa2017 Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">294</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gowa2017" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gowa2017" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mailto:shouzheng.zhang@gmail.com" title="E-Mail → mailto:shouzheng.zhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-json"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gowa2017 Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>














  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gowa-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://gowa.club/Lua/skynet-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%8A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html",
            identifier: "Lua/skynet-任务调度及消息处理.html",
            title: "skynet-任务调度及消息处理"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gowa-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
</script>

</body>
</html>
