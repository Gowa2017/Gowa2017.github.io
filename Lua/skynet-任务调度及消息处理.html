<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>skynet-任务调度及消息处理 | 退思园</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">skynet-任务调度及消息处理</h1><a id="logo" href="/.">退思园</a><p class="description">烦恼一般都是想太多了。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/workflow"><i class="fa fa-rss"> workflow</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">skynet-任务调度及消息处理</h1><div class="post-meta"><a href="/Lua/skynet-任务调度及消息处理.html#comments" class="comment-count"><i data-disqus-identifier="Lua/skynet-任务调度及消息处理.html" class="disqus-comment-count"></i>留言</a><p><span class="date">Feb 04, 2018</span><span><a href="/categories/Lua/" class="category">Lua</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>通过将配置文件传入skynet后，其就会根据我们的脚本逻辑业务单元来启动对应的服务，然后把收到的消息进行分发处理。一般来说，这个框架针对的是网络游戏服务器，所以肯定会面向网络套接字信息这样的，但是也有进程间消息传递的处理机制。下面我们来看一下。<br><a id="more"></a></p>
<h1 id="skyent-main"><a href="#skyent-main" class="headerlink" title="skyent main()"></a>skyent main()</h1><p>在文件<code>skynet_main.c</code>文件中，定义了一个<em>main()</em>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * config_file = <span class="literal">NULL</span> ;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		config_file = argv[<span class="number">1</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Need a config file. Please read skynet wiki : https://github.com/cloudwu/skynet/wiki/Config\n"</span></span><br><span class="line">			<span class="string">"usage: skynet configfilename\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skynet_globalinit();</span><br><span class="line">	skynet_env_init();</span><br><span class="line"></span><br><span class="line">	sigign();</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LUA_CACHELIB</span></span><br><span class="line">	<span class="comment">// init the lock of code cache</span></span><br><span class="line">	luaL_initcodecache();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">L</span> = <span class="title">luaL_newstate</span>();</span></span><br><span class="line">	luaL_openlibs(L);	<span class="comment">// link lua lib</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err =  luaL_loadbufferx(L, load_config, <span class="built_in">strlen</span>(load_config), <span class="string">"=[skynet config]"</span>, <span class="string">"t"</span>);</span><br><span class="line">	assert(err == LUA_OK);</span><br><span class="line">	lua_pushstring(L, config_file);</span><br><span class="line"></span><br><span class="line">	err = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">		lua_close(L);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_init_env(L);</span><br><span class="line"></span><br><span class="line">	config.thread =  optint(<span class="string">"thread"</span>,<span class="number">8</span>);</span><br><span class="line">	config.module_path = optstring(<span class="string">"cpath"</span>,<span class="string">"./cservice/?.so"</span>);</span><br><span class="line">	config.harbor = optint(<span class="string">"harbor"</span>, <span class="number">1</span>);</span><br><span class="line">	config.bootstrap = optstring(<span class="string">"bootstrap"</span>,<span class="string">"snlua bootstrap"</span>);</span><br><span class="line">	config.daemon = optstring(<span class="string">"daemon"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	config.logger = optstring(<span class="string">"logger"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	config.logservice = optstring(<span class="string">"logservice"</span>, <span class="string">"logger"</span>);</span><br><span class="line">	config.profile = optboolean(<span class="string">"profile"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	lua_close(L);</span><br><span class="line"></span><br><span class="line">	skynet_start(&amp;config);</span><br><span class="line">	skynet_globalexit();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数做了几件事情：</p>
<ol>
<li>初始化全局环境。<code>skynet_globalinit()</code>  </li>
<li>初始化环境变量。<code>skynet_env_init()</code>  </li>
<li>使用 Lua 加载代码来来加载我们的配置文件。<code>luaL_loadbufferx()</code>  </li>
<li>就是读取传入的配置文件，解析参数，然后以<code>skynet_start(&amp;config)</code>进行启动。</li>
</ol>
<h1 id="skynet-globalinit-全局节点初始化"><a href="#skynet-globalinit-全局节点初始化" class="headerlink" title="skynet_globalinit() - 全局节点初始化"></a>skynet_globalinit() - 全局节点初始化</h1><p>这个函数，会初始化全局的节点信息，被设置主线程内的控制键值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> total;</span><br><span class="line">        <span class="keyword">int</span> init;</span><br><span class="line">        <span class="keyword">uint32_t</span> monitor_exit;</span><br><span class="line">        <span class="keyword">pthread_key_t</span> handle_key;</span><br><span class="line">        <span class="keyword">bool</span> profile;   <span class="comment">// default is off</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">skynet_node</span> <span class="title">G_NODE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_globalinit(<span class="keyword">void</span>) &#123;</span><br><span class="line">        G_NODE.total = <span class="number">0</span>;</span><br><span class="line">        G_NODE.monitor_exit = <span class="number">0</span>;</span><br><span class="line">        G_NODE.init = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pthread_key_create(&amp;G_NODE.handle_key, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_key_create failed"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set mainthread's key</span></span><br><span class="line">        skynet_initthread(THREAD_MAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_initthread(<span class="keyword">int</span> m) &#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> v = (<span class="keyword">uint32_t</span>)(-m);</span><br><span class="line">	pthread_setspecific(G_NODE.handle_key, (<span class="keyword">void</span> *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来，在主线程上创建了一个线程存储键，并初始化为 THREAD_MAIN,这个常量定义为 1。</p>
<p>初始化全局的节点信息，这个应该是为了分布式或多节点而来的。</p>
<h1 id="skynet-env-init-－全局环境变量"><a href="#skynet-env-init-－全局环境变量" class="headerlink" title="skynet_env_init()－全局环境变量"></a>skynet_env_init()－全局环境变量</h1><p>这个文件，初始化一个全局的环境变量<strong>E</strong>，可以看到这个全局变量其实也是用一个 lua_State 来保存我们的配置的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_env.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_env</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">        lua_State *L;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">skynet_env</span> *<span class="title">E</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_env_init() &#123;</span><br><span class="line">        E = skynet_malloc(<span class="keyword">sizeof</span>(*E));</span><br><span class="line">        SPIN_INIT(E)</span><br><span class="line">        E-&gt;L = luaL_newstate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>spinlock 就是一个整型，不知道是做什么用处的，可能是和锁相关的内容。<br>想要对全局环境进行修改的时候，势必要获取这个锁。</p>
<h1 id="luaL-initcodecache"><a href="#luaL-initcodecache" class="headerlink" title="luaL_initcodecache"></a>luaL_initcodecache</h1><p>这个函数，原生的 Lua 是不具备的，是在 lauxlib.c 内增加 的这么一个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3rd/lua/lauxlib.c</span></span><br><span class="line"></span><br><span class="line">LUALIB_API <span class="keyword">void</span></span><br><span class="line">luaL_initcodecache(<span class="keyword">void</span>) &#123;</span><br><span class="line">	SPIN_INIT(&amp;CC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">codecache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">	lua_State *L;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">codecache</span> <span class="title">CC</span>;</span></span><br></pre></td></tr></table></figure>
<p>一个 CC 静态变量，用来存储一些需要有多个 lua_State 公用的代码，当然也是加了锁的。</p>
<h1 id="配置加载"><a href="#配置加载" class="headerlink" title="配置加载"></a>配置加载</h1><p>一些库的载入，是打开一个虚拟机，然后通过Lua脚本的形式载入的。我们看主函数中的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_main.c </span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">L</span> = <span class="title">luaL_newstate</span>();</span></span><br><span class="line">        luaL_openlibs(L);       <span class="comment">// link lua lib</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> err =  luaL_loadbufferx(L, load_config, <span class="built_in">strlen</span>(load_config), <span class="string">"=[skynet config]"</span>, <span class="string">"t"</span>);</span><br><span class="line">        assert(err == LUA_OK);</span><br><span class="line">        lua_pushstring(L, config_file);</span><br><span class="line"></span><br><span class="line">        err = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">                lua_close(L);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要注意的是 <code>luaL_loadbufferx</code>会将字符串压入栈上，第三个参数一般用来做调试的时候打印信息用，第四个参数表示加载的是 二进制（<strong>b</strong>） 还是 文本 (<strong>t</strong>)，或者两者都有（<strong>bt</strong>）。</p>
<p>先是建立一个新的Lua State，然后把 下面的代码载入其内；接着，把配置文件压入栈，然后执行配置文件。这个是我们的 config.lua 配置文件的加载逻辑。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">static const <span class="built_in">char</span> * load_config = <span class="string">"\</span></span><br><span class="line"><span class="string">	local result = &#123;&#125;\n\</span></span><br><span class="line"><span class="string">	local function getenv(name) return assert(os.getenv(name), [[os.getenv() failed: ]] .. name) end\n\</span></span><br><span class="line"><span class="string">	local sep = package.config:sub(1,1)\n\</span></span><br><span class="line"><span class="string">	local current_path = [[.]]..sep\n\</span></span><br><span class="line"><span class="string">	local function include(filename)\n\</span></span><br><span class="line"><span class="string">		local last_path = current_path\n\</span></span><br><span class="line"><span class="string">		local path, name = filename:match([[(.*]]..sep..[[)(.*)$]])\n\</span></span><br><span class="line"><span class="string">		if path then\n\</span></span><br><span class="line"><span class="string">			if path:sub(1,1) == sep then	-- root\n\</span></span><br><span class="line"><span class="string">				current_path = path\n\</span></span><br><span class="line"><span class="string">			else\n\</span></span><br><span class="line"><span class="string">				current_path = current_path .. path\n\</span></span><br><span class="line"><span class="string">			end\n\</span></span><br><span class="line"><span class="string">		else\n\</span></span><br><span class="line"><span class="string">			name = filename\n\</span></span><br><span class="line"><span class="string">		end\n\</span></span><br><span class="line"><span class="string">		local f = assert(io.open(current_path .. name))\n\</span></span><br><span class="line"><span class="string">		local code = assert(f:read [[*a]])\n\</span></span><br><span class="line"><span class="string">		code = string.gsub(code, [[%$([%w_%d]+)]], getenv)\n\</span></span><br><span class="line"><span class="string">		f:close()\n\</span></span><br><span class="line"><span class="string">		assert(load(code,[[@]]..filename,[[t]],result))()\n\</span></span><br><span class="line"><span class="string">		current_path = last_path\n\</span></span><br><span class="line"><span class="string">	end\n\</span></span><br><span class="line"><span class="string">	setmetatable(result, &#123; __index = &#123; include = include &#125; &#125;)\n\</span></span><br><span class="line"><span class="string">	local config_name = ...\n\</span></span><br><span class="line"><span class="string">	include(config_name)\n\</span></span><br><span class="line"><span class="string">	setmetatable(result, nil)\n\</span></span><br><span class="line"><span class="string">	return result\n\</span></span><br><span class="line"><span class="string">"</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们的配置，这个时候是加载在一在个本地的 Lua State 里面的，需要在后面进行配置到全局。</p>
<p>这段代码的运行逻辑看起来有点累哈，实际就是设置了一个 <code>include</code> 函数，这个函数会把我们指定的配置文件以 result 为环境加 load 到栈上，但是并不执行，返回值就是我们建立的 result。这即是加载后的配置表。</p>
<h1 id="init-env-L"><a href="#init-env-L" class="headerlink" title="__init_env(L)"></a>__init_env(L)</h1><p>接下来的事情就比较奇妙了，在先前建立的Lua State内，已经保存了我们的配置信息，已经载入的库等。接下来就是把这个Lua State内的配置，都设置到全局变量内（事实上这些完全可以在C代码内完成的，为什么要用Lua呢）。</p>
<p>关于就在于我们的 skynet_setenv()  函数，会将我们 Lua 内配置的内容都设置到全局配置 <strong>E</strong> 内去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_init_env(lua_State *L) &#123;</span><br><span class="line">        lua_pushnil(L);  <span class="comment">/* first key */</span></span><br><span class="line">        <span class="keyword">while</span> (lua_next(L, <span class="number">-2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> keyt = lua_type(L, <span class="number">-2</span>);</span><br><span class="line">                <span class="keyword">if</span> (keyt != LUA_TSTRING) &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid config table\n"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> * key = lua_tostring(L,<span class="number">-2</span>);</span><br><span class="line">                <span class="keyword">if</span> (lua_type(L,<span class="number">-1</span>) == LUA_TBOOLEAN) &#123;</span><br><span class="line">                        <span class="keyword">int</span> b = lua_toboolean(L,<span class="number">-1</span>);</span><br><span class="line">                        skynet_setenv(key,b ? <span class="string">"true"</span> : <span class="string">"false"</span> );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> * value = lua_tostring(L,<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid config table key = %s\n"</span>, key);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        skynet_setenv(key,value);</span><br><span class="line">                &#125;</span><br><span class="line">                lua_pop(L,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua_pop(L,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码就是要理解 <code>lua_next(L,index)</code> 这个函数会从栈顶 弹出一个键，然后从 Index 的表处，压入两个值，key_value 对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">skynet_setenv(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">char</span> *value) &#123;</span><br><span class="line">	SPIN_LOCK(E)</span><br><span class="line">	</span><br><span class="line">	lua_State *L = E-&gt;L;</span><br><span class="line">	lua_getglobal(L, key);</span><br><span class="line">	assert(lua_isnil(L, <span class="number">-1</span>));</span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushstring(L,value);</span><br><span class="line">	lua_setglobal(L,key);</span><br><span class="line"></span><br><span class="line">	SPIN_UNLOCK(E)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们的配置文件信息，其实是放在全局环境的注册表内的。</p>
<h1 id="skynet-start-amp-config"><a href="#skynet-start-amp-config" class="headerlink" title="skynet_start(&amp;config)"></a>skynet_start(&amp;config)</h1><p>当我们把我们的 config.lua 内的内容加载到全局环境变量 E 中后，就会根据配置来构造我们的启动了。</p>
<p>类似 <code>optint(), optstring()</code> 这些函数其实都是使用 skynet_getenv 了从 E 内取内容。</p>
<p>在<code>skynet_start.c</code>中，我们可以看到代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">skynet_start(struct skynet_config * config) &#123;</span><br><span class="line">        <span class="comment">// register SIGHUP for log file reopen</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">        sa.sa_handler = &amp;handle_hup;</span><br><span class="line">        sa.sa_flags = SA_RESTART;</span><br><span class="line">        sigfillset(&amp;sa.sa_mask);</span><br><span class="line">        sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config-&gt;daemon) &#123;</span><br><span class="line">                <span class="keyword">if</span> (daemon_init(config-&gt;daemon)) &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        skynet_harbor_init(config-&gt;harbor);</span><br><span class="line">        skynet_handle_init(config-&gt;harbor);</span><br><span class="line">        skynet_mq_init();</span><br><span class="line">        skynet_module_init(config-&gt;module_path);</span><br><span class="line">        skynet_timer_init();</span><br><span class="line">        skynet_socket_init();</span><br><span class="line">        skynet_profile_enable(config-&gt;profile);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, config-&gt;logservice);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bootstrap(ctx, config-&gt;bootstrap);</span><br><span class="line"></span><br><span class="line">        start(config-&gt;thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// harbor_exit may call socket send, so it should exit before socket_free</span></span><br><span class="line">        skynet_harbor_exit();</span><br><span class="line">        skynet_socket_free();</span><br><span class="line">        <span class="keyword">if</span> (config-&gt;daemon) &#123;</span><br><span class="line">                daemon_exit(config-&gt;daemon);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要工作为：</p>
<ol>
<li>设置<code>SIGHUP</code>的信号处理程序。  </li>
<li>初始化句柄。<code>skynet_handle_init()</code>  </li>
<li>初始化消息队列。<code>skynet_mq_init()</code>  </li>
<li>模块加载。<code>skynet_module_init(config-&gt;module_path)</code> 我们指定的 C 编译的 so 库的目录下的内容。  </li>
<li>定时器设置。<code>skynet_timer_init()</code>  </li>
<li>套接字初始化。<code>skynet_socket_ini()</code>  </li>
<li>开启日志服务。  </li>
<li>启动<strong>bootstrap</strong>脚本。<code>bootstrap(ctr, confit-&gt;bootstrap)</code>  </li>
<li>启动线程。<code>start(config-&gt;thread)</code>。  </li>
</ol>
<h2 id="skynet-harbor-init-int-harbor"><a href="#skynet-harbor-init-int-harbor" class="headerlink" title="skynet_harbor_init(int harbor)"></a>skynet_harbor_init(int harbor)</h2><p>初始化节点化的ID。</p>
<blockquote>
<p>harbor 可以是 1-255 间的任意整数。一个 skynet 网络最多支持 255 个节点。每个节点有必须有一个唯一的编号。  </p>
<p>如果 harbor 为 0 ，skynet 工作在单节点模式下。此时 master 和 address 以及 standalone 都不必设置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_harbor_init(<span class="keyword">int</span> harbor) &#123;</span><br><span class="line">	HARBOR = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)harbor &lt;&lt; HANDLE_REMOTE_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="skynet-handle-init"><a href="#skynet-handle-init" class="headerlink" title="skynet_handle_init()"></a>skynet_handle_init()</h2><p>handle是什么我一直没有搞清楚，这是干什么的我也没有弄明白。只有参考了一下作者的博客 。</p>
<blockquote>
<p>把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。模块被称为服务（Service），服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。每个服务都是被一个个消息包驱动，当没有包到来的时候，它们就会处于挂起状态，对 CPU 资源零消耗。如果需要自主逻辑，则可以利用 Skynet 系统提供的 timeout 消息，定期触发。</p>
</blockquote>
<p>模块的实例是服务，实例的ID是 handle，每个服务都对应一个唯一的handle_id。</p>
<p>也就是对于很多类型的服务，都是首先加载进来，然后注册，为服务模块，可以启动多个实例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_handle.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rwlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> harbor;</span><br><span class="line">        <span class="keyword">uint32_t</span> handle_index;</span><br><span class="line">        <span class="keyword">int</span> slot_size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> ** <span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> name_cap;</span><br><span class="line">        <span class="keyword">int</span> name_count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">handle_name</span> *<span class="title">name</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> *<span class="title">H</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_handle_init(<span class="keyword">int</span> harbor) &#123;</span><br><span class="line">        assert(H==<span class="literal">NULL</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> * <span class="title">s</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">H</span>));</span></span><br><span class="line">        s-&gt;slot_size = DEFAULT_SLOT_SIZE;</span><br><span class="line">        s-&gt;slot = skynet_malloc(s-&gt;slot_size * <span class="keyword">sizeof</span>(struct skynet_context *));</span><br><span class="line">        <span class="built_in">memset</span>(s-&gt;slot, <span class="number">0</span>, s-&gt;slot_size * <span class="keyword">sizeof</span>(struct skynet_context *));</span><br><span class="line"></span><br><span class="line">        rwlock_init(&amp;s-&gt;lock);</span><br><span class="line">        <span class="comment">// reserve 0 for system</span></span><br><span class="line">        s-&gt;harbor = (<span class="keyword">uint32_t</span>) (harbor &amp; <span class="number">0xff</span>) &lt;&lt; HANDLE_REMOTE_SHIFT;</span><br><span class="line">        s-&gt;handle_index = <span class="number">1</span>;</span><br><span class="line">        s-&gt;name_cap = <span class="number">2</span>;</span><br><span class="line">        s-&gt;name_count = <span class="number">0</span>;</span><br><span class="line">        s-&gt;name = skynet_malloc(s-&gt;name_cap * <span class="keyword">sizeof</span>(struct handle_name));</span><br><span class="line"></span><br><span class="line">        H = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't need to free H</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置一个全局控制柄变量<strong>H</strong>，默认有四个位置可以存储四个 <code>skynet_context</code>服务结构的指针。</p>
<h2 id="skynet-module-init"><a href="#skynet-module-init" class="headerlink" title="skynet_module_init()"></a>skynet_module_init()</h2><p>服务表已经有了，现在我们需要把我们的模块加载进来。</p>
<p>这个函数定义在<code>skynet_module.c</code>中，其作用，就是载入配置文件中<code>lua_cpath= ...</code>指定的动态库路径。同时，将全局的模块变量<strong>M</strong>指像这个路径。</p>
<p>每个模块的结构定义在<code>skynet_module.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_module.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">        <span class="keyword">void</span> * <span class="keyword">module</span>;</span><br><span class="line">        skynet_dl_create create;</span><br><span class="line">        skynet_dl_init init;</span><br><span class="line">        skynet_dl_release release;</span><br><span class="line">        skynet_dl_signal signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，后面四个函数是由动态库提供的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_modlue.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">modules</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * path;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> <span class="title">m</span>[<span class="title">MAX_MODULE_TYPE</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">modules</span> * <span class="title">M</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_module_init(<span class="keyword">const</span> <span class="keyword">char</span> *path) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">modules</span> *<span class="title">m</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">m</span>));</span></span><br><span class="line">        m-&gt;count = <span class="number">0</span>;</span><br><span class="line">        m-&gt;path = skynet_strdup(path);</span><br><span class="line"></span><br><span class="line">        SPIN_INIT(m)</span><br><span class="line"></span><br><span class="line">        M = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="skynet-mq-init"><a href="#skynet-mq-init" class="headerlink" title="skynet_mq_init()"></a>skynet_mq_init()</h2><p>在文件<code>skynet_mq.c</code>中，定义了这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_mq_init() &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> *<span class="title">q</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">q</span>));</span></span><br><span class="line">        <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(*q));</span><br><span class="line">        SPIN_INIT(q);</span><br><span class="line">        Q=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是建立了一个全局的消息队列 <strong>Q</strong>，此队列保存了每个服务的消息队列。</p>
<h2 id="skynet-timer-init"><a href="#skynet-timer-init" class="headerlink" title="skynet_timer_init();"></a>skynet_timer_init();</h2><p>定时器初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_timer_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">	TI = timer_create_timer();</span><br><span class="line">	<span class="keyword">uint32_t</span> current = <span class="number">0</span>;</span><br><span class="line">	systime(&amp;TI-&gt;starttime, &amp;current);</span><br><span class="line">	TI-&gt;current = current;</span><br><span class="line">	TI-&gt;current_point = gettime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="skynet-socket-init"><a href="#skynet-socket-init" class="headerlink" title="skynet_socket_init();"></a>skynet_socket_init();</h2><p>套接字服务器初始化，这个的作用是当需要启动网络服务的时候，由这个服务器来启动对应的监听。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_socket_init() &#123;</span><br><span class="line">	SOCKET_SERVER = socket_server_create(skynet_now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> * </span></span><br><span class="line"><span class="class"><span class="title">socket_server_create</span>(<span class="title">uint64_t</span> <span class="title">time</span>) &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	poll_fd efd = sp_create();</span><br><span class="line">	<span class="keyword">if</span> (sp_invalid(efd)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: create event pool failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd)) &#123;</span><br><span class="line">		sp_release(efd);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: create socket pair failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sp_add(efd, fd[<span class="number">0</span>], <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">// add recvctrl_fd to event poll</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: can't add server fd to event pool.\n"</span>);</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		sp_release(efd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> = <span class="title">MALLOC</span>(<span class="title">sizeof</span>(*<span class="title">ss</span>));</span></span><br><span class="line">	ss-&gt;time = time;</span><br><span class="line">	ss-&gt;event_fd = efd;</span><br><span class="line">	ss-&gt;recvctrl_fd = fd[<span class="number">0</span>];</span><br><span class="line">	ss-&gt;sendctrl_fd = fd[<span class="number">1</span>];</span><br><span class="line">	ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAX_SOCKET;i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">slot</span>[<span class="title">i</span>];</span></span><br><span class="line">		s-&gt;type = SOCKET_TYPE_INVALID;</span><br><span class="line">		clear_wb_list(&amp;s-&gt;high);</span><br><span class="line">		clear_wb_list(&amp;s-&gt;low);</span><br><span class="line">		spinlock_init(&amp;s-&gt;dw_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	ss-&gt;alloc_id = <span class="number">0</span>;</span><br><span class="line">	ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">	ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ss-&gt;soi, <span class="number">0</span>, <span class="keyword">sizeof</span>(ss-&gt;soi));</span><br><span class="line">	FD_ZERO(&amp;ss-&gt;rfds);</span><br><span class="line">	assert(ss-&gt;recvctrl_fd &lt; FD_SETSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="skynet-context-结构"><a href="#skynet-context-结构" class="headerlink" title="skynet_context 结构"></a>skynet_context 结构</h1><p>在skynet.c中，结构<code>skynet_context</code>为每个服务保存了一个内部结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> * instance;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span>;</span></span><br><span class="line">        <span class="keyword">void</span> * cb_ud;</span><br><span class="line">        skynet_cb cb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">        FILE * logfile;</span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_cost;      <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_start;     <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> handle;</span><br><span class="line">        <span class="keyword">int</span> session_id;</span><br><span class="line">        <span class="keyword">int</span> ref;</span><br><span class="line">        <span class="keyword">int</span> message_count;</span><br><span class="line">        <span class="keyword">bool</span> init;</span><br><span class="line">        <span class="keyword">bool</span> endless;</span><br><span class="line">        <span class="keyword">bool</span> profile;</span><br><span class="line"></span><br><span class="line">        CHECKCALLING_DECL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构定义了每个服务的<em>实例地址，模块地址，消息队列，日志文件，会话ID，引用数，消息数</em>等字段。</p>
<h1 id="服务-H-表"><a href="#服务-H-表" class="headerlink" title="服务 H 表"></a>服务 H 表</h1><p>我们第一个启动的服务就是 logger 服务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, config-&gt;logservice);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet_handle_namehandle(skynet_context_handle(ctx), <span class="string">"logger"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="skynet-create-new"><a href="#skynet-create-new" class="headerlink" title="skynet_create_new()"></a>skynet_create_new()</h2><p><code>skynet.c</code>中，<code>skynet_create_new()</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_context_new</span>(<span class="title">const</span> <span class="title">char</span> * <span class="title">name</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">param</span>) &#123;</span></span><br><span class="line">		  <span class="comment">// 查询模块是否加载</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span> = <span class="title">skynet_module_query</span>(<span class="title">name</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		  <span class="comment">// 用模块建立一个实例 返回的是实例地址</span></span><br><span class="line">        <span class="keyword">void</span> *inst = skynet_module_instance_create(mod);</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 建立一个服务结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">ctx</span>));</span></span><br><span class="line">        CHECKCALLING_INIT(ctx)</span><br><span class="line"></span><br><span class="line">        ctx-&gt;mod = mod;</span><br><span class="line">        ctx-&gt;instance = inst;</span><br><span class="line">        ctx-&gt;ref = <span class="number">2</span>;</span><br><span class="line">        ctx-&gt;cb = <span class="literal">NULL</span>;</span><br><span class="line">        ctx-&gt;cb_ud = <span class="literal">NULL</span>;</span><br><span class="line">        ctx-&gt;session_id = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;logfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ctx-&gt;init = <span class="literal">false</span>;</span><br><span class="line">        ctx-&gt;endless = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ctx-&gt;cpu_cost = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;cpu_start = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;message_count = <span class="number">0</span>;</span><br><span class="line">        ctx-&gt;profile = G_NODE.profile;</span><br><span class="line">        <span class="comment">// Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle</span></span><br><span class="line">        ctx-&gt;handle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注册一个handle</span></span><br><span class="line">        ctx-&gt;handle = skynet_handle_register(ctx);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">queue</span> = <span class="title">ctx</span>-&gt;<span class="title">queue</span> = <span class="title">skynet_mq_create</span>(<span class="title">ctx</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">        <span class="comment">// init function maybe use ctx-&gt;handle, so it must init at last</span></span><br><span class="line">        context_inc();</span><br><span class="line"></span><br><span class="line">        CHECKCALLING_BEGIN(ctx)</span><br><span class="line">        <span class="comment">// 初始化服务</span></span><br><span class="line">        <span class="keyword">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);</span><br><span class="line">        CHECKCALLING_END(ctx)</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ret</span> = <span class="title">skynet_context_release</span>(<span class="title">ctx</span>);</span></span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        ctx-&gt;init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                skynet_globalmq_push(<span class="built_in">queue</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        skynet_error(ret, <span class="string">"LAUNCH %s %s"</span>, name, param ? param : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"FAILED launch %s"</span>, name);</span><br><span class="line">                <span class="keyword">uint32_t</span> handle = ctx-&gt;handle;</span><br><span class="line">                skynet_context_release(ctx);</span><br><span class="line">                skynet_handle_retire(handle);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> = &#123;</span> handle &#125;;</span><br><span class="line">                skynet_mq_release(<span class="built_in">queue</span>, drop_message, &amp;d);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数，</p>
<ol>
<li>首先会查看一下全局服务变量<strong>M</strong>中是否存在对应模块，如果存在，就初始化一个实例；  </li>
<li>初始化 服务的 skynet_context 结构，包括会分配一个唯一的 handle。<code>skynet_handle_register(ctx)</code>  ，然后将服务注册到  <strong>H</strong> 中。</li>
<li>建立服务的消息队列。<code>skynet_mq_create</code>  </li>
<li>初始化服务。<code>skynet_module_instance_init(mod, inst, ctx, param);</code>  其结果是调用模块自身的 <code>init</code>函数。  </li>
<li>然后把消息队列放在全局消息队列中。  </li>
</ol>
<h2 id="skynet-module-instance-create"><a href="#skynet-module-instance-create" class="headerlink" title="skynet_module_instance_create"></a>skynet_module_instance_create</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * </span><br><span class="line">skynet_module_instance_create(struct skynet_module *m) &#123;</span><br><span class="line">	<span class="keyword">if</span> (m-&gt;create) &#123;</span><br><span class="line">		<span class="keyword">return</span> m-&gt;create();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>)(~<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块实例的建立，实际上就是C 服务中的 create 函数的调用，其结果，一般都是返回一个服务需要的数据结构。如 logger, snlua, gate 服务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate</span> *</span></span><br><span class="line"><span class="class"><span class="title">gate_create</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gate</span> * <span class="title">g</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">g</span>));</span></span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(*g));</span><br><span class="line">	g-&gt;listen_id = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logger</span> *</span></span><br><span class="line"><span class="class"><span class="title">logger_create</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">logger</span> * <span class="title">inst</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">inst</span>));</span></span><br><span class="line">	inst-&gt;handle = <span class="literal">NULL</span>;</span><br><span class="line">	inst-&gt;close = <span class="number">0</span>;</span><br><span class="line">	inst-&gt;filename = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *</span></span><br><span class="line"><span class="class"><span class="title">snlua_create</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> * <span class="title">l</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">l</span>));</span></span><br><span class="line">	<span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(*l));</span><br><span class="line">	l-&gt;mem_report = MEMORY_WARNING_REPORT;</span><br><span class="line">	l-&gt;mem_limit = <span class="number">0</span>;</span><br><span class="line">	l-&gt;L = lua_newstate(lalloc, l);</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="skynet-handle-register"><a href="#skynet-handle-register" class="headerlink" title="skynet_handle_register"></a>skynet_handle_register</h2><p>我们通过模块建立了一个服务后，事实上对于 skynet 来说，这个服务，就是一个 skynet_context ，其对具体的模块实际上是不关心的。</p>
<p>在  <strong>H</strong> 表中 slot 是服务的插槽，每个插槽都指向一个 skynet_context 结构。</p>
<p>下面这个逻辑会首先看一下插槽够用不，不够用就增大插槽，然后再注册后返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span></span><br><span class="line">skynet_handle_register(struct skynet_context *ctx) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> *<span class="title">s</span> = <span class="title">H</span>;</span></span><br><span class="line"></span><br><span class="line">	rwlock_wlock(&amp;s-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">uint32_t</span> handle = s-&gt;handle_index;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s-&gt;slot_size;i++,handle++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (handle &gt; HANDLE_MASK) &#123;</span><br><span class="line">				<span class="comment">// 0 is reserved</span></span><br><span class="line">				handle = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> hash = handle &amp; (s-&gt;slot_size<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;slot[hash] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				s-&gt;slot[hash] = ctx;</span><br><span class="line">				s-&gt;handle_index = handle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				rwlock_wunlock(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">				handle |= s-&gt;harbor;</span><br><span class="line">				<span class="keyword">return</span> handle;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		assert((s-&gt;slot_size*<span class="number">2</span> - <span class="number">1</span>) &lt;= HANDLE_MASK);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> ** <span class="title">new_slot</span> = <span class="title">skynet_malloc</span>(<span class="title">s</span>-&gt;<span class="title">slot_size</span> * 2 * <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">skynet_context</span> *));</span></span><br><span class="line">		<span class="built_in">memset</span>(new_slot, <span class="number">0</span>, s-&gt;slot_size * <span class="number">2</span> * <span class="keyword">sizeof</span>(struct skynet_context *));</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s-&gt;slot_size;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> hash = skynet_context_handle(s-&gt;slot[i]) &amp; (s-&gt;slot_size * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">			assert(new_slot[hash] == <span class="literal">NULL</span>);</span><br><span class="line">			new_slot[hash] = s-&gt;slot[i];</span><br><span class="line">		&#125;</span><br><span class="line">		skynet_free(s-&gt;slot);</span><br><span class="line">		s-&gt;slot = new_slot;</span><br><span class="line">		s-&gt;slot_size *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块（服务）的初始化"><a href="#模块（服务）的初始化" class="headerlink" title="模块（服务）的初始化"></a>模块（服务）的初始化</h2><p>每个模块的实例建立了以后，就会调用模块自己的初始化函数进行初始化设置。对于我们所有的Lua服务来说，其都是 <code>snlua</code>模块的一个实例。对于 <code>skyent_context_new()</code>中调用的函数<code>skynet_module_instance_init()</code>，我们看一下它的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_module.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_module_instance_init(struct skynet_module *m, <span class="keyword">void</span> * inst, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * parm) &#123;</span><br><span class="line">        <span class="keyword">return</span> m-&gt;init(inst, ctx, parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个其实就是 <code>c server</code>模块中的 <code>init</code>函数。</p>
<p>现在框架提供的服务有 :logger, gate,snlua, harbor,默认4个，所以 H 表流了四个 slot 在。</p>
<h2 id="snlua"><a href="#snlua" class="headerlink" title="snlua"></a>snlua</h2><p>snlua 实际上已经建立了一个 lua_State。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service_src/service_snlua.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> &#123;</span></span><br><span class="line">        lua_State * L;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> mem;</span><br><span class="line">        <span class="keyword">size_t</span> mem_report;</span><br><span class="line">        <span class="keyword">size_t</span> mem_limit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">snlua_init(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="built_in">strlen</span>(args);</span><br><span class="line">        <span class="keyword">char</span> * tmp = skynet_malloc(sz);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, args, sz);</span><br><span class="line">        <span class="comment">// 设置 ctx 回调函数为 launch_cb</span></span><br><span class="line">        skynet_callback(ctx, l , launch_cb);</span><br><span class="line">        <span class="comment">// 这个就是返回一个自己的服务名字。如果我们传入 最后一个参数不是NULL，不是空字符，也不是以 . 开头就会出错。因为不以 . 开头的是系统服务。这个命令，是向 **H** 注册一个名字的意思。默认我 NULL，就是返回一个 : handleId 这样的值。 [:00000009]</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * self = skynet_command(ctx, <span class="string">"REG"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">uint32_t</span> handle_id = strtoul(self+<span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// it must be first message</span></span><br><span class="line">        <span class="comment">// 模块向服务发送消息。参数：ctx, 源（0代表自己），目标handle，类型，seesionId,数据，大小。第一条消息会被发送给设置的回调。这个消息，会发送到 handle_Id 标识的 ctx 消息队列中。由消息调度线程查询消息后分发。</span></span><br><span class="line">        skynet_send(ctx, <span class="number">0</span>, handle_id, PTYPE_TAG_DONTCOPY,<span class="number">0</span>, tmp, sz);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">launch_cb(struct skynet_context * context, <span class="keyword">void</span> *ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source , <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        assert(type == <span class="number">0</span> &amp;&amp; session == <span class="number">0</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *<span class="title">l</span> = <span class="title">ud</span>;</span></span><br><span class="line">        skynet_callback(context, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> err = init_cb(l, context, msg, sz);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                skynet_command(context, <span class="string">"EXIT"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">init_cb(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        lua_State *L = l-&gt;L;</span><br><span class="line">        l-&gt;ctx = ctx;</span><br><span class="line">        lua_gc(L, LUA_GCSTOP, <span class="number">0</span>);</span><br><span class="line">        lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">        lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"LUA_NOENV"</span>);</span><br><span class="line">        luaL_openlibs(L);</span><br><span class="line">        lua_pushlightuserdata(L, ctx);</span><br><span class="line">        lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>);</span><br><span class="line">        luaL_requiref(L, <span class="string">"skynet.codecache"</span>, codecache , <span class="number">0</span>);</span><br><span class="line">        lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path = optstring(ctx, <span class="string">"lua_path"</span>,<span class="string">"./lualib/?.lua;./lualib/?/init.lua"</span>);</span><br><span class="line">        lua_pushstring(L, path);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_PATH"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *cpath = optstring(ctx, <span class="string">"lua_cpath"</span>,<span class="string">"./luaclib/?.so"</span>);</span><br><span class="line">        lua_pushstring(L, cpath);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_CPATH"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *service = optstring(ctx, <span class="string">"luaservice"</span>, <span class="string">"./service/?.lua"</span>);</span><br><span class="line">        lua_pushstring(L, service);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_SERVICE"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *preload = skynet_command(ctx, <span class="string">"GETENV"</span>, <span class="string">"preload"</span>);</span><br><span class="line">        lua_pushstring(L, preload);</span><br><span class="line">        lua_setglobal(L, <span class="string">"LUA_PRELOAD"</span>);</span><br><span class="line"></span><br><span class="line">        lua_pushcfunction(L, traceback);</span><br><span class="line">        assert(lua_gettop(L) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = luaL_loadfile(L,loader);</span><br><span class="line">        <span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">                report_launcher_error(ctx);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                lua_pushlstring(L, args, sz);</span><br><span class="line">        r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"lua loader error : %s"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">                report_launcher_error(ctx);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lua_settop(L,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">                <span class="keyword">size_t</span> limit = lua_tointeger(L, <span class="number">-1</span>);</span><br><span class="line">                l-&gt;mem_limit = limit;</span><br><span class="line">                skynet_error(ctx, <span class="string">"Set memory limit to %.2f M"</span>, (<span class="keyword">float</span>)limit / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">                lua_pushnil(L);</span><br><span class="line">                lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua_pop(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        lua_gc(L, LUA_GCRESTART, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，每个snlua结构都有自己的 Lua State，所以所有的代码都是snlua自己的内部执行的，不会影响其他的Lua State。</p>
<p>这个函数都干了什么：</p>
<ol>
<li>设置对应服务 ctx 的回调函数为 <code>launch_cb</code>；  </li>
<li>注册自身；  </li>
<li>向 ctx 发送消息（入列）。</li>
<li>收到消息后会回调 <code>launch_cb</code>，而这个函数会又取消调回调函数。转而调用 <code>init_cb</code>函数。进行初始化 snlua中的 Lua State;  </li>
<li>这个函数才调用<code>loader.lua</code>来真正的加载服务脚本等操作。</li>
</ol>
<h1 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap()"></a>bootstrap()</h1><p>之前我们只启动了一个 logger 服务。现在我们要开始启动新的服务了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line">      <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, config-&gt;logservice);</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，会以<em>logger, NULL</em>为参数调用 <code>skynet_context_new(“logger”, NULL)</code>函数，建立一个关于 <em>logger</em>服务的<code>skynet_context</code>的结构，其实就是启动了 <em>logger</em>服务。</p>
<p>然后调用<code>bootstrap(ctx, config-&gt;bootstrap)</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//skynet_start.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bootstrap(struct skynet_context * logger, <span class="keyword">const</span> <span class="keyword">char</span> * cmdline) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="built_in">strlen</span>(cmdline);</span><br><span class="line">        <span class="keyword">char</span> name[sz+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">char</span> args[sz+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sscanf</span>(cmdline, <span class="string">"%s %s"</span>, name, args);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">name</span>, <span class="title">args</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                skynet_error(<span class="literal">NULL</span>, <span class="string">"Bootstrap error : %s\n"</span>, cmdline);</span><br><span class="line">                skynet_context_dispatchall(logger);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>config-&gt;bootstrap</code>是<code>snlua bootstrap</code>。事实上最终执行的函数是<code>skynet_context_new(&quot;snlua&quot;, &quot;bootstrap&quot;)</code>，如此又建立一个服务结构，并用<em>bootstrap</em>参数进行初始化。如果服务建立失败，就会将所有的信息发送到 <em>logger</em>，并处理全部的 <em>logger</em>服务的消息。</p>
<p><strong>snlua</strong>作为沙盒服务，会再入<code>lua</code>脚本并进行执行。</p>
<p>实际上 snlua 会利用  lualib/loader.lua 来加载我们的 bootstrap 脚本。然后进行启动。</p>
<blockquote>
<p>bootstrap 这个配置项关系着 skynet 运行的第二个服务。通常通过这个服务把整个系统启动起来。默认的 bootstrap 配置项为 “snlua bootstrap” ，这意味着，skynet 会启动 snlua 这个服务，并将 bootstrap 作为参数传给它。snlua 是 lua 沙盒服务，bootstrap 会根据配置的 luaservice 匹配到最终的 lua 脚本。如果按默认配置，这个脚本应该是 service/bootstrap.lua 。</p>
<p>如无必要，你不需要更改 bootstrap 配置项，让默认的 bootstrap 脚本工作。</p>
<p>最后，它从 config 中读取 start 这个配置项，作为用户定义的服务启动入口脚本运行。成功后，把自己退出。</p>
<p>这个 start 配置项，才是用户定义的启动脚本，默认值为 “main” 。如果你只是试玩一下 skynet ，可能有多份不同的启动脚本，那么建议你多写几份 config 文件，在里面配置不同的 start 项。examples 目录下有很多这样的例子。</p>
</blockquote>
<p>最终，bootstrap 会将我们配置在配置文件中的 start 脚本加载进来，启动。其他服务。</p>
<h1 id="start-thread-config-gt-thread"><a href="#start-thread-config-gt-thread" class="headerlink" title="start_thread(config-&gt;thread)"></a>start_thread(config-&gt;thread)</h1><p>此函数用来启动我们设置的线程数。一共启动了<em>config-&gt;thread + 3</em>个线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> ** <span class="title">m</span>;</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">        <span class="keyword">int</span> sleep;</span><br><span class="line">        <span class="keyword">int</span> quit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start(<span class="keyword">int</span> thread) &#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> pid[thread+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">m</span>));</span></span><br><span class="line">        <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line">        m-&gt;count = thread;</span><br><span class="line">        m-&gt;sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m-&gt;m = skynet_malloc(thread * <span class="keyword">sizeof</span>(struct skynet_monitor *));</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">                m-&gt;m[i] = skynet_monitor_new();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;m-&gt;mutex, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Init mutex error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pthread_cond_init(&amp;m-&gt;cond, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Init cond error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> weight[] = &#123;</span><br><span class="line">                <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;;</span><br><span class="line">                 <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">                wp[i].m = m;</span><br><span class="line">                wp[i].id = i;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;</span><br><span class="line">                        wp[i].weight= weight[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        wp[i].weight = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread+<span class="number">3</span>;i++) &#123;</span><br><span class="line">                pthread_join(pid[i], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free_monitor(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，函数先建立了一个监控器<strong>m</strong>，并初始化了<em>线程数，睡眠数分别为(8, 0)</em>，然后，再为每个线程建立了skynet自己的监控数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_monitor.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> version;</span><br><span class="line">        <span class="keyword">int</span> check_version;</span><br><span class="line">        <span class="keyword">uint32_t</span> source;</span><br><span class="line">        <span class="keyword">uint32_t</span> destination;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来我们可以看到，是通过 互斥量 和条件变量来进行线程的抢占使用的。接着建立了三个线程和<em>thread(默认是8)</em>个工作线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span>;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">        create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);</span><br><span class="line">        create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> weight[] = &#123;</span><br><span class="line">                <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">                wp[i].m = m;</span><br><span class="line">                wp[i].id = i;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;</span><br><span class="line">                        wp[i].weight= weight[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        wp[i].weight = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>建立了一个工作线程参数表<code>struct worker_parm wp[thread];</code>，并设置每个线程的权重，然后启动线程，线程ID保存在<em>pid</em>数组内。</p>
<h2 id="thread-worker"><a href="#thread-worker" class="headerlink" title="thread_worker"></a>thread_worker</h2><p>工作线程循环从队列内取出消息进行处理，如果没有消息，就从全局消息队列去取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">thread_worker(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> *<span class="title">wp</span> = <span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">int</span> id = wp-&gt;id;</span><br><span class="line">        <span class="keyword">int</span> weight = wp-&gt;weight;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> = <span class="title">wp</span>-&gt;<span class="title">m</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span> = <span class="title">m</span>-&gt;<span class="title">m</span>[<span class="title">id</span>];</span></span><br><span class="line">        skynet_initthread(THREAD_WORKER);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">q</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (!m-&gt;quit) &#123;</span><br><span class="line">                q = skynet_context_message_dispatch(sm, q, weight);</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pthread_mutex_lock(&amp;m-&gt;mutex) == <span class="number">0</span>) &#123;</span><br><span class="line">                                ++ m-&gt;sleep;</span><br><span class="line">                                <span class="comment">// "spurious wakeup" is harmless,</span></span><br><span class="line">                                <span class="comment">// because skynet_context_message_dispatch() can be call at any time.</span></span><br><span class="line">                                <span class="keyword">if</span> (!m-&gt;quit)</span><br><span class="line">                                        pthread_cond_wait(&amp;m-&gt;cond, &amp;m-&gt;mutex);</span><br><span class="line">                                -- m-&gt;sleep;</span><br><span class="line">                                <span class="keyword">if</span> (pthread_mutex_unlock(&amp;m-&gt;mutex)) &#123;</span><br><span class="line">                                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unlock mutex error"</span>);</span><br><span class="line">                                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>skynet_initthread(THREAD_WORKER);</code>用于在线程特定数据内保存自己的<em>handlekey</em>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_initthread(<span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> v = (<span class="keyword">uint32_t</span>)(-m);</span><br><span class="line">        pthread_setspecific(G_NODE.handle_key, (<span class="keyword">void</span> *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个工作线程，都是调用<code>skynet_context_message_dispatch(sm, q, wight)</code>来从消息队列获取信息，如果获取不到，就进入睡眠状态。直到条件变量条件满足，才进行唤醒。</p>
<p>当线程的消息队列不存在的时候，就会从全局消息队列获取一个消息队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_mq.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> handle;</span><br><span class="line">        <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">int</span> head;</span><br><span class="line">        <span class="keyword">int</span> tail;</span><br><span class="line">        <span class="keyword">int</span> release;</span><br><span class="line">        <span class="keyword">int</span> in_global;</span><br><span class="line">        <span class="keyword">int</span> overload;</span><br><span class="line">        <span class="keyword">int</span> overload_threshold;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> *<span class="title">queue</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">head</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">tail</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_globalmq_pop</span>() &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> *<span class="title">q</span> = <span class="title">Q</span>;</span></span><br><span class="line"></span><br><span class="line">        SPIN_LOCK(q)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">mq</span> = <span class="title">q</span>-&gt;<span class="title">head</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(mq) &#123;</span><br><span class="line">                q-&gt;head = mq-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(q-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        assert(mq == q-&gt;tail);</span><br><span class="line">                        q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mq-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SPIN_UNLOCK(q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_context_message_dispatch</span>(<span class="title">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span>, <span class="title">struct</span> <span class="title">message_queue</span> *<span class="title">q</span>, <span class="title">int</span> <span class="title">weight</span>) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q = skynet_globalmq_pop();</span><br><span class="line">                <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> handle = skynet_mq_handle(q);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_handle_grab</span>(<span class="title">handle</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> = &#123;</span> handle &#125;;</span><br><span class="line">                skynet_mq_release(q, drop_message, &amp;d);</span><br><span class="line">                <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i,n=<span class="number">1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;</span><br><span class="line">                        skynet_context_release(ctx);</span><br><span class="line">                        <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        n = skynet_mq_length(q);</span><br><span class="line">                        n &gt;&gt;= weight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> overload = skynet_mq_overload(q);</span><br><span class="line">                <span class="keyword">if</span> (overload) &#123;</span><br><span class="line">                        skynet_error(ctx, <span class="string">"May overload, message queue length = %d"</span>, overload);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                skynet_monitor_trigger(sm, msg.source , handle);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        skynet_free(msg.data);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dispatch_message(ctx, &amp;msg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(q == ctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">nq</span> = <span class="title">skynet_globalmq_pop</span>();</span></span><br><span class="line">        <span class="keyword">if</span> (nq) &#123;</span><br><span class="line">                <span class="comment">// If global mq is not empty , push q back, and return next queue (nq)</span></span><br><span class="line">                <span class="comment">// Else (global mq is empty or block, don't push q back, and return q again (for next dispatch)</span></span><br><span class="line">                skynet_globalmq_push(q);</span><br><span class="line">                q = nq;</span><br><span class="line">        &#125;</span><br><span class="line">        skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理消息最主要的就是这个函数了：</p>
<ol>
<li>如果传入的消息队列<em>q</em>为空，就会重新从全局队列弹出一个。  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = skynet_globalmq_pop();</span><br></pre></td></tr></table></figure>
<ol>
<li>获得弹出消息队列的 handle，根据handle来找到对应的 服务 ctx； </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> handle = skynet_mq_handle(q);</span><br></pre></td></tr></table></figure>
<ol>
<li>从队列取消息。  如果从特定的消息队列弹出消息失败，就会从全局队列返回一个新的消息队列。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,n=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;</span><br><span class="line">                skynet_context_release(ctx);</span><br><span class="line">                <span class="comment">// 弹出消息失败，返回一个新的消息队列</span></span><br><span class="line">                <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">                <span class="comment">// 根据线程权重设置来获取消息数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                n = skynet_mq_length(q);</span><br><span class="line">                n &gt;&gt;= weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> overload = skynet_mq_overload(q);</span><br><span class="line">        <span class="keyword">if</span> (overload) &#123;</span><br><span class="line">                skynet_error(ctx, <span class="string">"May overload, message queue length = %d"</span>, overload);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skynet_monitor_trigger(sm, msg.source , handle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                skynet_free(msg.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_message(ctx, &amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用<code>dispatch_message(ctx, &amp;msg)</code>；  此函数会调用注册的回调函数处理消息。   </li>
<li>消息处理完毕后，检查全局消息队列是否为空，如果为空的话，就继续返回当前队列；如果全局消息队列不为空， 就返回一个新的消息队列。</li>
</ol>
<p><strong>也就是说，默认情况下，每个线程每次只会处理全局消息队列中，某一消息队列的一条消息。</strong></p>
<h2 id="thread-socket"><a href="#thread-socket" class="headerlink" title="thread_socket"></a>thread_socket</h2><p>这个线程，会轮询所有的的套接字，具体的工作在<code>skynet_socket_poll()</code>内完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">thread_socket(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> * <span class="title">m</span> = <span class="title">p</span>;</span></span><br><span class="line">        skynet_initthread(THREAD_SOCKET);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = skynet_socket_poll();</span><br><span class="line">                <span class="keyword">if</span> (r==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                        CHECK_ABORT</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup(m,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数会获取获取消息类型和消息内容，并进行消息转发。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_socket.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_socket_poll() &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> = <span class="title">SOCKET_SERVER</span>;</span></span><br><span class="line">        assert(ss);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_message</span> <span class="title">result</span>;</span></span><br><span class="line">        <span class="keyword">int</span> more = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> type = socket_server_poll(ss, &amp;result, &amp;more);</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_EXIT:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_DATA:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_DATA, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_CLOSE:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_CLOSE, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_OPEN:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_CONNECT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_ERR:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_ERROR, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_ACCEPT:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_ACCEPT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_UDP:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_UDP, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_WARNING:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_WARNING, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                skynet_error(<span class="literal">NULL</span>, <span class="string">"Unknown socket message type %d."</span>,type);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的主要工作还是由 <code>socket_service_poll(ss, &amp;result, &amp;more)</code>来完成的。该函数会返回套接字消息的类型，消息本身及是否有更多消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket_server.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">socket_server_poll(struct socket_server *ss, struct socket_message * result, <span class="keyword">int</span> * more) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;checkctrl) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (has_cmd(ss)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type = ctrl_cmd(ss, result);</span><br><span class="line">                                <span class="keyword">if</span> (type != <span class="number">-1</span>) &#123;</span><br><span class="line">                                        clear_closed_event(ss, result, type);</span><br><span class="line">                                        <span class="keyword">return</span> type;</span><br><span class="line">                                &#125; <span class="keyword">else</span></span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ss-&gt;checkctrl = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;event_index == ss-&gt;event_n) &#123;</span><br><span class="line">                        ss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);</span><br><span class="line">                        ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                                *more = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ss-&gt;event_n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">ev</span>[<span class="title">ss</span>-&gt;<span class="title">event_index</span>++];</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = <span class="title">e</span>-&gt;<span class="title">s</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="comment">// dispatch pipe message at beginning</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">                socket_lock_init(s, &amp;l);</span><br><span class="line">                <span class="keyword">switch</span> (s-&gt;type) &#123;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_CONNECTING:</span><br><span class="line">                        <span class="keyword">return</span> report_connect(ss, s, &amp;l, result);</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_LISTEN: &#123;</span><br><span class="line">                        <span class="keyword">int</span> ok = report_accept(ss, s, result);</span><br><span class="line">                        <span class="keyword">if</span> (ok &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ACCEPT;</span><br><span class="line">                        &#125; <span class="keyword">if</span> (ok &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// when ok == 0, retry</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_INVALID:</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: invalid socket\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;read) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type;</span><br><span class="line">                                <span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">                                                                        type = forward_message_tcp(ss, s, &amp;l, result);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        type = forward_message_udp(ss, s, &amp;l, result);</span><br><span class="line">                                        <span class="keyword">if</span> (type == SOCKET_UDP) &#123;</span><br><span class="line">                                                <span class="comment">// try read again</span></span><br><span class="line">                                                --ss-&gt;event_index;</span><br><span class="line">                                                <span class="keyword">return</span> SOCKET_UDP;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (e-&gt;write &amp;&amp; type != SOCKET_CLOSE &amp;&amp; type != SOCKET_ERR) &#123;</span><br><span class="line">                                        <span class="comment">// Try to dispatch write message next step if write flag set.</span></span><br><span class="line">                                        e-&gt;read = <span class="literal">false</span>;</span><br><span class="line">                                        --ss-&gt;event_index;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;write) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type = send_buffer(ss, s, &amp;l, result);</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;error) &#123;</span><br><span class="line">                                <span class="comment">// close when error</span></span><br><span class="line">                                <span class="keyword">int</span> error;</span><br><span class="line">                                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">                                <span class="keyword">int</span> code = getsockopt(s-&gt;fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span> * err = <span class="literal">NULL</span>;</span><br><span class="line">                                <span class="keyword">if</span> (code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(errno);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(error);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        err = <span class="string">"Unknown error"</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                                                force_close(ss, s, &amp;l, result);</span><br><span class="line">                                result-&gt;data = (<span class="keyword">char</span> *)err;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forward_message</code>会被对应类型的消息，压入到对应服务结构中的消息队列去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_socket.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forward_message(<span class="keyword">int</span> type, <span class="keyword">bool</span> padding, struct socket_message * result) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_socket_message</span> *<span class="title">sm</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(*sm);</span><br><span class="line">        <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result-&gt;data) &#123;</span><br><span class="line">                        <span class="keyword">size_t</span> msg_sz = <span class="built_in">strlen</span>(result-&gt;data);</span><br><span class="line">                        <span class="keyword">if</span> (msg_sz &gt; <span class="number">128</span>) &#123;</span><br><span class="line">                                msg_sz = <span class="number">128</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sz += msg_sz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result-&gt;data = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sm = (struct skynet_socket_message *)skynet_malloc(sz);</span><br><span class="line">        sm-&gt;type = type;</span><br><span class="line">        sm-&gt;id = result-&gt;id;</span><br><span class="line">        sm-&gt;ud = result-&gt;ud;</span><br><span class="line">        <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">                        sm-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(sm+<span class="number">1</span>, result-&gt;data, sz - <span class="keyword">sizeof</span>(*sm));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sm-&gt;buffer = result-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">message</span>;</span></span><br><span class="line">        message.source = <span class="number">0</span>;</span><br><span class="line">        message.session = <span class="number">0</span>;</span><br><span class="line">        message.data = sm;</span><br><span class="line">        message.sz = sz | ((<span class="keyword">size_t</span>)PTYPE_SOCKET &lt;&lt; MESSAGE_TYPE_SHIFT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skynet_context_push((<span class="keyword">uint32_t</span>)result-&gt;opaque, &amp;message)) &#123;</span><br><span class="line">                <span class="comment">// todo: report somewhere to close socket</span></span><br><span class="line">                <span class="comment">// don't call skynet_socket_close here (It will block mainloop)</span></span><br><span class="line">                skynet_free(sm-&gt;buffer);</span><br><span class="line">                skynet_free(sm);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其是通过 <code>skynet_context_push()</code>函数实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_context_push(<span class="keyword">uint32_t</span> handle, struct skynet_message *message) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_handle_grab</span>(<span class="title">handle</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        skynet_mq_push(ctx-&gt;<span class="built_in">queue</span>, message);</span><br><span class="line">        skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过handle来找到服务的ctx-&gt;queue，然后压进去。</p>
<h1 id="从服务的注册看起。"><a href="#从服务的注册看起。" class="headerlink" title="从服务的注册看起。"></a>从服务的注册看起。</h1><p>我们通过Lua编写的所有服务，都是通过 <code>skynet.newservice</code>函数注册的。这是一个Lua函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.newservice</span><span class="params">(name, ...)</span></span></span><br><span class="line">        <span class="keyword">return</span> skynet.call(<span class="string">".launcher"</span>, <span class="string">"lua"</span> , <span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> p = proto[typename]</span><br><span class="line">        <span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))</span><br><span class="line">        <span class="keyword">if</span> session == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">error</span>(<span class="string">"call to invalid address "</span> .. skynet.address(addr))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其本质，是通过 <code>skynet.call</code>函数向 <em>.launcher</em>服务，发送 <em>lua</em>类型的消息，加上一系列参数实现的。</p>
<p>而<code>skynet.call</code>则调用的是导出的C函数 <code>skynet_core.send</code>，更具体的C函数就是<code>lsend</code>。具体函数的导出参看另外一篇文章<a href="https://gowa2017.github.io/Lua/skynet%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%BD%BD%E5%85%A5%E6%B5%81%E7%A8%8B.html">skynet的启动与服务载入流程</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lualib-src/lua-skynet.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lsend(lua_State *L) &#123;</span><br><span class="line">        <span class="keyword">return</span> send_message(L, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_message(lua_State *L, <span class="keyword">int</span> source, <span class="keyword">int</span> idx_type) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">        <span class="keyword">uint32_t</span> dest = (<span class="keyword">uint32_t</span>)lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * dest_string = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (dest == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lua_type(L,<span class="number">1</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">                        <span class="keyword">return</span> luaL_error(L, <span class="string">"Invalid service address 0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dest_string = get_dest_string(L, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> type = luaL_checkinteger(L, idx_type+<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> session = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lua_isnil(L,idx_type+<span class="number">1</span>)) &#123;</span><br><span class="line">                type |= PTYPE_TAG_ALLOCSESSION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                session = luaL_checkinteger(L,idx_type+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mtype = lua_type(L,idx_type+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">switch</span> (mtype) &#123;</span><br><span class="line">                <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">                <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">void</span> * msg = (<span class="keyword">void</span> *)lua_tolstring(L,idx_type+<span class="number">2</span>,&amp;len);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                        msg = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dest_string) &#123;</span><br><span class="line">                        session = skynet_sendname(context, source, dest_string, type, session , msg, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        session = skynet_send(context, source, dest, type, session , msg, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> LUA_TLIGHTUSERDATA: &#123;</span><br><span class="line">                <span class="keyword">void</span> * msg = lua_touserdata(L,idx_type+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">int</span> size = luaL_checkinteger(L,idx_type+<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (dest_string) &#123;</span><br><span class="line">                        session = skynet_sendname(context, source, dest_string, type | PTYPE_TAG_DONTCOPY, session, msg, size);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        session = skynet_send(context, source, dest, type | PTYPE_TAG_DONTCOPY, session, msg, size);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                luaL_error(L, <span class="string">"invalid param %s"</span>, lua_typename(L, lua_type(L,idx_type+<span class="number">2</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// send to invalid address</span></span><br><span class="line">                <span class="comment">// todo: maybe throw an error would be better</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                lua_pushinteger(L,session);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，是通过<code>skynet_server.c</code>中的的 <code>skynet_context_push</code>函数将消息推到对应的<code>skynet_context</code>结构中的消息队列中去，接着就返回 sessionId。</p>
<h2 id="消息分发函数"><a href="#消息分发函数" class="headerlink" title="消息分发函数"></a>消息分发函数</h2><p>每个业务脚本都会注册一个消息处理函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">        c.callback(skynet.dispatch_message)</span><br><span class="line">        skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                skynet.init_service(start_func)</span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>每次收到消息的时候就会调用这个消息处理函数。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Gowa2017 Zhang</p><p>原文链接: <a href="https://gowa2017.github.io/Lua/skynet-任务调度及消息处理.html">https://gowa2017.github.io/Lua/skynet-任务调度及消息处理.html</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Lua/">Lua</a><a href="/tags/skynet/">skynet</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/PIL/PIL.29Lua中调用C函数.html" class="pre">PIL.29Lua中调用C函数</a><a href="/Lua/skynet的启动与服务载入流程.html" class="next">Skynet的启动与服务载入流程</a></div><div id="comments"><div id="disqus_thread"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#skyent-main"><span class="toc-text">skyent main()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#skynet-globalinit-全局节点初始化"><span class="toc-text">skynet_globalinit() - 全局节点初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#skynet-env-init-－全局环境变量"><span class="toc-text">skynet_env_init()－全局环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#luaL-initcodecache"><span class="toc-text">luaL_initcodecache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置加载"><span class="toc-text">配置加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init-env-L"><span class="toc-text">__init_env(L)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#skynet-start-amp-config"><span class="toc-text">skynet_start(&amp;config)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-harbor-init-int-harbor"><span class="toc-text">skynet_harbor_init(int harbor)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-handle-init"><span class="toc-text">skynet_handle_init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-module-init"><span class="toc-text">skynet_module_init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-mq-init"><span class="toc-text">skynet_mq_init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-timer-init"><span class="toc-text">skynet_timer_init();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-socket-init"><span class="toc-text">skynet_socket_init();</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#skynet-context-结构"><span class="toc-text">skynet_context 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#服务-H-表"><span class="toc-text">服务 H 表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-create-new"><span class="toc-text">skynet_create_new()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-module-instance-create"><span class="toc-text">skynet_module_instance_create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skynet-handle-register"><span class="toc-text">skynet_handle_register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块（服务）的初始化"><span class="toc-text">模块（服务）的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#snlua"><span class="toc-text">snlua</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bootstrap"><span class="toc-text">bootstrap()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#start-thread-config-gt-thread"><span class="toc-text">start_thread(config-&gt;thread)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-worker"><span class="toc-text">thread_worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-socket"><span class="toc-text">thread_socket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从服务的注册看起。"><span class="toc-text">从服务的注册看起。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#消息分发函数"><span class="toc-text">消息分发函数</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Lua/luasocket中的http实现.html">luasocket中的http实现</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/安卓原生模拟器进行root操作.html">安卓原生模拟器进行root操作</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/JNI使用-LuaJava实现.html">JNI使用-LuaJava实现</a></li><li class="post-list-item"><a class="post-list-link" href="/Java/JNI技术与Native代码交互.html">JNI技术与Native代码交互</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/PIL.15.数据文件与序列化.html">PIL.15.数据文件与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/在安卓中进行共享库的注入.html">在安卓中进行共享库的注入</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/Windows反调试技术.html">Windows反调试技术</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/Windows反虚拟机技术.html">Windows反虚拟机技术</a></li><li class="post-list-item"><a class="post-list-link" href="/Oracle/使用Sqlplus动态执行SQL命令.html">使用Sqlplus动态执行SQL命令</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/关于汇编中的PTR操作符.html">关于汇编中的PTR操作符</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Asm/">Asm</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos-Creator/">Cocos Creator</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-X/">Cocos2d-X</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Device/">Device</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GTD/">GTD</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">43</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kindle/">Kindle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Unix/">Linux/Unix</a><span class="category-list-count">35</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Office/">Office</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Oracle/">Oracle</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PIL/">PIL</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SED-AWK/">SED&AWK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TensorFlow/">TensorFlow</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Work/">Work</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS/">macOS</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/RegEx/" style="font-size: 15px;">RegEx</a> <a href="/tags/curl/" style="font-size: 15px;">curl</a> <a href="/tags/装修/" style="font-size: 15px;">装修</a> <a href="/tags/brew/" style="font-size: 15px;">brew</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Word/" style="font-size: 15px;">Word</a> <a href="/tags/Office/" style="font-size: 15px;">Office</a> <a href="/tags/弯头/" style="font-size: 15px;">弯头</a> <a href="/tags/管件/" style="font-size: 15px;">管件</a> <a href="/tags/水管/" style="font-size: 15px;">水管</a> <a href="/tags/sed/" style="font-size: 15px;">sed</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/Cocos2d-X/" style="font-size: 15px;">Cocos2d-X</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/LVM/" style="font-size: 15px;">LVM</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/android-studio/" style="font-size: 15px;">android studio</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/word/" style="font-size: 15px;">word</a> <a href="/tags/REST/" style="font-size: 15px;">REST</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/VNC/" style="font-size: 15px;">VNC</a> <a href="/tags/Docx/" style="font-size: 15px;">Docx</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/X5/" style="font-size: 15px;">X5</a> <a href="/tags/Tbs/" style="font-size: 15px;">Tbs</a> <a href="/tags/Cocos-Creator/" style="font-size: 15px;">Cocos Creator</a> <a href="/tags/Cocos-Js/" style="font-size: 15px;">Cocos-Js</a> <a href="/tags/Cocos-Creator/" style="font-size: 15px;">Cocos-Creator</a> <a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/ML/" style="font-size: 15px;">ML</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/Sqlplus/" style="font-size: 15px;">Sqlplus</a> <a href="/tags/Application/" style="font-size: 15px;">Application</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/Dagger/" style="font-size: 15px;">Dagger</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/PAC/" style="font-size: 15px;">PAC</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/NFS/" style="font-size: 15px;">NFS</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/Pomelo/" style="font-size: 15px;">Pomelo</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/AppExecutors/" style="font-size: 15px;">AppExecutors</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/Gson/" style="font-size: 15px;">Gson</a> <a href="/tags/GTD/" style="font-size: 15px;">GTD</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Bash/" style="font-size: 15px;">Bash</a> <a href="/tags/Selector/" style="font-size: 15px;">Selector</a> <a href="/tags/Room/" style="font-size: 15px;">Room</a> <a href="/tags/AAR/" style="font-size: 15px;">AAR</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/MFC/" style="font-size: 15px;">MFC</a> <a href="/tags/Cpp/" style="font-size: 15px;">Cpp</a> <a href="/tags/Asm/" style="font-size: 15px;">Asm</a> <a href="/tags/Work/" style="font-size: 15px;">Work</a> <a href="/tags/AAA/" style="font-size: 15px;">AAA</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/POSIX/" style="font-size: 15px;">POSIX</a> <a href="/tags/Kindle/" style="font-size: 15px;">Kindle</a> <a href="/tags/小说/" style="font-size: 15px;">小说</a> <a href="/tags/F5/" style="font-size: 15px;">F5</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/iptables/" style="font-size: 15px;">iptables</a> <a href="/tags/加固/" style="font-size: 15px;">加固</a> <a href="/tags/越狱/" style="font-size: 15px;">越狱</a> <a href="/tags/阅读/" style="font-size: 15px;">阅读</a> <a href="/tags/Cron/" style="font-size: 15px;">Cron</a> <a href="/tags/Unix/" style="font-size: 15px;">Unix</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/OSPF/" style="font-size: 15px;">OSPF</a> <a href="/tags/OpenSSH/" style="font-size: 15px;">OpenSSH</a> <a href="/tags/OpenSSL/" style="font-size: 15px;">OpenSSL</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Oralce/" style="font-size: 15px;">Oralce</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Device/" style="font-size: 15px;">Device</a> <a href="/tags/Raid/" style="font-size: 15px;">Raid</a> <a href="/tags/磁盘阵列/" style="font-size: 15px;">磁盘阵列</a> <a href="/tags/ntpd/" style="font-size: 15px;">ntpd</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Gowa2017 Zhang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-137245514-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><<<<<<< Updated upstream<script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>var disqus_shortname = 'gowa-1';
var disqus_identifier = 'Lua/skynet-任务调度及消息处理.html';
var disqus_title = 'skynet-任务调度及消息处理';
var disqus_url = 'https://gowa2017.github.io/Lua/skynet-任务调度及消息处理.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//gowa-1.disqus.com/count.js" async></script><script type="text/javascript" src="//gowa-1.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></body></html>