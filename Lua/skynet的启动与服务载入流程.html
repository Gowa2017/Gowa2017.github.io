<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  <title>Skynet的启动与服务载入流程 | 退思园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。">
<meta name="keywords" content="Lua,Skynet">
<meta property="og:type" content="article">
<meta property="og:title" content="Skynet的启动与服务载入流程">
<meta property="og:url" content="https://gowa.club/Lua/skynet的启动与服务载入流程.html">
<meta property="og:site_name" content="退思园">
<meta property="og:description" content="一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-01T09:35:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skynet的启动与服务载入流程">
<meta name="twitter:description" content="一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。">
  
    <link rel="alternate" href="/atom.xml" title="退思园" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">退思园</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">烦恼一般都是想太多了。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://gowa.club"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-skynet的启动与服务载入流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Lua/skynet的启动与服务载入流程.html" class="article-date">
  <time class="dt-published" datetime="2018-02-01T09:35:39.000Z" itemprop="datePublished">2018-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Lua/">Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Skynet的启动与服务载入流程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。<br><a id="more"></a></p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>这个项目在<a href="https://github.com/cloudwu/skynet" target="_blank" rel="noopener">github.com开源</a>。是一个用于在线游戏服务器的框架，但是不仅仅用于游戏，很多其他服务端也能用到。其是基与c和lua的。其内部封装了<strong>mysql, mongodb, socket</strong>等库，用起来确实是很不错的。但是性能方面暂时不知道，但是看云风大大一直追求的性能和效率的话应该不会差。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Skynet 的单机模型来说，只有一个进程。然后把用 Lua 编写的每个业务逻辑单元叫做<em>服务</em>。所有的数据，消息的传递只在进程内部，因此的话，效率是有保证的，唯一可能出现考量的地方，就是Lua的虚拟机是否依然高效。这比传统的多进程间的通信模型就简单了许多，不需要用到什么共享内存，消息队列等了。</p>
<p>对于想启动一个服务，只需要调用<code>skynet.newservice(name)</code>，这将会返回一个服务地址，就可以了。<em>name</em>是脚本名。Skynet 会根据我们配置文件中的 <em>luaservice</em> 目录去寻找对应的 <em>name.lua</em> 文件。另外注意，类似 <code>.launcher</code> 这样的服务只是在本机可见， 在节点间是不可见的。同时我们可以用<code>skynet.name(name, addr)</code>把一个服务地址给绑定到一个别名，以后凡是用到服务地址的地方都可以使用名字。</p>
<h1 id="服务的三个阶段"><a href="#服务的三个阶段" class="headerlink" title="服务的三个阶段"></a>服务的三个阶段</h1><p>每个Lua都分为三个阶段：</p>
<ul>
<li>加载阶段。加载Lua脚本到内存，分配一个实例。</li>
<li>初始化阶段。由<code>skynet.start(function() ... end)</code>注册的初始化函数进行初始化。我们的<code>skynet.newservice(name)</code>会在这个函数执行完毕后才返回。</li>
<li>工作阶段。</li>
</ul>
<h1 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h1><p>skynet 其实有两种服务，一种是 C 服务，一种是 Lua 服务。这两者事实上没有本质的区别，止不过对于 C 服务其逻辑是用 C 中实现的，而 Lua 服务，则是用 Lua 实现了逻辑，同时，Lua 服务其实是一个承载 Lua 逻辑的 snlua 服务而已。</p>
<p>搭建一个 Lua 服务，只需要定义好其要处理的协议信息，其消息处理函数，其实就OK了。</p>
<p>就对于 skynet 引擎而言，任何服务，其都将其封装在一个 skynet_context 结构中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> * instance;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span>;</span></span><br><span class="line">        <span class="keyword">void</span> * cb_ud;</span><br><span class="line">        skynet_cb cb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">        FILE * logfile;</span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_cost;      <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_start;     <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> handle;</span><br><span class="line">        <span class="keyword">int</span> session_id;</span><br><span class="line">        <span class="keyword">int</span> ref;</span><br><span class="line">        <span class="keyword">int</span> message_count;</span><br><span class="line">        <span class="keyword">bool</span> init;</span><br><span class="line">        <span class="keyword">bool</span> endless;</span><br><span class="line">        <span class="keyword">bool</span> profile;</span><br><span class="line"></span><br><span class="line">        CHECKCALLING_DECL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个上下文结构中保留了此</p>
<ul>
<li><strong>instance</strong> 服务实例的指针，实际上是一个 so 库中定义的结构。</li>
<li><strong>mod</strong> 模块地址，对应加载在 skynet 进程中的 so 库内存地址。</li>
<li><strong>cb_ud</strong> 回调是会使用到的一个数据结构，对于 Lua 服务，这将会是一个 lua_State</li>
<li><strong>skynet_cb</strong> 服务的回调 skynet_cb ，。</li>
<li><strong>queue</strong> 以及其消息队列</li>
</ul>
<p>创建一个服务，其实质，就是创建一个 skynet_context 结构而已，然后根据消息，回调此结构内的对应函数。</p>
<p>对于一个 C 服务，多会在其实例化的时候即指定其回调，而对于 Lua 服务，一般是在 Lua 中通过注册回调来实现的。</p>
<h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><p>skynet的主程序，通过类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./skynet config.lua</span><br></pre></td></tr></table></figure>
<p>这样的命令行启动。然后主程序就会读入这个配置文件，进行启动各项服务。  </p>
<p>我们先来看一下这个配置文件默认情况下是什么样的。</p>
<h2 id="config-lua"><a href="#config-lua" class="headerlink" title="config.lua"></a>config.lua</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">root = <span class="string">"./"</span></span><br><span class="line">thread = <span class="number">8</span></span><br><span class="line">logger = <span class="literal">nil</span></span><br><span class="line">harbor = <span class="number">1</span></span><br><span class="line">address = <span class="string">"127.0.0.1:2526"</span></span><br><span class="line">master = <span class="string">"127.0.0.1:2013"</span></span><br><span class="line">start = <span class="string">"main"</span>    <span class="comment">-- main script</span></span><br><span class="line">bootstrap = <span class="string">"snlua bootstrap"</span>    <span class="comment">-- The service for bootstrap</span></span><br><span class="line">standalone = <span class="string">"0.0.0.0:2013"</span></span><br><span class="line">luaservice = root..<span class="string">"service/?.lua;"</span>..root..<span class="string">"test/?.lua;"</span>..root..<span class="string">"examples/?.lua"</span></span><br><span class="line">lualoader = <span class="string">"lualib/loader.lua"</span></span><br><span class="line">snax = root..<span class="string">"examples/?.lua;"</span>..root..<span class="string">"test/?.lua"</span></span><br><span class="line"><span class="built_in">cpath</span> = root..<span class="string">"cservice/?.so"</span></span><br></pre></td></tr></table></figure>
<p>单机模型下，我们可以暂时忽略<em>address, master, standalone</em>三个字段。现在把重心放在启动的流程上面，暂时不要管多节点的情况。</p>
<ul>
<li><strong>thread</strong>：线程数，一般设置为和CPU核心数量一致</li>
<li><strong>bootstrap</strong>：启动的第一个服务及参数。<em>snlua bootstrap</em>是默认配置，说明的是以<em>bootstrap</em>参数启动<em>snlua</em>服务（ snlua 是 lua 的沙盒服务，相当于开启一个 Lua 虚拟机了），之后的所有服务都直接或间接的由这个服务启动。默认情况下，<em>bootstrap</em>服务文件位于<code>service/bootstrap.lua</code>下。指定服务文件名不需要带上<code>.lua</code>扩展名。</li>
<li><strong>cpath</strong>： 用 C 编写的服务模块的位置，通常指 cservice 下那些 .so 文件。如果你的系统的动态库不是以 .so 为后缀，需要做相应的修改。这个路径可以配置多项，以 ; 分割。</li>
<li><strong>luaservice</strong>：lua服务文件的位置。也就是说，当我们启动一个服务的时候，去哪里寻找并载入对应的文件。</li>
<li><strong>loader</strong>：用哪一段 lua 代码加载 lua 服务。通常配置为<code>lualib/loader.lua</code> ，再由这段代码解析服务名称，进一步加载 lua 代码。snlua 会将下面几个配置项取出，放在初始化好的 lua 虚拟机的全局变量中。具体可参考实现。<br>SERVICE_NAME 第一个参数，通常是服务名。<br>LUA_PATH config 文件中配置的 lua_path 。<br>LUA_CPATH config 文件中配置的 lua_cpath 。<br>LUA_PRELOAD config 文件中配置的 preload 。<br>LUA_SERVICE config 文件中配置的 luaservice 。  </li>
<li><strong>lua_path</strong>： 将添加到 package.path 中的路径，供 require 调用。</li>
<li><strong>lua_cpath</strong>： 将添加到 package.cpath 中的路径，供 require 调用</li>
</ul>
<h2 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h2><blockquote>
<p>第一个启动的服务是 logger ，它负责记录之后的服务中的 log 输出。logger 是一个简单的 C 服务， skynet_error  这个 C API 会把字符串发送给它。在 config 文件中，logger 配置项可以配置 log 输出的文件名，默认是 nil ，表示输出到标准输出。</p>
</blockquote>
<p>在 <a href="/Lua/skynet-任务调度及消息处理.html" title="skynet-任务调度及消息处理">skynet-任务调度及消息处理</a> 中我们可以看到 logger 服务的启动逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, config-&gt;logservice);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet_handle_namehandle(skynet_context_handle(ctx), <span class="string">"logger"</span>);</span><br></pre></td></tr></table></figure>
<p>logger.so 这个 C 服务模块会在初始化后，即将服务的回调指定为 C 来处理，同时将其回调时候的 <strong>cb_ud</strong> 指定为实例本身。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service-src/service-logger.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">logger_cb(struct skynet_context * context, <span class="keyword">void</span> *ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">logger</span> * <span class="title">inst</span> = <span class="title">ud</span>;</span></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PTYPE_SYSTEM:</span><br><span class="line">		<span class="keyword">if</span> (inst-&gt;filename) &#123;</span><br><span class="line">			inst-&gt;handle = freopen(inst-&gt;filename, <span class="string">"a"</span>, inst-&gt;handle);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PTYPE_TEXT:</span><br><span class="line">		<span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">"[:%08x] "</span>,source);</span><br><span class="line">		fwrite(msg, sz , <span class="number">1</span>, inst-&gt;handle);</span><br><span class="line">		<span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">"\n"</span>);</span><br><span class="line">		fflush(inst-&gt;handle);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger_init(struct logger * inst, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * parm) &#123;</span><br><span class="line">	<span class="keyword">if</span> (parm) &#123;</span><br><span class="line">		inst-&gt;handle = fopen(parm,<span class="string">"w"</span>);</span><br><span class="line">		<span class="keyword">if</span> (inst-&gt;handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inst-&gt;filename = skynet_malloc(<span class="built_in">strlen</span>(parm)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(inst-&gt;filename, parm);</span><br><span class="line">		inst-&gt;close = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		inst-&gt;handle = <span class="built_in">stdout</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inst-&gt;handle) &#123;</span><br><span class="line">		skynet_callback(ctx, inst, logger_cb); <span class="comment">// 设置服务回调</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="snlua"><a href="#snlua" class="headerlink" title="snlua"></a>snlua</h2><p>snlua是一个C模块的服务，在<code>cservice/snlua.so</code>下，所有的Lua服务其实都是snlua模块服务的实例，只是承载的Lua脚本不同而已。</p>
<p>我们看到， snlua 服务的初始化相对而言要麻烦很多。<br>其大体分为几步：</p>
<ol>
<li>C 部分的初始化。 当建立好一个 snlua 服务后，其会将对应的 skynet_context 注册到 skynet 中去，通过向 skynet 发送  REG 命令。</li>
<li>Lua 部分的初始化。通过向 此服务发送一个包含了要加载的脚本的第一个消息，使 snlua 进入 launch_cb 阶段。</li>
<li>在 launch_cb 中，会根据收到消息中的参数（表示要加载的 lua 脚本），然后进行初始化 Lua 服务</li>
<li>init_cb 加载脚本，并执行。我们可以来细细看看 init_cb 这个函数的内容。</li>
<li>init_cb 会使用  loader.lua 来加载，并执行我们的 Lua 服务。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">init_cb(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	lua_State *L = l-&gt;L;</span><br><span class="line">	l-&gt;ctx = ctx;</span><br><span class="line">	lua_gc(L, LUA_GCSTOP, <span class="number">0</span>);</span><br><span class="line">	lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">	lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"LUA_NOENV"</span>);</span><br><span class="line">	luaL_openlibs(L);</span><br><span class="line">	lua_pushlightuserdata(L, ctx);</span><br><span class="line">	lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>); <span class="comment">// 将服务结构 skynet_context 保存到全局注册表内</span></span><br><span class="line">	luaL_requiref(L, <span class="string">"skynet.codecache"</span>, codecache , <span class="number">0</span>);</span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *path = optstring(ctx, <span class="string">"lua_path"</span>,<span class="string">"./lualib/?.lua;./lualib/?/init.lua"</span>);</span><br><span class="line">	lua_pushstring(L, path);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_PATH"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cpath = optstring(ctx, <span class="string">"lua_cpath"</span>,<span class="string">"./luaclib/?.so"</span>);</span><br><span class="line">	lua_pushstring(L, cpath);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_CPATH"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *service = optstring(ctx, <span class="string">"luaservice"</span>, <span class="string">"./service/?.lua"</span>);</span><br><span class="line">	lua_pushstring(L, service);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_SERVICE"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *preload = skynet_command(ctx, <span class="string">"GETENV"</span>, <span class="string">"preload"</span>);</span><br><span class="line">	lua_pushstring(L, preload);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_PRELOAD"</span>);</span><br><span class="line"></span><br><span class="line">	lua_pushcfunction(L, traceback);</span><br><span class="line">	assert(lua_gettop(L) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> r = luaL_loadfile(L,loader); <span class="comment">// 加载 loader.lua</span></span><br><span class="line">	<span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">		skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">		report_launcher_error(ctx);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pushlstring(L, args, sz); <span class="comment">// 通过 loader.lua 来加载我们指定的脚本</span></span><br><span class="line">	r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 加载 我们的服务脚本</span></span><br><span class="line">	<span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">		skynet_error(ctx, <span class="string">"lua loader error : %s"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">		report_launcher_error(ctx);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_settop(L,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> limit = lua_tointeger(L, <span class="number">-1</span>);</span><br><span class="line">		l-&gt;mem_limit = limit;</span><br><span class="line">		skynet_error(ctx, <span class="string">"Set memory limit to %.2f M"</span>, (<span class="keyword">float</span>)limit / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">		lua_pushnil(L);</span><br><span class="line">		lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pop(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	lua_gc(L, LUA_GCRESTART, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">launch_cb(struct skynet_context * context, <span class="keyword">void</span> *ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source , <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	assert(type == <span class="number">0</span> &amp;&amp; session == <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *<span class="title">l</span> = <span class="title">ud</span>;</span></span><br><span class="line">	skynet_callback(context, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> err = init_cb(l, context, msg, sz);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		skynet_command(context, <span class="string">"EXIT"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">snlua_init(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args) &#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="built_in">strlen</span>(args);</span><br><span class="line">	<span class="keyword">char</span> * tmp = skynet_malloc(sz);</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp, args, sz);</span><br><span class="line">	skynet_callback(ctx, l , launch_cb);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * self = skynet_command(ctx, <span class="string">"REG"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> handle_id = strtoul(self+<span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">	<span class="comment">// it must be first message</span></span><br><span class="line">	skynet_send(ctx, <span class="number">0</span>, handle_id, PTYPE_TAG_DONTCOPY,<span class="number">0</span>, tmp, sz);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="skynet-导出到-Lua"><a href="#skynet-导出到-Lua" class="headerlink" title="skynet 导出到 Lua"></a>skynet 导出到 Lua</h1><p>skynet 本身所提供的 API 只有基础的几个，但是在其导出的 API 上在 Lua 中又进行了很多的封装，因此看起来会有点绕的样子。</p>
<p>而且对于服务的加载，也重写了 <strong>loader.lua</strong></p>
<h2 id="skynet-core"><a href="#skynet-core" class="headerlink" title="skynet.core"></a>skynet.core</h2><p>其返回值是一个地址。这里我们看到，<code>skynet.core</code>是一个被导入的库，真实执行的就是这个库内导出的函数。在文件<code>lualib-src/lua-skynet.c</code>中，我们看到了这个函数的导出。</p>
<p>在 <a href="/Lua/PIL.17Lua中的模块与包.html" title="PIL.17Lua中的模块与包">PIL.17Lua中的模块与包</a> 中我们说到，当我们以 <code>skynet.core</code> 尝试加载一个子模块的时候，如果找不到对应的 <code>core.lua</code>，也找不到对应的 <code>core.so</code>，那么加载 C 库的最后一个搜索器就会使用 <code>skynet</code> 名称进行查找，然后调用 <code>luaopen_skynet_core</code>。这就运行我们将子模块都放到一个库文件中进行加载了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lua-skynet.c</span></span><br><span class="line">LUAMOD_API <span class="keyword">int</span></span><br><span class="line">luaopen_skynet_core(lua_State *L) &#123;</span><br><span class="line">        luaL_checkversion(L);</span><br><span class="line"></span><br><span class="line">        luaL_Reg l[] = &#123;</span><br><span class="line">                &#123; <span class="string">"send"</span> , lsend &#125;,</span><br><span class="line">                &#123; <span class="string">"genid"</span>, lgenid &#125;,</span><br><span class="line">                &#123; <span class="string">"redirect"</span>, lredirect &#125;,</span><br><span class="line">                &#123; <span class="string">"command"</span> , lcommand &#125;,</span><br><span class="line">                &#123; <span class="string">"intcommand"</span>, lintcommand &#125;,</span><br><span class="line">                &#123; <span class="string">"error"</span>, lerror &#125;,</span><br><span class="line">                &#123; <span class="string">"tostring"</span>, ltostring &#125;,</span><br><span class="line">                &#123; <span class="string">"harbor"</span>, lharbor &#125;,</span><br><span class="line">                &#123; <span class="string">"pack"</span>, luaseri_pack &#125;,</span><br><span class="line">                &#123; <span class="string">"unpack"</span>, luaseri_unpack &#125;,</span><br><span class="line">                &#123; <span class="string">"packstring"</span>, lpackstring &#125;,</span><br><span class="line">                &#123; <span class="string">"trash"</span> , ltrash &#125;,</span><br><span class="line">                &#123; <span class="string">"callback"</span>, lcallback &#125;,</span><br><span class="line">                &#123; <span class="string">"now"</span>, lnow &#125;,</span><br><span class="line">                &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        luaL_newlibtable(L, l);</span><br><span class="line"></span><br><span class="line">        lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>,-1);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> luaL_error(L, <span class="string">"Init skynet context first"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        luaL_setfuncs(L,l,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcommand(lua_State *L) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * cmd = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * result;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * parm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (lua_gettop(L) == <span class="number">2</span>) &#123;</span><br><span class="line">                parm = luaL_checkstring(L,<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = skynet_command(context, cmd, parm);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                lua_pushstring(L, result);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>skynet-src/skynet_server.c</code>中，定义了<code>skynet_command</code>函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">static struct command_func cmd_funcs[] = &#123;</span><br><span class="line">        &#123; <span class="string">"TIMEOUT"</span>, cmd_timeout &#125;,</span><br><span class="line">        &#123; <span class="string">"REG"</span>, cmd_reg &#125;,</span><br><span class="line">        &#123; <span class="string">"QUERY"</span>, cmd_query &#125;,</span><br><span class="line">        &#123; <span class="string">"NAME"</span>, cmd_name &#125;,</span><br><span class="line">        &#123; <span class="string">"EXIT"</span>, cmd_exit &#125;,</span><br><span class="line">        &#123; <span class="string">"KILL"</span>, cmd_kill &#125;,</span><br><span class="line">        &#123; <span class="string">"LAUNCH"</span>, cmd_launch &#125;,</span><br><span class="line">        &#123; <span class="string">"GETENV"</span>, cmd_getenv &#125;,</span><br><span class="line">        &#123; <span class="string">"SETENV"</span>, cmd_setenv &#125;,</span><br><span class="line">        &#123; <span class="string">"STARTTIME"</span>, cmd_starttime &#125;,</span><br><span class="line">        &#123; <span class="string">"ABORT"</span>, cmd_abort &#125;,</span><br><span class="line">        &#123; <span class="string">"MONITOR"</span>, cmd_monitor &#125;,</span><br><span class="line">        &#123; <span class="string">"STAT"</span>, cmd_stat &#125;,</span><br><span class="line">        &#123; <span class="string">"LOGON"</span>, cmd_logon &#125;,</span><br><span class="line">        &#123; <span class="string">"LOGOFF"</span>, cmd_logoff &#125;,</span><br><span class="line">        &#123; <span class="string">"SIGNAL"</span>, cmd_signal &#125;,</span><br><span class="line">        &#123; NULL, NULL &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">char</span> *</span><br><span class="line">skynet_command(struct skynet_context * context, const <span class="built_in">char</span> * cmd , const <span class="built_in">char</span> * param) &#123;</span><br><span class="line">        struct command_func * method = &amp;cmd_funcs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(method-&gt;name) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strcmp(cmd, method-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method-&gt;func(context, param);</span><br><span class="line">                &#125;</span><br><span class="line">                ++method;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const <span class="built_in">char</span> *</span><br><span class="line">cmd_launch(struct skynet_context * context, const <span class="built_in">char</span> * param) &#123;</span><br><span class="line">        size_t sz = strlen(param);</span><br><span class="line">        <span class="built_in">char</span> tmp[sz+<span class="number">1</span>];</span><br><span class="line">        strcpy(tmp,param);</span><br><span class="line">        <span class="built_in">char</span> * args = tmp;</span><br><span class="line">        <span class="built_in">char</span> * <span class="built_in">mod</span> = strsep(&amp;args, <span class="string">" \t\r\n"</span>);</span><br><span class="line">        args = strsep(&amp;args, <span class="string">"\r\n"</span>);</span><br><span class="line">        struct skynet_context * inst = skynet_context_new(<span class="built_in">mod</span>,args);</span><br><span class="line">        <span class="keyword">if</span> (inst == NULL) &#123;</span><br><span class="line">                <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                id_to_hex(context-&gt;result, inst-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> context-&gt;result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导出库"><a href="#导出库" class="headerlink" title="导出库"></a>导出库</h2><p>在 <code>lualib-src</code> 目录中，导出了很多 C 库。在这些导出库之上，又用 Lua 进行了一些封装。</p>
<p>例如，在 <code>skynet.core</code> 库之上，还封装了 <code>lualib/skynet.lua, lualib/skyet/*</code> 这些库。</p>
<p>其中与服务相关的是 <code>skynet/manager.lua</code> 进行框架（各种服务）管理。<code>skynet.lua</code> 则是 Lua 中的服务构建。</p>
<h1 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h1><p>Skynet运行的第二个服务是<code>snlua bootstrap</code>，表示启动一个<strong>snlua</strong>服务，以<code>bootstrap</code>作为参数进行初始化，<strong>snlua</strong>是lua的沙盒服务。同样，服务名<em>bootstrap</em>指定后，会根据<code>luaservice</code>配置的路径来寻找对应的<code>bootstrap.lua</code>文件并加载执行。</p>
<p>在skynet的源码文件<code>skynet-serc/skynet_start.c</code>中，有<code>bootstrap(ctx, config-&gt;bootstrap)</code>调用。</p>
<p>当前<em>bootstrap.lua</em>文件如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">"skynet"</span></span><br><span class="line"><span class="keyword">local</span> harbor = <span class="built_in">require</span> <span class="string">"skynet.harbor"</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> standalone = skynet.<span class="built_in">getenv</span> <span class="string">"standalone"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> launcher = <span class="built_in">assert</span>(skynet.launch(<span class="string">"snlua"</span>,<span class="string">"launcher"</span>))</span><br><span class="line">    skynet.name(<span class="string">".launcher"</span>, launcher)</span><br><span class="line">        <span class="keyword">local</span> harbor_id = <span class="built_in">tonumber</span>(skynet.<span class="built_in">getenv</span> <span class="string">"harbor"</span>)</span><br><span class="line">    <span class="keyword">if</span> harbor_id == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">assert</span>(standalone ==  <span class="literal">nil</span>)</span><br><span class="line">        standalone = <span class="literal">true</span></span><br><span class="line">        skynet.setenv(<span class="string">"standalone"</span>, <span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> ok, slave = <span class="built_in">pcall</span>(skynet.newservice, <span class="string">"cdummy"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">            skynet.abort()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        skynet.name(<span class="string">".slave"</span>, slave)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> standalone <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">pcall</span>(skynet.newservice,<span class="string">"cmaster"</span>) <span class="keyword">then</span></span><br><span class="line">                skynet.abort()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> ok, slave = <span class="built_in">pcall</span>(skynet.newservice, <span class="string">"cslave"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">            skynet.abort()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        skynet.name(<span class="string">".slave"</span>, slave)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> standalone <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> datacenter = skynet.newservice <span class="string">"datacenterd"</span></span><br><span class="line">        skynet.name(<span class="string">"DATACENTER"</span>, datacenter)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    skynet.newservice <span class="string">"service_mgr"</span></span><br><span class="line">    <span class="built_in">pcall</span>(skynet.newservice,skynet.<span class="built_in">getenv</span> <span class="string">"start"</span> <span class="keyword">or</span> <span class="string">"main"</span>)</span><br><span class="line">    skynet.<span class="built_in">exit</span>()</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>当 snlua 将 bootstrap 脚本加载到对应服务实例的 Lua 虚拟机中，就会以 loader.lua 来加载服务，然后进行执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = luaL_loadfile(L,loader);</span><br><span class="line"><span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">	skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">	report_launcher_error(ctx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">lua_pushlstring(L, args, sz);</span><br><span class="line">r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="服务的框架"><a href="#服务的框架" class="headerlink" title="服务的框架"></a>服务的框架</h2><p>这个函数，封装在 skynet.lua 中，感觉颇为复杂。参看 <a href="https://github.com/cloudwu/skynet/wiki/APIList" target="_blank" rel="noopener">API列表来进行解释吧</a></p>
<h2 id="skynet-start"><a href="#skynet-start" class="headerlink" title="skynet.start"></a>skynet.start</h2><p>我们通过前面的 snlua 初始化过程已经知道，这个时候， snlua 实例已经注册到了 skynet，但是其回调，协议都是没有进行定义的。这个函数，其实就是进行定义此 snlua 实例的协议及消息分发函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">	c.callback(skynet.dispatch_message) <span class="comment">-- 简单直接的将 snlua 的回调设置为 skynet.dispatch_message</span></span><br><span class="line">	init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		skynet.init_service(start_func)</span><br><span class="line">		init_thread = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.dispatch_message</span><span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> succ, err = <span class="built_in">pcall</span>(raw_dispatch_message,...)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> co = tremove(fork_queue,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> co == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">local</span> fork_succ, fork_err = <span class="built_in">pcall</span>(suspend,co,coroutine_resume(co))</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> fork_succ <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">if</span> succ <span class="keyword">then</span></span><br><span class="line">				succ = <span class="literal">false</span></span><br><span class="line">				err = <span class="built_in">tostring</span>(fork_err)</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				err = <span class="built_in">tostring</span>(err) .. <span class="string">"\n"</span> .. <span class="built_in">tostring</span>(fork_err)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">assert</span>(succ, <span class="built_in">tostring</span>(err))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="skynet-core-callback"><a href="#skynet-core-callback" class="headerlink" title="skynet.core.callback"></a>skynet.core.callback</h3><p>这个函数，是一个导出库。<br>事实上这有两个步骤的回调。</p>
<ol>
<li>将 Lua 消息处理回调注册到 Lua 的注册表中</li>
<li>将skynet_context 服务中的回调，设置为 snlua 本身的 <code>_cb</code> 或者 <code>forward_cb</code> 函数。</li>
<li>在 <code>_cb, forward_cb</code> 中调用 Lua 的消息处理回调。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lualib-src/lua-skynet.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcallback(lua_State *L) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">	<span class="keyword">int</span> forward = lua_toboolean(L, <span class="number">2</span>);</span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TFUNCTION);</span><br><span class="line">	lua_settop(L,<span class="number">1</span>);</span><br><span class="line">	lua_rawsetp(L, LUA_REGISTRYINDEX, _cb); <span class="comment">// 将回调设置到 Lua 注册表内</span></span><br><span class="line"></span><br><span class="line">	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);</span><br><span class="line">	lua_State *gL = lua_tothread(L,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 将服务的回调设置为 _cb</span></span><br><span class="line">	<span class="keyword">if</span> (forward) &#123;</span><br><span class="line">		skynet_callback(context, gL, forward_cb); </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		skynet_callback(context, gL, _cb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_cb(struct skynet_context * context, <span class="keyword">void</span> * ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	lua_State *L = ud;</span><br><span class="line">	<span class="keyword">int</span> trace = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">int</span> top = lua_gettop(L);</span><br><span class="line">	<span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">		lua_pushcfunction(L, traceback);</span><br><span class="line">		lua_rawgetp(L, LUA_REGISTRYINDEX, _cb);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(top == <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pushvalue(L,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	lua_pushinteger(L, type);</span><br><span class="line">	lua_pushlightuserdata(L, (<span class="keyword">void</span> *)msg);</span><br><span class="line">	lua_pushinteger(L,sz);</span><br><span class="line">	lua_pushinteger(L, session);</span><br><span class="line">	lua_pushinteger(L, source);</span><br><span class="line"></span><br><span class="line">	r = lua_pcall(L, <span class="number">5</span>, <span class="number">0</span> , trace);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r == LUA_OK) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * self = skynet_command(context, <span class="string">"REG"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">switch</span> (r) &#123;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRRUN:</span><br><span class="line">		skynet_error(context, <span class="string">"lua call [%x to %s : %d msgsz = %d] error : "</span> KRED <span class="string">"%s"</span> KNRM, source , self, session, sz, lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRMEM:</span><br><span class="line">		skynet_error(context, <span class="string">"lua memory error : [%x to %s : %d]"</span>, source , self, session);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRERR:</span><br><span class="line">		skynet_error(context, <span class="string">"lua error in error : [%x to %s : %d]"</span>, source , self, session);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRGCMM:</span><br><span class="line">		skynet_error(context, <span class="string">"lua gc error : [%x to %s : %d]"</span>, source , self, session);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet-src/skynet_server.c</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_callback(struct skynet_context * context, <span class="keyword">void</span> *ud, skynet_cb cb) &#123;</span><br><span class="line">	context-&gt;cb = cb;</span><br><span class="line">	context-&gt;cb_ud = ud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，消息就传到了 Lua 中了。</p>
<h2 id="skynet-init-service"><a href="#skynet-init-service" class="headerlink" title="skynet.init_service"></a>skynet.init_service</h2><p>这个函数，来进行服务的初始化，实际上就是让 Lua 调用我们的 start 中定义的 Lua 函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.init_service</span><span class="params">(start)</span></span></span><br><span class="line">	<span class="keyword">local</span> ok, err = skynet.<span class="built_in">pcall</span>(start)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">		skynet.<span class="built_in">error</span>(<span class="string">"init service failed: "</span> .. <span class="built_in">tostring</span>(err))</span><br><span class="line">		skynet.send(<span class="string">".launcher"</span>,<span class="string">"lua"</span>, <span class="string">"ERROR"</span>)</span><br><span class="line">		skynet.<span class="built_in">exit</span>()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skynet.send(<span class="string">".launcher"</span>,<span class="string">"lua"</span>, <span class="string">"LAUNCHOK"</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里我有个疑问，launcher 服务是在 bootstrap 中启动的，然后又在这里面发消息给 launcher 不会GG 么。</p>
<h2 id="launcher-服务"><a href="#launcher-服务" class="headerlink" title=".launcher 服务"></a>.launcher 服务</h2><p>代码中，首先就执行了:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> launcher = <span class="built_in">assert</span>(skynet.launch(<span class="string">"snlua"</span>,<span class="string">"launcher"</span>))</span><br><span class="line">skynet.name(<span class="string">".launcher"</span>, launcher)</span><br></pre></td></tr></table></figure>
<p>这个就是首先启动一个 C 服务模块 <code>snlua</code>，然后以 <code>launcher</code>进行初始化。 </p>
<p><code>skynet.launch</code>定义在<code>skynet/manager.lua</code>中：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> c = <span class="built_in">require</span> <span class="string">"skynet.core"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.launch</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> addr = c.command(<span class="string">"LAUNCH"</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;,<span class="string">" "</span>))</span><br><span class="line">        <span class="keyword">if</span> addr <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">tonumber</span>(<span class="string">"0x"</span> .. <span class="built_in">string</span>.<span class="built_in">sub</span>(addr , <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其即是通过核心API 像引擎发送 <strong>LAUNCH</strong> 命令的意思。</p>
<p>其用处是用来启动一个C模块的（实例）服务，在这里，就会根据我们传入的 SNLUA 模块名，建立一个  snlua 服务，这个 snlua 服务，就会加载 launcher 所写的 Lua 服务。</p>
<p>最终返回的是一个服务地址。<br><code>skynet.name(name, add)</code>则是将一个服务地址绑定为一个别名。</p>
<h1 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h1><p>可以看到，只有第一个服务 <em>launcher</em> 是以<code>skynet.launch</code>启动，而其他服务都是以<code>pcall(skynet.newservice())</code>来启动的。如<em>.cslave, .cmaster, DATACENTER, service_mgr</em>。最后，<code>bootstrap.lua</code>服务会最后启动<code>start=</code>设置的值，默认情况下是<code>main</code>，当然我们可以设置为其他的。</p>
<p>我们看到，<code>skynet.launch</code>最终是调用的C代码进行了启动服务。而对于 <code>skynet.newservice</code>，其在<code>lualib/skynet.lua</code>中进行了定义：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.newservice</span><span class="params">(name, ...)</span></span></span><br><span class="line">        <span class="keyword">return</span> skynet.call(<span class="string">".launcher"</span>, <span class="string">"lua"</span> , <span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> p = proto[typename]</span><br><span class="line">        <span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))</span><br><span class="line">        <span class="keyword">if</span> session == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">error</span>(<span class="string">"call to invalid address "</span> .. skynet.address(addr))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>是通过向 <strong>.launcher</strong>发送消息来启动服务的。也即是说，.launcher 就是服务的启动器了。</p>
<h1 id="skynet-call"><a href="#skynet-call" class="headerlink" title="skynet.call"></a>skynet.call</h1><p>此Lua函数原型是:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其接受<em>服务地址，消息类型</em>作为参数，调用 打包函数 <code>p.pack(...)</code>打包后调用<code>c.send(addr, p.id, nil, p.pack(...))</code>发送到对应的地址。同样我们在 <code>lualib/skynet.lua</code>，预先注册了几个协议类型：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = &#123;</span><br><span class="line">        <span class="comment">-- read skynet.h</span></span><br><span class="line">        PTYPE_TEXT = <span class="number">0</span>,</span><br><span class="line">        PTYPE_RESPONSE = <span class="number">1</span>,</span><br><span class="line">        PTYPE_MULTICAST = <span class="number">2</span>,</span><br><span class="line">        PTYPE_CLIENT = <span class="number">3</span>,</span><br><span class="line">        PTYPE_SYSTEM = <span class="number">4</span>,</span><br><span class="line">        PTYPE_HARBOR = <span class="number">5</span>,</span><br><span class="line">        PTYPE_SOCKET = <span class="number">6</span>,</span><br><span class="line">        PTYPE_ERROR = <span class="number">7</span>,</span><br><span class="line">        PTYPE_QUEUE = <span class="number">8</span>,        <span class="comment">-- used in deprecated mqueue, use skynet.queue instead</span></span><br><span class="line">        PTYPE_DEBUG = <span class="number">9</span>,</span><br><span class="line">        PTYPE_LUA = <span class="number">10</span>,</span><br><span class="line">        PTYPE_SNAX = <span class="number">11</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet.pack = <span class="built_in">assert</span>(c.pack)</span><br><span class="line">skynet.packstring = <span class="built_in">assert</span>(c.packstring)</span><br><span class="line">skynet.<span class="built_in">unpack</span> = <span class="built_in">assert</span>(c.<span class="built_in">unpack</span>)</span><br><span class="line">skynet.<span class="built_in">tostring</span> = <span class="built_in">assert</span>(c.<span class="built_in">tostring</span>)</span><br><span class="line">skynet.trash = <span class="built_in">assert</span>(c.trash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> REG = skynet.register_protocol</span><br><span class="line"></span><br><span class="line">        REG &#123;</span><br><span class="line">                name = <span class="string">"lua"</span>,</span><br><span class="line">                id = skynet.PTYPE_LUA,</span><br><span class="line">                pack = skynet.pack,</span><br><span class="line">                <span class="built_in">unpack</span> = skynet.<span class="built_in">unpack</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        REG &#123;</span><br><span class="line">                name = <span class="string">"response"</span>,</span><br><span class="line">                id = skynet.PTYPE_RESPONSE,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        REG &#123;</span><br><span class="line">                name = <span class="string">"error"</span>,</span><br><span class="line">                id = skynet.PTYPE_ERROR,</span><br><span class="line">                <span class="built_in">unpack</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> <span class="keyword">return</span> ... <span class="keyword">end</span>,</span><br><span class="line">                dispatch = _error_dispatch,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>分别是 <em>lua, response, error</em> 三种协议已经是预注册的，同时其使用了对应的打包与解包函数。对于我们常用的 <em>lua</em> 类型的消息，去使用的是 <em>c.pack,  c.unpack</em> 两个函数进行消息的打包与解包。</p>
<h1 id="launcher-lua"><a href="#launcher-lua" class="headerlink" title="launcher.lua"></a>launcher.lua</h1><p>再来看看<code>launcher.lua</code>，其定义在 <code>service</code>目录下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- service/launcher.lua</span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd , ...)</span></span></span><br><span class="line">        cmd = <span class="built_in">string</span>.<span class="built_in">upper</span>(cmd)</span><br><span class="line">        <span class="keyword">local</span> f = command[cmd]</span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> ret = f(address, ...)</span><br><span class="line">                <span class="keyword">if</span> ret ~= NORET <span class="keyword">then</span></span><br><span class="line">                        skynet.ret(skynet.pack(ret))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                skynet.ret(skynet.pack &#123;<span class="string">"Unknown command"</span>&#125; )</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">launch_service</span><span class="params">(service, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> param = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;, <span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">local</span> inst = skynet.launch(service, param)</span><br><span class="line">        <span class="keyword">local</span> response = skynet.response()</span><br><span class="line">        <span class="keyword">if</span> inst <span class="keyword">then</span></span><br><span class="line">                services[inst] = service .. <span class="string">" "</span> .. param</span><br><span class="line">                instance[inst] = response</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                response(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> inst</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.LAUNCH</span><span class="params">(_, service, ...)</span></span></span><br><span class="line">        launch_service(service, ...)</span><br><span class="line">        <span class="keyword">return</span> NORET</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其首先注册了一个消息分发函数，对于 <code>LAUNCH</code>的命令，最终还是通过 <code>skynet.launch</code>来启动对应的C服务。我们来完整的看一下这个过程：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.newservice(<span class="string">"srv"</span>)</span><br><span class="line">skynet.call(<span class="string">".launcher"</span>, <span class="string">"lua"</span> , <span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, <span class="string">"srv"</span>, ...)</span><br><span class="line">c.send(<span class="string">".launcher"</span>, p.id , <span class="literal">nil</span> , p.pack(<span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, name, ...))</span><br><span class="line">command.LAUNCH(_, <span class="string">"snlua"</span>, <span class="string">"srv"</span>, ...)</span><br><span class="line">launch_service(<span class="string">"snlua"</span>, <span class="string">"srv"</span>, ...)</span><br><span class="line">skynet.launch(<span class="string">"snlua"</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;<span class="string">"srv"</span>, ...&#125;, <span class="string">" "</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>最终，还是调用了 skynet.launch 来进行启动服务。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>我们可以看到，在<code>bootstrap.lua 和 main.lua</code>中，都有类似代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> sharestring = <span class="built_in">tonumber</span>(skynet.<span class="built_in">getenv</span> <span class="string">"sharestring"</span> <span class="keyword">or</span> <span class="number">4096</span>)</span><br><span class="line">        memory.ssexpand(sharestring)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>类似的代码，其实，任何一个服务都是以<code>skynet.start(function() ... end)</code>这样的形式进行初始化的。</p>
<p>当然，其实我们在<code>main.lua</code>中，也可以通过 <code>skynet.newservice(name, ...)</code>来启动新的服务。</p>
<h1 id="消息分发与回应"><a href="#消息分发与回应" class="headerlink" title="消息分发与回应"></a>消息分发与回应</h1><p>当一个服务加载，初始化，然后就开始工作了。和大多数的服务一样，其实skynet中的服务做的事情也没有什么特别的。也就是接收消息，处理消息，给出响应这样的操作。</p>
<p>每个服务分三个运行阶段：</p>
<ul>
<li><p>首先是服务加载阶段，当服务的源文件被加载时，就会按 lua 的运行规则被执行到。这个阶段不可以调用任何有可能阻塞住该服务的 skynet api 。因为，在这个阶段中，和服务配套的 skynet 设置并没有初始化完毕。</p>
</li>
<li><p>然后是服务初始化阶段，由 skynet.start 这个 api 注册的初始化函数执行。这个初始化函数理论上可以调用任何 skynet api 了，但启动该服务的 skynet.newservice 这个 api 会一直等待到初始化函数结束才会返回。</p>
</li>
<li><p>最后是服务工作阶段，当你在初始化阶段注册了消息处理函数的话，只要有消息输入，就会触发注册的消息处理函数。这些消息都是 skynet 内部消息，外部的网络数据，定时器也会通过内部消息的形式表达出来。</p>
</li>
</ul>
<p>消息处理器，是通过函数<code>skynet.dispatch</code>来进行注册的，在多数的服务文件中都能看到类似代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> CMD = &#123;&#125;</span><br><span class="line">        skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(_, address, cmd, ...)</span></span></span><br><span class="line">                        <span class="keyword">local</span> f = CMD[cmd]</span><br><span class="line">                        <span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">                                skynet.ret(skynet.pack(f(address, ...)))</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                skynet.ret(skynet.pack(handler.command(cmd, address, ...)))</span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span>)</span><br><span class="line">        <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>如上所示代码中：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(_, address, cmd, ...)</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>就是将<strong>lua</strong>类型的消息，注册给后面的匿名函数处理，每次收到<strong>lua</strong>类型的函数时，就会调用这个函数。</p>
<p><strong>通常约定 lua 类消息的第一个元素是一个字符串，表示具体消息对应的操作</strong>。我们会在脚本中创建一个 CMD 表，把对应的操作函数定义在表中。每条 lua 消息抵达后，从 CMD 表中查到处理函数，并把余下的参数传入。这个消息的 session 和　source 可以不必传递给处理函数，因为除了主动向 source 发送类别为 “response” 的消息来回应它以外，还有更简单的方法。框架记忆了这两个值。</p>
<p>这仅仅是一个惯用法，你也可以用其它方法来处理消息。skynet 并未规定你必须怎样做。</p>
<p>每个服务最重要的功能就是处理收到的消息，并根据消息产生特定的动作。每个消息都由五个元素构成：</p>
<ul>
<li><strong>session</strong>：大部分消息工作在请求回应模式下。即，一个服务向另一个服务发起一个请求，而后收到请求的服务在处理完请求消息后，回复一条消息。session 是由发起请求的服务生成的，对它自己唯一的消息标识。回应方在回应时，将 session 带回。这样发送方才能识别出哪条消息是针对哪条的回应。session 是一个非负整数，当一条消息不需要回应时，按惯例，使用 0 这个特殊的 session 号。session 由 skynet 框架生成管理，通常不需要使用者关心。</li>
<li><strong>source</strong>：消息源。每个服务都由一个 32bit 整数标识。这个整数可以看成是服务在 skynet 系统中的地址。即使在服务退出后，新启动的服务通常也不会使用已用过的地址（除非发生回绕，但一般间隔时间非常长）。每条收到的消息都携带有 source ，方便在回应的时候可以指定地址。但地址的管理通常由框架完成，用户不用关心。</li>
<li><strong>type</strong>：消息类别。每个服务可以接收 256 种不同类别的消息。每种类别可以有不同的消息编码格式。有十几种类别是框架保留的，通常也不建议用户定义新的消息类别。因为用户完全可以利用已有的类别，而用具体的消息内容来区分每条具体的含义。框架把这些 type 映射为字符串便于记忆。最常用的消息类别名为 “lua” 广泛用于用 lua 编写的 skynet 服务间的通讯。</li>
<li><strong>messsage</strong>：消息的 C 指针，在 Lua 层看来是一个 lightuserdata 。框架会隐藏这个细节，最终用户处理的是经过解码过的 lua 对象。只有极少情况，你才需要在 lua 层直接操作这个指针。</li>
<li><strong>size</strong>：消息的长度。通常和 message 一起结合起来使用。</li>
</ul>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>有两个API可以进行消息的发送：<code>skynet.call,  skynet.send</code>。</p>
<p><code>skynet.send(address, typename, ...)</code>这条 API 可以把一条类别为 typename 的消息发送给 address 。它会先经过事先注册的 pack 函数打包 … 的内容。</p>
<p>skynet.send 是一条非阻塞 API ，发送完消息后，coroutine 会继续向下运行，这期间服务不会重入。</p>
<p><code>skynet.call(address, typename, ...)</code> 这条 API 则不同，它会在内部生成一个唯一 session ，并向 address 提起请求，并阻塞等待对 session 的回应（可以不由 address 回应）。当消息回应后，还会通过之前注册的 unpack 函数解包。表面上看起来，就是发起了一次 RPC ，并阻塞等待回应。call 不支持超时。</p>
<p>尤其需要留意的是，skynet.call 仅仅阻塞住当前的 coroutine ，而没有阻塞整个服务。在等待回应期间，服务照样可以响应其他请求。<strong>所以，尤其要注意，在 skynet.call 之前获得的服务内的状态，到返回后，很有可能改变。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gowa.club/Lua/skynet的启动与服务载入流程.html" data-id="ck2k5hiew00zsgm03tixcnbid" data-title="Skynet的启动与服务载入流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Skynet/">Skynet</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/Lua/skynet-任务调度及消息处理.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          skynet-任务调度及消息处理
        
      </div>
    </a>
  
  
    <a href="/Lua/lua中的表及面向对象.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">lua中的表及面向对象</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Android/Hooking-Linux中的共享库函数.html">Hooking-Linux中的共享库函数</a>
          </li>
        
          <li>
            <a href="/Android/Riru来注入Zygote进程.html">Riru来注入Zygote进程</a>
          </li>
        
          <li>
            <a href="/Android/Android的权限检查过程.html">Android的权限检查过程</a>
          </li>
        
          <li>
            <a href="/Android/Android的服务管理.html">Android的服务管理</a>
          </li>
        
          <li>
            <a href="/Cpp/使用Clang进行交叉编译.html">使用Clang进行交叉编译</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Asm/">Asm</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos-Creator/">Cocos Creator</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-X/">Cocos2d-X</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Device/">Device</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GTD/">GTD</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kindle/">Kindle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Unix/">Linux/Unix</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS/">macOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">25</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AWK/" style="font-size: 10px;">AWK</a> <a href="/tags/Activiti/" style="font-size: 10px;">Activiti</a> <a href="/tags/Aix/" style="font-size: 10.63px;">Aix</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Apue/" style="font-size: 11.88px;">Apue</a> <a href="/tags/Asm/" style="font-size: 11.88px;">Asm</a> <a href="/tags/Auto-js/" style="font-size: 10px;">Auto.js</a> <a href="/tags/CentOS/" style="font-size: 11.88px;">CentOS</a> <a href="/tags/Cocos-Creator/" style="font-size: 12.5px;">Cocos Creator</a> <a href="/tags/Cocos2d-X/" style="font-size: 13.13px;">Cocos2d-X</a> <a href="/tags/Cpp/" style="font-size: 11.88px;">Cpp</a> <a href="/tags/Curl/" style="font-size: 10.63px;">Curl</a> <a href="/tags/DHCP/" style="font-size: 10px;">DHCP</a> <a href="/tags/Dagger/" style="font-size: 12.5px;">Dagger</a> <a href="/tags/Device/" style="font-size: 10px;">Device</a> <a href="/tags/Docx/" style="font-size: 14.38px;">Docx</a> <a href="/tags/Docx4j/" style="font-size: 10px;">Docx4j</a> <a href="/tags/F5/" style="font-size: 10px;">F5</a> <a href="/tags/GTD/" style="font-size: 10px;">GTD</a> <a href="/tags/Git/" style="font-size: 12.5px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Golang/" style="font-size: 10.63px;">Golang</a> <a href="/tags/Gson/" style="font-size: 10.63px;">Gson</a> <a href="/tags/Hooking/" style="font-size: 10px;">Hooking</a> <a href="/tags/Iptables/" style="font-size: 10px;">Iptables</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/Java/" style="font-size: 19.38px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Kindle/" style="font-size: 10.63px;">Kindle</a> <a href="/tags/LVM/" style="font-size: 10.63px;">LVM</a> <a href="/tags/Linux/" style="font-size: 18.75px;">Linux</a> <a href="/tags/Lsyncd/" style="font-size: 10px;">Lsyncd</a> <a href="/tags/Lua/" style="font-size: 18.13px;">Lua</a> <a href="/tags/MFC/" style="font-size: 13.13px;">MFC</a> <a href="/tags/ML/" style="font-size: 10px;">ML</a> <a href="/tags/MVP/" style="font-size: 10.63px;">MVP</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MySQL/" style="font-size: 16.88px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/OSPF/" style="font-size: 10px;">OSPF</a> <a href="/tags/Oracle/" style="font-size: 14.38px;">Oracle</a> <a href="/tags/Oralce/" style="font-size: 10px;">Oralce</a> <a href="/tags/PAC/" style="font-size: 10px;">PAC</a> <a href="/tags/PIL/" style="font-size: 15.63px;">PIL</a> <a href="/tags/PPPoE/" style="font-size: 10px;">PPPoE</a> <a href="/tags/Pandas/" style="font-size: 10.63px;">Pandas</a> <a href="/tags/Php/" style="font-size: 10px;">Php</a> <a href="/tags/Poi/" style="font-size: 11.25px;">Poi</a> <a href="/tags/Pomelo/" style="font-size: 11.25px;">Pomelo</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Python/" style="font-size: 14.38px;">Python</a> <a href="/tags/REST/" style="font-size: 10px;">REST</a> <a href="/tags/Raid/" style="font-size: 10px;">Raid</a> <a href="/tags/RegEx/" style="font-size: 10px;">RegEx</a> <a href="/tags/Retrofit/" style="font-size: 11.88px;">Retrofit</a> <a href="/tags/Room/" style="font-size: 10px;">Room</a> <a href="/tags/Rsync/" style="font-size: 10px;">Rsync</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/SED/" style="font-size: 11.25px;">SED</a> <a href="/tags/SHELL/" style="font-size: 10.63px;">SHELL</a> <a href="/tags/SSH/" style="font-size: 11.25px;">SSH</a> <a href="/tags/Shell/" style="font-size: 13.13px;">Shell</a> <a href="/tags/Skynet/" style="font-size: 12.5px;">Skynet</a> <a href="/tags/So/" style="font-size: 10px;">So</a> <a href="/tags/Spring/" style="font-size: 11.25px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 11.25px;">SpringMVC</a> <a href="/tags/Sqlplus/" style="font-size: 10.63px;">Sqlplus</a> <a href="/tags/Svn/" style="font-size: 10.63px;">Svn</a> <a href="/tags/Syslog/" style="font-size: 10px;">Syslog</a> <a href="/tags/TCP-IP/" style="font-size: 12.5px;">TCP/IP</a> <a href="/tags/Tbs/" style="font-size: 10px;">Tbs</a> <a href="/tags/Tcpdump/" style="font-size: 10px;">Tcpdump</a> <a href="/tags/TensorFlow/" style="font-size: 13.75px;">TensorFlow</a> <a href="/tags/The-Java-Tutorial/" style="font-size: 13.13px;">The Java Tutorial</a> <a href="/tags/Thread/" style="font-size: 11.25px;">Thread</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/VIM/" style="font-size: 10px;">VIM</a> <a href="/tags/VNC/" style="font-size: 11.25px;">VNC</a> <a href="/tags/Vim/" style="font-size: 13.13px;">Vim</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/Windows/" style="font-size: 17.5px;">Windows</a> <a href="/tags/X5/" style="font-size: 10px;">X5</a> <a href="/tags/YCM/" style="font-size: 10px;">YCM</a> <a href="/tags/YouCompleteMe/" style="font-size: 10px;">YouCompleteMe</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/brew/" style="font-size: 11.88px;">brew</a> <a href="/tags/ffmpeg/" style="font-size: 10px;">ffmpeg</a> <a href="/tags/launchd/" style="font-size: 10px;">launchd</a> <a href="/tags/macOS/" style="font-size: 13.75px;">macOS</a> <a href="/tags/networksetup/" style="font-size: 10px;">networksetup</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/数据库/" style="font-size: 13.75px;">数据库</a> <a href="/tags/磁盘阵列/" style="font-size: 10px;">磁盘阵列</a> <a href="/tags/设备信息查看/" style="font-size: 10px;">设备信息查看</a> <a href="/tags/负载均衡/" style="font-size: 10px;">负载均衡</a> <a href="/tags/运维/" style="font-size: 17.5px;">运维</a> <a href="/tags/逆向/" style="font-size: 16.25px;">逆向</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>


  
</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Gowa2017 Zhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery-3.4.1.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>