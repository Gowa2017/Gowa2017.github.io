<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="退思园" type="application/atom+xml">
  <meta name="google-site-verification" content="EDvvZZUFkxy_QUzZTaqwsG_9VHqFthY-NhQE4j6WL-s">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'LHD9LWONQ3',
      apiKey: '23a113c49e36d8cc93f61239cb530b43',
      indexName: 'gowa.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。">
<meta name="keywords" content="Lua,Skynet">
<meta property="og:type" content="article">
<meta property="og:title" content="Skynet的启动与服务载入流程">
<meta property="og:url" content="https://gowa.club/Lua/skynet的启动与服务载入流程.html">
<meta property="og:site_name" content="退思园">
<meta property="og:description" content="一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-02-01T09:35:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skynet的启动与服务载入流程">
<meta name="twitter:description" content="一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。">

<link rel="canonical" href="https://gowa.club/Lua/skynet的启动与服务载入流程.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Skynet的启动与服务载入流程 | 退思园</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137245514-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-137245514-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">退思园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">烦恼一般都是想太多了。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-soft">

    <a href="/soft/" rel="section"><i class="fa fa-fw fa-rocket"></i>soft</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gowa.club/Lua/skynet的启动与服务载入流程.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gowa2017 Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="退思园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Skynet的启动与服务载入流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-01 17:35:39" itemprop="dateCreated datePublished" datetime="2018-02-01T17:35:39+08:00">2018-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index">
                    <span itemprop="name">Lua</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/Lua/skynet的启动与服务载入流程.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Lua/skynet的启动与服务载入流程.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一直以来很喜欢玩游戏，却一直没有自己开发过游戏，主要是不知道怎么入手。以前接触过的一款游戏就是以C++写程序，然后Lua做脚本和逻辑的。偶然间发现了skynet这个框架，作者居然是多年以前我就已经仰视已久的人物。用这个，加上客户端用cocos2dx的话，似乎确实能做出我自己想做的一些小游戏了。<br><a id="more"></a></p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>这个项目在<a href="https://github.com/cloudwu/skynet" target="_blank" rel="noopener">github.com开源</a>。是一个用于在线游戏服务器的框架，但是不仅仅用于游戏，很多其他服务端也能用到。其是基与c和lua的。其内部封装了<strong>mysql, mongodb, socket</strong>等库，用起来确实是很不错的。但是性能方面暂时不知道，但是看云风大大一直追求的性能和效率的话应该不会差。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Skynet 的单机模型来说，只有一个进程。然后把用 Lua 编写的每个业务逻辑单元叫做<em>服务</em>。所有的数据，消息的传递只在进程内部，因此的话，效率是有保证的，唯一可能出现考量的地方，就是Lua的虚拟机是否依然高效。这比传统的多进程间的通信模型就简单了许多，不需要用到什么共享内存，消息队列等了。</p>
<p>对于想启动一个服务，只需要调用<code>skynet.newservice(name)</code>，这将会返回一个服务地址，就可以了。<em>name</em>是脚本名。Skynet 会根据我们配置文件中的 <em>luaservice</em> 目录去寻找对应的 <em>name.lua</em> 文件。另外注意，类似 <code>.launcher</code> 这样的服务只是在本机可见， 在节点间是不可见的。同时我们可以用<code>skynet.name(name, addr)</code>把一个服务地址给绑定到一个别名，以后凡是用到服务地址的地方都可以使用名字。</p>
<h1 id="服务的三个阶段"><a href="#服务的三个阶段" class="headerlink" title="服务的三个阶段"></a>服务的三个阶段</h1><p>每个Lua都分为三个阶段：</p>
<ul>
<li>加载阶段。加载Lua脚本到内存，分配一个实例。</li>
<li>初始化阶段。由<code>skynet.start(function() ... end)</code>注册的初始化函数进行初始化。我们的<code>skynet.newservice(name)</code>会在这个函数执行完毕后才返回。</li>
<li>工作阶段。</li>
</ul>
<h1 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h1><p>skynet 其实有两种服务，一种是 C 服务，一种是 Lua 服务。这两者事实上没有本质的区别，止不过对于 C 服务其逻辑是用 C 中实现的，而 Lua 服务，则是用 Lua 实现了逻辑，同时，Lua 服务其实是一个承载 Lua 逻辑的 snlua 服务而已。</p>
<p>搭建一个 Lua 服务，只需要定义好其要处理的协议信息，其消息处理函数，其实就OK了。</p>
<p>就对于 skynet 引擎而言，任何服务，其都将其封装在一个 skynet_context 结构中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> * instance;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span>;</span></span><br><span class="line">        <span class="keyword">void</span> * cb_ud;</span><br><span class="line">        skynet_cb cb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">        FILE * logfile;</span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_cost;      <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">uint64_t</span> cpu_start;     <span class="comment">// in microsec</span></span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> handle;</span><br><span class="line">        <span class="keyword">int</span> session_id;</span><br><span class="line">        <span class="keyword">int</span> ref;</span><br><span class="line">        <span class="keyword">int</span> message_count;</span><br><span class="line">        <span class="keyword">bool</span> init;</span><br><span class="line">        <span class="keyword">bool</span> endless;</span><br><span class="line">        <span class="keyword">bool</span> profile;</span><br><span class="line"></span><br><span class="line">        CHECKCALLING_DECL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个上下文结构中保留了此</p>
<ul>
<li><strong>instance</strong> 服务实例的指针，实际上是一个 so 库中定义的结构。</li>
<li><strong>mod</strong> 模块地址，对应加载在 skynet 进程中的 so 库内存地址。</li>
<li><strong>cb_ud</strong> 回调是会使用到的一个数据结构，对于 Lua 服务，这将会是一个 lua_State</li>
<li><strong>skynet_cb</strong> 服务的回调 skynet_cb ，。</li>
<li><strong>queue</strong> 以及其消息队列</li>
</ul>
<p>创建一个服务，其实质，就是创建一个 skynet_context 结构而已，然后根据消息，回调此结构内的对应函数。</p>
<p>对于一个 C 服务，多会在其实例化的时候即指定其回调，而对于 Lua 服务，一般是在 Lua 中通过注册回调来实现的。</p>
<h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><p>skynet的主程序，通过类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./skynet config.lua</span><br></pre></td></tr></table></figure>
<p>这样的命令行启动。然后主程序就会读入这个配置文件，进行启动各项服务。  </p>
<p>我们先来看一下这个配置文件默认情况下是什么样的。</p>
<h2 id="config-lua"><a href="#config-lua" class="headerlink" title="config.lua"></a>config.lua</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">root = <span class="string">"./"</span></span><br><span class="line">thread = <span class="number">8</span></span><br><span class="line">logger = <span class="literal">nil</span></span><br><span class="line">harbor = <span class="number">1</span></span><br><span class="line">address = <span class="string">"127.0.0.1:2526"</span></span><br><span class="line">master = <span class="string">"127.0.0.1:2013"</span></span><br><span class="line">start = <span class="string">"main"</span>    <span class="comment">-- main script</span></span><br><span class="line">bootstrap = <span class="string">"snlua bootstrap"</span>    <span class="comment">-- The service for bootstrap</span></span><br><span class="line">standalone = <span class="string">"0.0.0.0:2013"</span></span><br><span class="line">luaservice = root..<span class="string">"service/?.lua;"</span>..root..<span class="string">"test/?.lua;"</span>..root..<span class="string">"examples/?.lua"</span></span><br><span class="line">lualoader = <span class="string">"lualib/loader.lua"</span></span><br><span class="line">snax = root..<span class="string">"examples/?.lua;"</span>..root..<span class="string">"test/?.lua"</span></span><br><span class="line"><span class="built_in">cpath</span> = root..<span class="string">"cservice/?.so"</span></span><br></pre></td></tr></table></figure>
<p>单机模型下，我们可以暂时忽略<em>address, master, standalone</em>三个字段。现在把重心放在启动的流程上面，暂时不要管多节点的情况。</p>
<ul>
<li><strong>thread</strong>：线程数，一般设置为和CPU核心数量一致</li>
<li><strong>bootstrap</strong>：启动的第一个服务及参数。<em>snlua bootstrap</em>是默认配置，说明的是以<em>bootstrap</em>参数启动<em>snlua</em>服务（ snlua 是 lua 的沙盒服务，相当于开启一个 Lua 虚拟机了），之后的所有服务都直接或间接的由这个服务启动。默认情况下，<em>bootstrap</em>服务文件位于<code>service/bootstrap.lua</code>下。指定服务文件名不需要带上<code>.lua</code>扩展名。</li>
<li><strong>cpath</strong>： 用 C 编写的服务模块的位置，通常指 cservice 下那些 .so 文件。如果你的系统的动态库不是以 .so 为后缀，需要做相应的修改。这个路径可以配置多项，以 ; 分割。</li>
<li><strong>luaservice</strong>：lua服务文件的位置。也就是说，当我们启动一个服务的时候，去哪里寻找并载入对应的文件。</li>
<li><strong>loader</strong>：用哪一段 lua 代码加载 lua 服务。通常配置为<code>lualib/loader.lua</code> ，再由这段代码解析服务名称，进一步加载 lua 代码。snlua 会将下面几个配置项取出，放在初始化好的 lua 虚拟机的全局变量中。具体可参考实现。<br>SERVICE_NAME 第一个参数，通常是服务名。<br>LUA_PATH config 文件中配置的 lua_path 。<br>LUA_CPATH config 文件中配置的 lua_cpath 。<br>LUA_PRELOAD config 文件中配置的 preload 。<br>LUA_SERVICE config 文件中配置的 luaservice 。  </li>
<li><strong>lua_path</strong>： 将添加到 package.path 中的路径，供 require 调用。</li>
<li><strong>lua_cpath</strong>： 将添加到 package.cpath 中的路径，供 require 调用</li>
</ul>
<h2 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h2><blockquote>
<p>第一个启动的服务是 logger ，它负责记录之后的服务中的 log 输出。logger 是一个简单的 C 服务， skynet_error  这个 C API 会把字符串发送给它。在 config 文件中，logger 配置项可以配置 log 输出的文件名，默认是 nil ，表示输出到标准输出。</p>
</blockquote>
<p>在 <a href="/Lua/skynet-任务调度及消息处理.html" title="skynet-任务调度及消息处理">skynet-任务调度及消息处理</a> 中我们可以看到 logger 服务的启动逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">skynet_context_new</span>(<span class="title">config</span>-&gt;<span class="title">logservice</span>, <span class="title">config</span>-&gt;<span class="title">logger</span>);</span></span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, <span class="built_in">config</span>-&gt;logservice);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet_handle_namehandle(skynet_context_handle(ctx), <span class="string">"logger"</span>);</span><br></pre></td></tr></table></figure>
<p>logger.so 这个 C 服务模块会在初始化后，即将服务的回调指定为 C 来处理，同时将其回调时候的 <strong>cb_ud</strong> 指定为实例本身。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service-src/service-logger.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">logger_cb(struct skynet_context * context, <span class="keyword">void</span> *ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">logger</span> * <span class="title">inst</span> = <span class="title">ud</span>;</span></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PTYPE_SYSTEM:</span><br><span class="line">		<span class="keyword">if</span> (inst-&gt;filename) &#123;</span><br><span class="line">			inst-&gt;handle = freopen(inst-&gt;filename, <span class="string">"a"</span>, inst-&gt;handle);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PTYPE_TEXT:</span><br><span class="line">		<span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">"[:%08x] "</span>,source);</span><br><span class="line">		fwrite(msg, sz , <span class="number">1</span>, inst-&gt;handle);</span><br><span class="line">		<span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">"\n"</span>);</span><br><span class="line">		fflush(inst-&gt;handle);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger_init(struct logger * inst, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * parm) &#123;</span><br><span class="line">	<span class="keyword">if</span> (parm) &#123;</span><br><span class="line">		inst-&gt;handle = fopen(parm,<span class="string">"w"</span>);</span><br><span class="line">		<span class="keyword">if</span> (inst-&gt;handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inst-&gt;filename = skynet_malloc(<span class="built_in">strlen</span>(parm)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(inst-&gt;filename, parm);</span><br><span class="line">		inst-&gt;<span class="built_in">close</span> = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		inst-&gt;handle = <span class="built_in">stdout</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inst-&gt;handle) &#123;</span><br><span class="line">		skynet_callback(ctx, inst, logger_cb); <span class="comment">// 设置服务回调</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="snlua"><a href="#snlua" class="headerlink" title="snlua"></a>snlua</h2><p>snlua是一个C模块的服务，在<code>cservice/snlua.so</code>下，所有的Lua服务其实都是snlua模块服务的实例，只是承载的Lua脚本不同而已。</p>
<p>我们看到， snlua 服务的初始化相对而言要麻烦很多。<br>其大体分为几步：</p>
<ol>
<li>C 部分的初始化。 当建立好一个 snlua 服务后，其会将对应的 skynet_context 注册到 skynet 中去，通过向 skynet 发送  REG 命令。</li>
<li>Lua 部分的初始化。通过向 此服务发送一个包含了要加载的脚本的第一个消息，使 snlua 进入 launch_cb 阶段。</li>
<li>在 launch_cb 中，会根据收到消息中的参数（表示要加载的 lua 脚本），然后进行初始化 Lua 服务</li>
<li>init_cb 加载脚本，并执行。我们可以来细细看看 init_cb 这个函数的内容。</li>
<li>init_cb 会使用  loader.lua 来加载，并执行我们的 Lua 服务。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">init_cb(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	lua_State *L = l-&gt;L;</span><br><span class="line">	l-&gt;ctx = ctx;</span><br><span class="line">	lua_gc(L, LUA_GCSTOP, <span class="number">0</span>);</span><br><span class="line">	lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">	lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"LUA_NOENV"</span>);</span><br><span class="line">	luaL_openlibs(L);</span><br><span class="line">	lua_pushlightuserdata(L, ctx);</span><br><span class="line">	lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>); <span class="comment">// 将服务结构 skynet_context 保存到全局注册表内</span></span><br><span class="line">	luaL_requiref(L, <span class="string">"skynet.codecache"</span>, codecache , <span class="number">0</span>);</span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *path = optstring(ctx, <span class="string">"lua_path"</span>,<span class="string">"./lualib/?.lua;./lualib/?/init.lua"</span>);</span><br><span class="line">	lua_pushstring(L, path);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_PATH"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cpath = optstring(ctx, <span class="string">"lua_cpath"</span>,<span class="string">"./luaclib/?.so"</span>);</span><br><span class="line">	lua_pushstring(L, cpath);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_CPATH"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *service = optstring(ctx, <span class="string">"luaservice"</span>, <span class="string">"./service/?.lua"</span>);</span><br><span class="line">	lua_pushstring(L, service);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_SERVICE"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *preload = skynet_command(ctx, <span class="string">"GETENV"</span>, <span class="string">"preload"</span>);</span><br><span class="line">	lua_pushstring(L, preload);</span><br><span class="line">	lua_setglobal(L, <span class="string">"LUA_PRELOAD"</span>);</span><br><span class="line"></span><br><span class="line">	lua_pushcfunction(L, traceback);</span><br><span class="line">	assert(lua_gettop(L) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> r = luaL_loadfile(L,loader); <span class="comment">// 加载 loader.lua</span></span><br><span class="line">	<span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">		skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">		report_launcher_error(ctx);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pushlstring(L, args, sz); <span class="comment">// 通过 loader.lua 来加载我们指定的脚本</span></span><br><span class="line">	r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 加载 我们的服务脚本</span></span><br><span class="line">	<span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">		skynet_error(ctx, <span class="string">"lua loader error : %s"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">		report_launcher_error(ctx);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_settop(L,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> limit = lua_tointeger(L, <span class="number">-1</span>);</span><br><span class="line">		l-&gt;mem_limit = limit;</span><br><span class="line">		skynet_error(ctx, <span class="string">"Set memory limit to %.2f M"</span>, (<span class="keyword">float</span>)limit / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">		lua_pushnil(L);</span><br><span class="line">		lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">"memlimit"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pop(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	lua_gc(L, LUA_GCRESTART, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">launch_cb(struct skynet_context * context, <span class="keyword">void</span> *ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source , <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	assert(type == <span class="number">0</span> &amp;&amp; session == <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *<span class="title">l</span> = <span class="title">ud</span>;</span></span><br><span class="line">	skynet_callback(context, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> err = init_cb(l, context, msg, sz);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		skynet_command(context, <span class="string">"EXIT"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">snlua_init(struct snlua *l, struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> * args) &#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="built_in">strlen</span>(args);</span><br><span class="line">	<span class="keyword">char</span> * tmp = skynet_malloc(sz);</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp, args, sz);</span><br><span class="line">	skynet_callback(ctx, l , launch_cb);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * self = skynet_command(ctx, <span class="string">"REG"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> handle_id = strtoul(self+<span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">	<span class="comment">// it must be first message</span></span><br><span class="line">	skynet_send(ctx, <span class="number">0</span>, handle_id, PTYPE_TAG_DONTCOPY,<span class="number">0</span>, tmp, sz);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="skynet-导出到-Lua"><a href="#skynet-导出到-Lua" class="headerlink" title="skynet 导出到 Lua"></a>skynet 导出到 Lua</h1><p>skynet 本身所提供的 API 只有基础的几个，但是在其导出的 API 上在 Lua 中又进行了很多的封装，因此看起来会有点绕的样子。</p>
<p>而且对于服务的加载，也重写了 <strong>loader.lua</strong></p>
<h2 id="skynet-core"><a href="#skynet-core" class="headerlink" title="skynet.core"></a>skynet.core</h2><p>其返回值是一个地址。这里我们看到，<code>skynet.core</code>是一个被导入的库，真实执行的就是这个库内导出的函数。在文件<code>lualib-src/lua-skynet.c</code>中，我们看到了这个函数的导出。</p>
<p>在 <a href="/Lua/PIL.17Lua中的模块与包.html" title="PIL.17Lua中的模块与包">PIL.17Lua中的模块与包</a> 中我们说到，当我们以 <code>skynet.core</code> 尝试加载一个子模块的时候，如果找不到对应的 <code>core.lua</code>，也找不到对应的 <code>core.so</code>，那么加载 C 库的最后一个搜索器就会使用 <code>skynet</code> 名称进行查找，然后调用 <code>luaopen_skynet_core</code>。这就运行我们将子模块都放到一个库文件中进行加载了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lua-skynet.c</span></span><br><span class="line">LUAMOD_API <span class="keyword">int</span></span><br><span class="line">luaopen_skynet_core(lua_State *L) &#123;</span><br><span class="line">        luaL_checkversion(L);</span><br><span class="line"></span><br><span class="line">        luaL_Reg l[] = &#123;</span><br><span class="line">                &#123; <span class="string">"send"</span> , lsend &#125;,</span><br><span class="line">                &#123; <span class="string">"genid"</span>, lgenid &#125;,</span><br><span class="line">                &#123; <span class="string">"redirect"</span>, lredirect &#125;,</span><br><span class="line">                &#123; <span class="string">"command"</span> , lcommand &#125;,</span><br><span class="line">                &#123; <span class="string">"intcommand"</span>, lintcommand &#125;,</span><br><span class="line">                &#123; <span class="string">"error"</span>, lerror &#125;,</span><br><span class="line">                &#123; <span class="string">"tostring"</span>, ltostring &#125;,</span><br><span class="line">                &#123; <span class="string">"harbor"</span>, lharbor &#125;,</span><br><span class="line">                &#123; <span class="string">"pack"</span>, luaseri_pack &#125;,</span><br><span class="line">                &#123; <span class="string">"unpack"</span>, luaseri_unpack &#125;,</span><br><span class="line">                &#123; <span class="string">"packstring"</span>, lpackstring &#125;,</span><br><span class="line">                &#123; <span class="string">"trash"</span> , ltrash &#125;,</span><br><span class="line">                &#123; <span class="string">"callback"</span>, lcallback &#125;,</span><br><span class="line">                &#123; <span class="string">"now"</span>, lnow &#125;,</span><br><span class="line">                &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        luaL_newlibtable(L, l);</span><br><span class="line"></span><br><span class="line">        lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>,-1);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> luaL_error(L, <span class="string">"Init skynet context first"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        luaL_setfuncs(L,l,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcommand(lua_State *L) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * cmd = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * result;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * parm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (lua_gettop(L) == <span class="number">2</span>) &#123;</span><br><span class="line">                parm = luaL_checkstring(L,<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = skynet_command(context, cmd, parm);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                lua_pushstring(L, result);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>skynet-src/skynet_server.c</code>中，定义了<code>skynet_command</code>函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">static struct command_func cmd_funcs[] = &#123;</span><br><span class="line">        &#123; <span class="string">"TIMEOUT"</span>, cmd_timeout &#125;,</span><br><span class="line">        &#123; <span class="string">"REG"</span>, cmd_reg &#125;,</span><br><span class="line">        &#123; <span class="string">"QUERY"</span>, cmd_query &#125;,</span><br><span class="line">        &#123; <span class="string">"NAME"</span>, cmd_name &#125;,</span><br><span class="line">        &#123; <span class="string">"EXIT"</span>, cmd_exit &#125;,</span><br><span class="line">        &#123; <span class="string">"KILL"</span>, cmd_kill &#125;,</span><br><span class="line">        &#123; <span class="string">"LAUNCH"</span>, cmd_launch &#125;,</span><br><span class="line">        &#123; <span class="string">"GETENV"</span>, cmd_getenv &#125;,</span><br><span class="line">        &#123; <span class="string">"SETENV"</span>, cmd_setenv &#125;,</span><br><span class="line">        &#123; <span class="string">"STARTTIME"</span>, cmd_starttime &#125;,</span><br><span class="line">        &#123; <span class="string">"ABORT"</span>, cmd_abort &#125;,</span><br><span class="line">        &#123; <span class="string">"MONITOR"</span>, cmd_monitor &#125;,</span><br><span class="line">        &#123; <span class="string">"STAT"</span>, cmd_stat &#125;,</span><br><span class="line">        &#123; <span class="string">"LOGON"</span>, cmd_logon &#125;,</span><br><span class="line">        &#123; <span class="string">"LOGOFF"</span>, cmd_logoff &#125;,</span><br><span class="line">        &#123; <span class="string">"SIGNAL"</span>, cmd_signal &#125;,</span><br><span class="line">        &#123; NULL, NULL &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">char</span> *</span><br><span class="line">skynet_command(struct skynet_context * context, const <span class="built_in">char</span> * cmd , const <span class="built_in">char</span> * param) &#123;</span><br><span class="line">        struct command_func * method = &amp;cmd_funcs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(method-&gt;name) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strcmp(cmd, method-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method-&gt;func(context, param);</span><br><span class="line">                &#125;</span><br><span class="line">                ++method;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const <span class="built_in">char</span> *</span><br><span class="line">cmd_launch(struct skynet_context * context, const <span class="built_in">char</span> * param) &#123;</span><br><span class="line">        size_t sz = strlen(param);</span><br><span class="line">        <span class="built_in">char</span> tmp[sz+<span class="number">1</span>];</span><br><span class="line">        strcpy(tmp,param);</span><br><span class="line">        <span class="built_in">char</span> * args = tmp;</span><br><span class="line">        <span class="built_in">char</span> * <span class="built_in">mod</span> = strsep(&amp;args, <span class="string">" \t\r\n"</span>);</span><br><span class="line">        args = strsep(&amp;args, <span class="string">"\r\n"</span>);</span><br><span class="line">        struct skynet_context * inst = skynet_context_new(<span class="built_in">mod</span>,args);</span><br><span class="line">        <span class="keyword">if</span> (inst == NULL) &#123;</span><br><span class="line">                <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                id_to_hex(context-&gt;result, inst-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> context-&gt;result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导出库"><a href="#导出库" class="headerlink" title="导出库"></a>导出库</h2><p>在 <code>lualib-src</code> 目录中，导出了很多 C 库。在这些导出库之上，又用 Lua 进行了一些封装。</p>
<p>例如，在 <code>skynet.core</code> 库之上，还封装了 <code>lualib/skynet.lua, lualib/skyet/*</code> 这些库。</p>
<p>其中与服务相关的是 <code>skynet/manager.lua</code> 进行框架（各种服务）管理。<code>skynet.lua</code> 则是 Lua 中的服务构建。</p>
<h1 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h1><p>Skynet运行的第二个服务是<code>snlua bootstrap</code>，表示启动一个<strong>snlua</strong>服务，以<code>bootstrap</code>作为参数进行初始化，<strong>snlua</strong>是lua的沙盒服务。同样，服务名<em>bootstrap</em>指定后，会根据<code>luaservice</code>配置的路径来寻找对应的<code>bootstrap.lua</code>文件并加载执行。</p>
<p>在skynet的源码文件<code>skynet-serc/skynet_start.c</code>中，有<code>bootstrap(ctx, config-&gt;bootstrap)</code>调用。</p>
<p>当前<em>bootstrap.lua</em>文件如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">"skynet"</span></span><br><span class="line"><span class="keyword">local</span> harbor = <span class="built_in">require</span> <span class="string">"skynet.harbor"</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> standalone = skynet.<span class="built_in">getenv</span> <span class="string">"standalone"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> launcher = <span class="built_in">assert</span>(skynet.launch(<span class="string">"snlua"</span>,<span class="string">"launcher"</span>))</span><br><span class="line">    skynet.name(<span class="string">".launcher"</span>, launcher)</span><br><span class="line">        <span class="keyword">local</span> harbor_id = <span class="built_in">tonumber</span>(skynet.<span class="built_in">getenv</span> <span class="string">"harbor"</span>)</span><br><span class="line">    <span class="keyword">if</span> harbor_id == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">assert</span>(standalone ==  <span class="literal">nil</span>)</span><br><span class="line">        standalone = <span class="literal">true</span></span><br><span class="line">        skynet.setenv(<span class="string">"standalone"</span>, <span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> ok, slave = <span class="built_in">pcall</span>(skynet.newservice, <span class="string">"cdummy"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">            skynet.abort()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        skynet.name(<span class="string">".slave"</span>, slave)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> standalone <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">pcall</span>(skynet.newservice,<span class="string">"cmaster"</span>) <span class="keyword">then</span></span><br><span class="line">                skynet.abort()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> ok, slave = <span class="built_in">pcall</span>(skynet.newservice, <span class="string">"cslave"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">            skynet.abort()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        skynet.name(<span class="string">".slave"</span>, slave)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> standalone <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> datacenter = skynet.newservice <span class="string">"datacenterd"</span></span><br><span class="line">        skynet.name(<span class="string">"DATACENTER"</span>, datacenter)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    skynet.newservice <span class="string">"service_mgr"</span></span><br><span class="line">    <span class="built_in">pcall</span>(skynet.newservice,skynet.<span class="built_in">getenv</span> <span class="string">"start"</span> <span class="keyword">or</span> <span class="string">"main"</span>)</span><br><span class="line">    skynet.<span class="built_in">exit</span>()</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>当 snlua 将 bootstrap 脚本加载到对应服务实例的 Lua 虚拟机中，就会以 loader.lua 来加载服务，然后进行执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = luaL_loadfile(L,loader);</span><br><span class="line"><span class="keyword">if</span> (r != LUA_OK) &#123;</span><br><span class="line">	skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">	report_launcher_error(ctx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">lua_pushlstring(L, args, sz);</span><br><span class="line">r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="服务的框架"><a href="#服务的框架" class="headerlink" title="服务的框架"></a>服务的框架</h2><p>这个函数，封装在 skynet.lua 中，感觉颇为复杂。参看 <a href="https://github.com/cloudwu/skynet/wiki/APIList" target="_blank" rel="noopener">API列表来进行解释吧</a></p>
<h2 id="skynet-start"><a href="#skynet-start" class="headerlink" title="skynet.start"></a>skynet.start</h2><p>我们通过前面的 snlua 初始化过程已经知道，这个时候， snlua 实例已经注册到了 skynet，但是其回调，协议都是没有进行定义的。这个函数，其实就是进行定义此 snlua 实例的协议及消息分发函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">	c.callback(skynet.dispatch_message) <span class="comment">-- 简单直接的将 snlua 的回调设置为 skynet.dispatch_message</span></span><br><span class="line">	init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		skynet.init_service(start_func)</span><br><span class="line">		init_thread = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.dispatch_message</span><span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> succ, err = <span class="built_in">pcall</span>(raw_dispatch_message,...)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> co = tremove(fork_queue,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> co == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">local</span> fork_succ, fork_err = <span class="built_in">pcall</span>(suspend,co,coroutine_resume(co))</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> fork_succ <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">if</span> succ <span class="keyword">then</span></span><br><span class="line">				succ = <span class="literal">false</span></span><br><span class="line">				err = <span class="built_in">tostring</span>(fork_err)</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				err = <span class="built_in">tostring</span>(err) .. <span class="string">"\n"</span> .. <span class="built_in">tostring</span>(fork_err)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">assert</span>(succ, <span class="built_in">tostring</span>(err))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="skynet-core-callback"><a href="#skynet-core-callback" class="headerlink" title="skynet.core.callback"></a>skynet.core.callback</h3><p>这个函数，是一个导出库。<br>事实上这有两个步骤的回调。</p>
<ol>
<li>将 Lua 消息处理回调注册到 Lua 的注册表中</li>
<li>将skynet_context 服务中的回调，设置为 snlua 本身的 <code>_cb</code> 或者 <code>forward_cb</code> 函数。</li>
<li>在 <code>_cb, forward_cb</code> 中调用 Lua 的消息处理回调。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lualib-src/lua-skynet.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcallback(lua_State *L) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">	<span class="keyword">int</span> forward = lua_toboolean(L, <span class="number">2</span>);</span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TFUNCTION);</span><br><span class="line">	lua_settop(L,<span class="number">1</span>);</span><br><span class="line">	lua_rawsetp(L, LUA_REGISTRYINDEX, _cb); <span class="comment">// 将回调设置到 Lua 注册表内</span></span><br><span class="line"></span><br><span class="line">	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);</span><br><span class="line">	lua_State *gL = lua_tothread(L,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 将服务的回调设置为 _cb</span></span><br><span class="line">	<span class="keyword">if</span> (forward) &#123;</span><br><span class="line">		skynet_callback(context, gL, forward_cb); </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		skynet_callback(context, gL, _cb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_cb(struct skynet_context * context, <span class="keyword">void</span> * ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	lua_State *L = ud;</span><br><span class="line">	<span class="keyword">int</span> trace = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">int</span> top = lua_gettop(L);</span><br><span class="line">	<span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">		lua_pushcfunction(L, traceback);</span><br><span class="line">		lua_rawgetp(L, LUA_REGISTRYINDEX, _cb);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(top == <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pushvalue(L,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	lua_pushinteger(L, type);</span><br><span class="line">	lua_pushlightuserdata(L, (<span class="keyword">void</span> *)msg);</span><br><span class="line">	lua_pushinteger(L,sz);</span><br><span class="line">	lua_pushinteger(L, session);</span><br><span class="line">	lua_pushinteger(L, source);</span><br><span class="line"></span><br><span class="line">	r = lua_pcall(L, <span class="number">5</span>, <span class="number">0</span> , trace);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r == LUA_OK) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * self = skynet_command(context, <span class="string">"REG"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">switch</span> (r) &#123;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRRUN:</span><br><span class="line">		skynet_error(context, <span class="string">"lua call [%x to %s : %d msgsz = %d] error : "</span> KRED <span class="string">"%s"</span> KNRM, source , self, session, sz, lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRMEM:</span><br><span class="line">		skynet_error(context, <span class="string">"lua memory error : [%x to %s : %d]"</span>, source , self, session);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRERR:</span><br><span class="line">		skynet_error(context, <span class="string">"lua error in error : [%x to %s : %d]"</span>, source , self, session);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> LUA_ERRGCMM:</span><br><span class="line">		skynet_error(context, <span class="string">"lua gc error : [%x to %s : %d]"</span>, source , self, session);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet-src/skynet_server.c</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_callback(struct skynet_context * context, <span class="keyword">void</span> *ud, skynet_cb cb) &#123;</span><br><span class="line">	context-&gt;cb = cb;</span><br><span class="line">	context-&gt;cb_ud = ud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，消息就传到了 Lua 中了。</p>
<h2 id="skynet-init-service"><a href="#skynet-init-service" class="headerlink" title="skynet.init_service"></a>skynet.init_service</h2><p>这个函数，来进行服务的初始化，实际上就是让 Lua 调用我们的 start 中定义的 Lua 函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.init_service</span><span class="params">(start)</span></span></span><br><span class="line">	<span class="keyword">local</span> ok, err = skynet.<span class="built_in">pcall</span>(start)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">		skynet.<span class="built_in">error</span>(<span class="string">"init service failed: "</span> .. <span class="built_in">tostring</span>(err))</span><br><span class="line">		skynet.send(<span class="string">".launcher"</span>,<span class="string">"lua"</span>, <span class="string">"ERROR"</span>)</span><br><span class="line">		skynet.<span class="built_in">exit</span>()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skynet.send(<span class="string">".launcher"</span>,<span class="string">"lua"</span>, <span class="string">"LAUNCHOK"</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里我有个疑问，launcher 服务是在 bootstrap 中启动的，然后又在这里面发消息给 launcher 不会GG 么。</p>
<h2 id="launcher-服务"><a href="#launcher-服务" class="headerlink" title=".launcher 服务"></a>.launcher 服务</h2><p>代码中，首先就执行了:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> launcher = <span class="built_in">assert</span>(skynet.launch(<span class="string">"snlua"</span>,<span class="string">"launcher"</span>))</span><br><span class="line">skynet.name(<span class="string">".launcher"</span>, launcher)</span><br></pre></td></tr></table></figure>
<p>这个就是首先启动一个 C 服务模块 <code>snlua</code>，然后以 <code>launcher</code>进行初始化。 </p>
<p><code>skynet.launch</code>定义在<code>skynet/manager.lua</code>中：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> c = <span class="built_in">require</span> <span class="string">"skynet.core"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.launch</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> addr = c.command(<span class="string">"LAUNCH"</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;,<span class="string">" "</span>))</span><br><span class="line">        <span class="keyword">if</span> addr <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">tonumber</span>(<span class="string">"0x"</span> .. <span class="built_in">string</span>.<span class="built_in">sub</span>(addr , <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其即是通过核心API 像引擎发送 <strong>LAUNCH</strong> 命令的意思。</p>
<p>其用处是用来启动一个C模块的（实例）服务，在这里，就会根据我们传入的 SNLUA 模块名，建立一个  snlua 服务，这个 snlua 服务，就会加载 launcher 所写的 Lua 服务。</p>
<p>最终返回的是一个服务地址。<br><code>skynet.name(name, add)</code>则是将一个服务地址绑定为一个别名。</p>
<h1 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h1><p>可以看到，只有第一个服务 <em>launcher</em> 是以<code>skynet.launch</code>启动，而其他服务都是以<code>pcall(skynet.newservice())</code>来启动的。如<em>.cslave, .cmaster, DATACENTER, service_mgr</em>。最后，<code>bootstrap.lua</code>服务会最后启动<code>start=</code>设置的值，默认情况下是<code>main</code>，当然我们可以设置为其他的。</p>
<p>我们看到，<code>skynet.launch</code>最终是调用的C代码进行了启动服务。而对于 <code>skynet.newservice</code>，其在<code>lualib/skynet.lua</code>中进行了定义：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.newservice</span><span class="params">(name, ...)</span></span></span><br><span class="line">        <span class="keyword">return</span> skynet.call(<span class="string">".launcher"</span>, <span class="string">"lua"</span> , <span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> p = proto[typename]</span><br><span class="line">        <span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))</span><br><span class="line">        <span class="keyword">if</span> session == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">error</span>(<span class="string">"call to invalid address "</span> .. skynet.address(addr))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>是通过向 <strong>.launcher</strong>发送消息来启动服务的。也即是说，.launcher 就是服务的启动器了。</p>
<h1 id="skynet-call"><a href="#skynet-call" class="headerlink" title="skynet.call"></a>skynet.call</h1><p>此Lua函数原型是:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其接受<em>服务地址，消息类型</em>作为参数，调用 打包函数 <code>p.pack(...)</code>打包后调用<code>c.send(addr, p.id, nil, p.pack(...))</code>发送到对应的地址。同样我们在 <code>lualib/skynet.lua</code>，预先注册了几个协议类型：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/skynet.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = &#123;</span><br><span class="line">        <span class="comment">-- read skynet.h</span></span><br><span class="line">        PTYPE_TEXT = <span class="number">0</span>,</span><br><span class="line">        PTYPE_RESPONSE = <span class="number">1</span>,</span><br><span class="line">        PTYPE_MULTICAST = <span class="number">2</span>,</span><br><span class="line">        PTYPE_CLIENT = <span class="number">3</span>,</span><br><span class="line">        PTYPE_SYSTEM = <span class="number">4</span>,</span><br><span class="line">        PTYPE_HARBOR = <span class="number">5</span>,</span><br><span class="line">        PTYPE_SOCKET = <span class="number">6</span>,</span><br><span class="line">        PTYPE_ERROR = <span class="number">7</span>,</span><br><span class="line">        PTYPE_QUEUE = <span class="number">8</span>,        <span class="comment">-- used in deprecated mqueue, use skynet.queue instead</span></span><br><span class="line">        PTYPE_DEBUG = <span class="number">9</span>,</span><br><span class="line">        PTYPE_LUA = <span class="number">10</span>,</span><br><span class="line">        PTYPE_SNAX = <span class="number">11</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet.pack = <span class="built_in">assert</span>(c.pack)</span><br><span class="line">skynet.packstring = <span class="built_in">assert</span>(c.packstring)</span><br><span class="line">skynet.<span class="built_in">unpack</span> = <span class="built_in">assert</span>(c.<span class="built_in">unpack</span>)</span><br><span class="line">skynet.<span class="built_in">tostring</span> = <span class="built_in">assert</span>(c.<span class="built_in">tostring</span>)</span><br><span class="line">skynet.trash = <span class="built_in">assert</span>(c.trash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> REG = skynet.register_protocol</span><br><span class="line"></span><br><span class="line">        REG &#123;</span><br><span class="line">                name = <span class="string">"lua"</span>,</span><br><span class="line">                id = skynet.PTYPE_LUA,</span><br><span class="line">                pack = skynet.pack,</span><br><span class="line">                <span class="built_in">unpack</span> = skynet.<span class="built_in">unpack</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        REG &#123;</span><br><span class="line">                name = <span class="string">"response"</span>,</span><br><span class="line">                id = skynet.PTYPE_RESPONSE,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        REG &#123;</span><br><span class="line">                name = <span class="string">"error"</span>,</span><br><span class="line">                id = skynet.PTYPE_ERROR,</span><br><span class="line">                <span class="built_in">unpack</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> <span class="keyword">return</span> ... <span class="keyword">end</span>,</span><br><span class="line">                dispatch = _error_dispatch,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>分别是 <em>lua, response, error</em> 三种协议已经是预注册的，同时其使用了对应的打包与解包函数。对于我们常用的 <em>lua</em> 类型的消息，去使用的是 <em>c.pack,  c.unpack</em> 两个函数进行消息的打包与解包。</p>
<h1 id="launcher-lua"><a href="#launcher-lua" class="headerlink" title="launcher.lua"></a>launcher.lua</h1><p>再来看看<code>launcher.lua</code>，其定义在 <code>service</code>目录下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- service/launcher.lua</span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd , ...)</span></span></span><br><span class="line">        cmd = <span class="built_in">string</span>.<span class="built_in">upper</span>(cmd)</span><br><span class="line">        <span class="keyword">local</span> f = command[cmd]</span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> ret = f(address, ...)</span><br><span class="line">                <span class="keyword">if</span> ret ~= NORET <span class="keyword">then</span></span><br><span class="line">                        skynet.ret(skynet.pack(ret))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                skynet.ret(skynet.pack &#123;<span class="string">"Unknown command"</span>&#125; )</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">launch_service</span><span class="params">(service, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> param = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;, <span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">local</span> inst = skynet.launch(service, param)</span><br><span class="line">        <span class="keyword">local</span> response = skynet.response()</span><br><span class="line">        <span class="keyword">if</span> inst <span class="keyword">then</span></span><br><span class="line">                services[inst] = service .. <span class="string">" "</span> .. param</span><br><span class="line">                instance[inst] = response</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                response(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> inst</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.LAUNCH</span><span class="params">(_, service, ...)</span></span></span><br><span class="line">        launch_service(service, ...)</span><br><span class="line">        <span class="keyword">return</span> NORET</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其首先注册了一个消息分发函数，对于 <code>LAUNCH</code>的命令，最终还是通过 <code>skynet.launch</code>来启动对应的C服务。我们来完整的看一下这个过程：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.newservice(<span class="string">"srv"</span>)</span><br><span class="line">skynet.call(<span class="string">".launcher"</span>, <span class="string">"lua"</span> , <span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, <span class="string">"srv"</span>, ...)</span><br><span class="line">c.send(<span class="string">".launcher"</span>, p.id , <span class="literal">nil</span> , p.pack(<span class="string">"LAUNCH"</span>, <span class="string">"snlua"</span>, name, ...))</span><br><span class="line">command.LAUNCH(_, <span class="string">"snlua"</span>, <span class="string">"srv"</span>, ...)</span><br><span class="line">launch_service(<span class="string">"snlua"</span>, <span class="string">"srv"</span>, ...)</span><br><span class="line">skynet.launch(<span class="string">"snlua"</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;<span class="string">"srv"</span>, ...&#125;, <span class="string">" "</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>最终，还是调用了 skynet.launch 来进行启动服务。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>我们可以看到，在<code>bootstrap.lua 和 main.lua</code>中，都有类似代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> sharestring = <span class="built_in">tonumber</span>(skynet.<span class="built_in">getenv</span> <span class="string">"sharestring"</span> <span class="keyword">or</span> <span class="number">4096</span>)</span><br><span class="line">        memory.ssexpand(sharestring)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>类似的代码，其实，任何一个服务都是以<code>skynet.start(function() ... end)</code>这样的形式进行初始化的。</p>
<p>当然，其实我们在<code>main.lua</code>中，也可以通过 <code>skynet.newservice(name, ...)</code>来启动新的服务。</p>
<h1 id="消息分发与回应"><a href="#消息分发与回应" class="headerlink" title="消息分发与回应"></a>消息分发与回应</h1><p>当一个服务加载，初始化，然后就开始工作了。和大多数的服务一样，其实skynet中的服务做的事情也没有什么特别的。也就是接收消息，处理消息，给出响应这样的操作。</p>
<p>每个服务分三个运行阶段：</p>
<ul>
<li><p>首先是服务加载阶段，当服务的源文件被加载时，就会按 lua 的运行规则被执行到。这个阶段不可以调用任何有可能阻塞住该服务的 skynet api 。因为，在这个阶段中，和服务配套的 skynet 设置并没有初始化完毕。</p>
</li>
<li><p>然后是服务初始化阶段，由 skynet.start 这个 api 注册的初始化函数执行。这个初始化函数理论上可以调用任何 skynet api 了，但启动该服务的 skynet.newservice 这个 api 会一直等待到初始化函数结束才会返回。</p>
</li>
<li><p>最后是服务工作阶段，当你在初始化阶段注册了消息处理函数的话，只要有消息输入，就会触发注册的消息处理函数。这些消息都是 skynet 内部消息，外部的网络数据，定时器也会通过内部消息的形式表达出来。</p>
</li>
</ul>
<p>消息处理器，是通过函数<code>skynet.dispatch</code>来进行注册的，在多数的服务文件中都能看到类似代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> CMD = &#123;&#125;</span><br><span class="line">        skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(_, address, cmd, ...)</span></span></span><br><span class="line">                        <span class="keyword">local</span> f = CMD[cmd]</span><br><span class="line">                        <span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">                                skynet.ret(skynet.pack(f(address, ...)))</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                skynet.ret(skynet.pack(handler.command(cmd, address, ...)))</span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span>)</span><br><span class="line">        <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>如上所示代码中：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(_, address, cmd, ...)</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>就是将<strong>lua</strong>类型的消息，注册给后面的匿名函数处理，每次收到<strong>lua</strong>类型的函数时，就会调用这个函数。</p>
<p><strong>通常约定 lua 类消息的第一个元素是一个字符串，表示具体消息对应的操作</strong>。我们会在脚本中创建一个 CMD 表，把对应的操作函数定义在表中。每条 lua 消息抵达后，从 CMD 表中查到处理函数，并把余下的参数传入。这个消息的 session 和　source 可以不必传递给处理函数，因为除了主动向 source 发送类别为 “response” 的消息来回应它以外，还有更简单的方法。框架记忆了这两个值。</p>
<p>这仅仅是一个惯用法，你也可以用其它方法来处理消息。skynet 并未规定你必须怎样做。</p>
<p>每个服务最重要的功能就是处理收到的消息，并根据消息产生特定的动作。每个消息都由五个元素构成：</p>
<ul>
<li><strong>session</strong>：大部分消息工作在请求回应模式下。即，一个服务向另一个服务发起一个请求，而后收到请求的服务在处理完请求消息后，回复一条消息。session 是由发起请求的服务生成的，对它自己唯一的消息标识。回应方在回应时，将 session 带回。这样发送方才能识别出哪条消息是针对哪条的回应。session 是一个非负整数，当一条消息不需要回应时，按惯例，使用 0 这个特殊的 session 号。session 由 skynet 框架生成管理，通常不需要使用者关心。</li>
<li><strong>source</strong>：消息源。每个服务都由一个 32bit 整数标识。这个整数可以看成是服务在 skynet 系统中的地址。即使在服务退出后，新启动的服务通常也不会使用已用过的地址（除非发生回绕，但一般间隔时间非常长）。每条收到的消息都携带有 source ，方便在回应的时候可以指定地址。但地址的管理通常由框架完成，用户不用关心。</li>
<li><strong>type</strong>：消息类别。每个服务可以接收 256 种不同类别的消息。每种类别可以有不同的消息编码格式。有十几种类别是框架保留的，通常也不建议用户定义新的消息类别。因为用户完全可以利用已有的类别，而用具体的消息内容来区分每条具体的含义。框架把这些 type 映射为字符串便于记忆。最常用的消息类别名为 “lua” 广泛用于用 lua 编写的 skynet 服务间的通讯。</li>
<li><strong>messsage</strong>：消息的 C 指针，在 Lua 层看来是一个 lightuserdata 。框架会隐藏这个细节，最终用户处理的是经过解码过的 lua 对象。只有极少情况，你才需要在 lua 层直接操作这个指针。</li>
<li><strong>size</strong>：消息的长度。通常和 message 一起结合起来使用。</li>
</ul>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>有两个API可以进行消息的发送：<code>skynet.call,  skynet.send</code>。</p>
<p><code>skynet.send(address, typename, ...)</code>这条 API 可以把一条类别为 typename 的消息发送给 address 。它会先经过事先注册的 pack 函数打包 … 的内容。</p>
<p>skynet.send 是一条非阻塞 API ，发送完消息后，coroutine 会继续向下运行，这期间服务不会重入。</p>
<p><code>skynet.call(address, typename, ...)</code> 这条 API 则不同，它会在内部生成一个唯一 session ，并向 address 提起请求，并阻塞等待对 session 的回应（可以不由 address 回应）。当消息回应后，还会通过之前注册的 unpack 函数解包。表面上看起来，就是发起了一次 RPC ，并阻塞等待回应。call 不支持超时。</p>
<p>尤其需要留意的是，skynet.call 仅仅阻塞住当前的 coroutine ，而没有阻塞整个服务。在等待回应期间，服务照样可以响应其他请求。<strong>所以，尤其要注意，在 skynet.call 之前获得的服务内的状态，到返回后，很有可能改变。</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Lua/" rel="tag"># Lua</a>
              <a href="/tags/Skynet/" rel="tag"># Skynet</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Lua/lua中的表及面向对象.html" rel="next" title="lua中的表及面向对象">
                  <i class="fa fa-chevron-left"></i> lua中的表及面向对象
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/Lua/skynet-任务调度及消息处理.html" rel="prev" title="skynet-任务调度及消息处理">
                  skynet-任务调度及消息处理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#项目"><span class="nav-number">1.</span> <span class="nav-text">项目</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务的三个阶段"><span class="nav-number">3.</span> <span class="nav-text">服务的三个阶段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务的分类"><span class="nav-number">4.</span> <span class="nav-text">服务的分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#启动过程"><span class="nav-number">5.</span> <span class="nav-text">启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#config-lua"><span class="nav-number">5.1.</span> <span class="nav-text">config.lua</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#logger"><span class="nav-number">5.2.</span> <span class="nav-text">logger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#snlua"><span class="nav-number">5.3.</span> <span class="nav-text">snlua</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skynet-导出到-Lua"><span class="nav-number">6.</span> <span class="nav-text">skynet 导出到 Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-core"><span class="nav-number">6.1.</span> <span class="nav-text">skynet.core</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导出库"><span class="nav-number">6.2.</span> <span class="nav-text">导出库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bootstrap"><span class="nav-number">7.</span> <span class="nav-text">bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务的框架"><span class="nav-number">7.1.</span> <span class="nav-text">服务的框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-start"><span class="nav-number">7.2.</span> <span class="nav-text">skynet.start</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#skynet-core-callback"><span class="nav-number">7.2.1.</span> <span class="nav-text">skynet.core.callback</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#skynet-init-service"><span class="nav-number">7.3.</span> <span class="nav-text">skynet.init_service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#launcher-服务"><span class="nav-number">7.4.</span> <span class="nav-text">.launcher 服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不同"><span class="nav-number">8.</span> <span class="nav-text">不同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skynet-call"><span class="nav-number">9.</span> <span class="nav-text">skynet.call</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#launcher-lua"><span class="nav-number">10.</span> <span class="nav-text">launcher.lua</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化"><span class="nav-number">11.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息分发与回应"><span class="nav-number">12.</span> <span class="nav-text">消息分发与回应</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息发送"><span class="nav-number">13.</span> <span class="nav-text">消息发送</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gowa2017 Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">315</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">132</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gowa2017" title="GitHub → https://github.com/gowa2017" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shouzheng.zhang@gmail.com" title="E-Mail → mailto:shouzheng.zhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-json"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gowa2017 Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>














  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gowa-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://gowa.club/Lua/skynet的启动与服务载入流程.html",
            identifier: "Lua/skynet的启动与服务载入流程.html",
            title: "Skynet的启动与服务载入流程"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gowa-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
</script>

</body>
</html>
