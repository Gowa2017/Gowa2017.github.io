<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>skynet中的网络服务与消息处理 | 退思园</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">skynet中的网络服务与消息处理</h1><a id="logo" href="/.">退思园</a><p class="description">烦恼一般都是想太多了。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/soft"><i class="fa fa-rss"> soft</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">skynet中的网络服务与消息处理</h1><div class="post-meta"><a href="/Lua/skynet中的网络服务与消息处理.html#comments" class="comment-count"><i data-disqus-identifier="Lua/skynet中的网络服务与消息处理.html" class="disqus-comment-count"></i>留言</a><p><span class="date">Feb 13, 2018</span><span><a href="/categories/Lua/" class="category">Lua</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>网络信息与普通消息的封装似乎有所不同，所以关注一下这个过程是非常的有必要的。我们先从网络服务的注册开始说起。skynet封装了一个socket库作为Lua模块来给我们使用。我们可以看一下对于一个socket的注册是怎么样的。</p>
<a id="more"></a>
<h1 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h1><ol>
<li>注册网络服务时调用 <code>socketdriver:listen(address, port)</code>;</li>
<li>调用C库函数 <code>llisten</code>，获取 每个 Lua State中保存的 服务结构 <em>ctx</em>，其是通过存储为上值实现的。然后调用<code>skynet_socket_listen(ctx, host, port, backlog)</code>;</li>
<li><code>skynet_socket_listen(ctx, host, port, backlog)</code>中，根据 <em>ctx</em> 获得服务的 <em>handle</em>，然后调用<code>socket_server_listen(SOCKET_SERVER, handle, host, port, backlog)</code></li>
<li><code>socket_server_listen</code> 会获取一个<em>handle</em>，全局未使用的代表网络服务结构的id，及监听套接字 fd，构造一个请求发送给 <em>SOCKET_SERVER</em>。<code>send_request(ss, &amp;request, &#39;L&#39;, sizeof(request.u.listen));</code> 并返回网络服务id;</li>
<li>第四步的操作，其实就把请求发送到了 <em>SOCKET_SERVER</em>监听的管道中。</li>
</ol>
<h2 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h2><ol>
<li><code>thread_socket</code>工作线程会监听所有的套接字接控制管理消息。具体是在<code>skynet_socket_poll</code>工作；</li>
<li><code>skynet_socket_poll</code>会调用 <code>socket_server_poll</code>获得取到的消息类型及消息体，然后根据返回的消息类型，转发消息<code>forward_message</code>。</li>
<li><p><code>skynet_socket_poll</code>是一个非常重要的函数。其做了两个工作：</p>
<ol>
<li>如果有控制命令，就是在管道中有消息。则会调用 <code>ctrl_cmd</code>进行对应的操作。比如开启、监听、绑定、关闭、打开一个套接字。  </li>
<li>或者根据 epoll_wait 返回的事件，来进行操作。如果是读事件，获取事件的 socket结构，调用<code>forward_message_tcp(ss, s, &amp;l, result);</code>进行转发tcp消息。同样会返回一个消息体。</li>
</ol>
</li>
<li><p><code>forward_message</code>根据消息体中的 <em>handle</em>，把消息push到对应的 <em>ctx</em> 中的消息队列中。</p>
</li>
<li>工作线程会轮流取消息后，调用服务注册的对应回调函数进行处理。</li>
</ol>
<h1 id="gateserver"><a href="#gateserver" class="headerlink" title="gateserver"></a>gateserver</h1><p>在 <code>lualib/snax/gateserver.lua</code>中有绑定套接字的代码存在:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lualib/snax/gateserver.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> socketdriver = <span class="built_in">require</span> <span class="string">"skynet.socketdriver"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gateserver.start</span><span class="params">(handler)</span></span></span><br><span class="line">        <span class="built_in">assert</span>(handler.message)</span><br><span class="line">        <span class="built_in">assert</span>(handler.connect)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">CMD.open</span><span class="params">( source, conf )</span></span></span><br><span class="line">                <span class="built_in">assert</span>(<span class="keyword">not</span> socket)</span><br><span class="line">                <span class="keyword">local</span> address = conf.address <span class="keyword">or</span> <span class="string">"0.0.0.0"</span></span><br><span class="line">                <span class="keyword">local</span> port = <span class="built_in">assert</span>(conf.port)</span><br><span class="line">                maxclient = conf.maxclient <span class="keyword">or</span> <span class="number">1024</span></span><br><span class="line">                nodelay = conf.nodelay</span><br><span class="line">                skynet.<span class="built_in">error</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"Listen on %s:%d"</span>, address, port))</span><br><span class="line">                socket = socketdriver.listen(address, port)</span><br><span class="line">                socketdriver.start(socket)</span><br><span class="line">                <span class="keyword">if</span> handler.<span class="built_in">open</span> <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">return</span> handler.<span class="built_in">open</span>(source, conf)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>这是一个作为C库加载的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// lualib-src/lua-socket.c</span></span><br><span class="line">LUAMOD_API <span class="keyword">int</span></span><br><span class="line">luaopen_skynet_socketdriver(lua_State *L) &#123;</span><br><span class="line">        luaL_checkversion(L);</span><br><span class="line">        luaL_Reg l[] = &#123;</span><br><span class="line">                &#123; <span class="string">"buffer"</span>, lnewbuffer &#125;,</span><br><span class="line">                &#123; <span class="string">"push"</span>, lpushbuffer &#125;,</span><br><span class="line">                &#123; <span class="string">"pop"</span>, lpopbuffer &#125;,</span><br><span class="line">                &#123; <span class="string">"drop"</span>, ldrop &#125;,</span><br><span class="line">                &#123; <span class="string">"readall"</span>, lreadall &#125;,</span><br><span class="line">                &#123; <span class="string">"clear"</span>, lclearbuffer &#125;,</span><br><span class="line">                &#123; <span class="string">"readline"</span>, lreadline &#125;,</span><br><span class="line">                &#123; <span class="string">"str2p"</span>, lstr2p &#125;,</span><br><span class="line">                &#123; <span class="string">"header"</span>, lheader &#125;,</span><br><span class="line"></span><br><span class="line">                &#123; <span class="string">"unpack"</span>, lunpack &#125;,</span><br><span class="line">                &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        luaL_newlib(L,l);</span><br><span class="line">        luaL_Reg l2[] = &#123;</span><br><span class="line">                &#123; <span class="string">"connect"</span>, lconnect &#125;,</span><br><span class="line">                &#123; <span class="string">"close"</span>, lclose &#125;,</span><br><span class="line">                &#123; <span class="string">"shutdown"</span>, lshutdown &#125;,</span><br><span class="line">                &#123; <span class="string">"listen"</span>, llisten &#125;,</span><br><span class="line">                &#123; <span class="string">"send"</span>, lsend &#125;,</span><br><span class="line">                &#123; <span class="string">"lsend"</span>, lsendlow &#125;,</span><br><span class="line">                &#123; <span class="string">"bind"</span>, lbind &#125;,</span><br><span class="line">                &#123; <span class="string">"start"</span>, lstart &#125;,</span><br><span class="line">                &#123; <span class="string">"nodelay"</span>, lnodelay &#125;,</span><br><span class="line">                &#123; <span class="string">"udp"</span>, ludp &#125;,</span><br><span class="line">                &#123; <span class="string">"udp_connect"</span>, ludp_connect &#125;,</span><br><span class="line">                &#123; <span class="string">"udp_send"</span>, ludp_send &#125;,</span><br><span class="line">                &#123; <span class="string">"udp_address"</span>, ludp_address &#125;,</span><br><span class="line">                &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">"skynet_context"</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>,-1);</span></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> luaL_error(L, <span class="string">"Init skynet context first"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        luaL_setfuncs(L,l2,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="socketdriver-listen"><a href="#socketdriver-listen" class="headerlink" title="socketdriver.listen"></a>socketdriver.listen</h1><p><code>socketdriver.listen</code>其实加载的是库中的C函数<code>llisten</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lualib/lua-socket.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过把 host,port 压入Lua，然后进行处理 </span></span><br><span class="line"><span class="comment">// 返回的是一个代表 一个skynet socket结构的id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">llisten(lua_State *L) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * host = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> port = luaL_checkinteger(L,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> backlog = luaL_optinteger(L,<span class="number">3</span>,BACKLOG);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">        <span class="keyword">int</span> id = skynet_socket_listen(ctx, host,port,backlog);</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> luaL_error(L, <span class="string">"Listen error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lua_pushinteger(L,id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lstart(lua_State *L) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">        <span class="keyword">int</span> id = luaL_checkinteger(L, <span class="number">1</span>);</span><br><span class="line">        skynet_socket_start(ctx,id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="skynet-socket-listen"><a href="#skynet-socket-listen" class="headerlink" title="skynet_socket_listen"></a>skynet_socket_listen</h1><p>通过Lua中的上值来确定 <em>ctx</em> 结构，然后调用<br><code>skynet_socket_listen</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/skynet_socket.c</span></span><br><span class="line">skynet_socket_listen(struct skynet_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">int</span> port, <span class="keyword">int</span> backlog) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> source = skynet_context_handle(ctx);</span><br><span class="line">        <span class="keyword">return</span> socket_server_listen(SOCKET_SERVER, source, host, port, backlog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会获取 <em>ctx</em> 结构的 handle，然后传递给 <code>socket_server_listen</code>。</p>
<h1 id="socket-server-listen"><a href="#socket-server-listen" class="headerlink" title="socket_server_listen"></a>socket_server_listen</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/socket_server.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">socket_server_listen(struct socket_server *ss, <span class="keyword">uintptr_t</span> opaque, <span class="keyword">const</span> <span class="keyword">char</span> * addr, <span class="keyword">int</span> port, <span class="keyword">int</span> backlog) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = do_listen(addr, port, backlog);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_package</span> <span class="title">request</span>;</span></span><br><span class="line">        <span class="keyword">int</span> id = reserve_id(ss);</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        request.u.listen.opaque = opaque;</span><br><span class="line">        request.u.listen.id = id;</span><br><span class="line">        request.u.listen.fd = fd;</span><br><span class="line">        send_request(ss, &amp;request, <span class="string">'L'</span>, <span class="keyword">sizeof</span>(request.u.listen));</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">reserve_id(struct socket_server *ss) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAX_SOCKET;i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = ATOM_INC(&amp;(ss-&gt;alloc_id));</span><br><span class="line">                <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        id = ATOM_AND(&amp;(ss-&gt;alloc_id), <span class="number">0x7fffffff</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">slot</span>[<span class="title">HASH_ID</span>(<span class="title">id</span>)];</span></span><br><span class="line">                <span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_INVALID) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ATOM_CAS(&amp;s-&gt;type, SOCKET_TYPE_INVALID, SOCKET_TYPE_RESERVE)) &#123;</span><br><span class="line">                                s-&gt;id = id;</span><br><span class="line">                                s-&gt;protocol = PROTOCOL_UNKNOWN;</span><br><span class="line">                                <span class="comment">// socket_server_udp_connect may inc s-&gt;udpconncting directly (from other thread, before new_fd),</span></span><br><span class="line">                                <span class="comment">// so reset it to 0 here rather than in new_fd.</span></span><br><span class="line">                                s-&gt;udpconnecting = <span class="number">0</span>;</span><br><span class="line">                                s-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">                                <span class="keyword">return</span> id;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// retry</span></span><br><span class="line">                                --i;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其首先通过 <code>do_listen</code>获得socket套接字的 文件描述符，然后再通过 <code>reserve_id</code>获得一个代表全局 网络服务的id，把这两者写到一个请求包内，发送到 <em>SOCKET_SERVER</em>去。</p>
<h1 id="send-request"><a href="#send-request" class="headerlink" title="send_request"></a>send_request</h1><p>信息的发送是通过<code>send_request(ss, &amp;request, &#39;L&#39;, sizeof(request.u.listen));</code>发送一个<code>L</code>类型的请求消息到 <em>SOCKET_SERVER</em>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// skynet-src/socket_server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_package</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> header[<span class="number">8</span>];      <span class="comment">// 6 bytes dummy</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_open</span> <span class="title">open</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_send</span> <span class="title">send</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_send_udp</span> <span class="title">send_udp</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_close</span> <span class="title">close</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_listen</span> <span class="title">listen</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_bind</span> <span class="title">bind</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_start</span> <span class="title">start</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_setopt</span> <span class="title">setopt</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_udp</span> <span class="title">udp</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_setudp</span> <span class="title">set_udp</span>;</span></span><br><span class="line">        &#125; u;</span><br><span class="line">        <span class="keyword">uint8_t</span> dummy[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">send_request(struct socket_server *ss, struct request_package *request, <span class="keyword">char</span> type, <span class="keyword">int</span> len) &#123;</span><br><span class="line">		<span class="comment">// 这两个header字段存储了 请求的类型 和 消息的长度</span></span><br><span class="line">        request-&gt;header[<span class="number">6</span>] = (<span class="keyword">uint8_t</span>)type;</span><br><span class="line">        request-&gt;header[<span class="number">7</span>] = (<span class="keyword">uint8_t</span>)len;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">ssize_t</span> n = write(ss-&gt;sendctrl_fd, &amp;request-&gt;header[<span class="number">6</span>], len+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server : send ctrl command error %s.\n"</span>, strerror(errno));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                assert(n == len+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，是把相应的数据写到 全局服务器 <em>SOCKET_SERVER</em>中建立的管道的写端。skynet 的<em>socket</em>线程会每次监听对应的事件，优先读取管道中的数据。</p>
<p><code>request_package</code>是一个联合，用了封装了所有类型的请求消息。</p>
<h1 id="thread-socket-线程"><a href="#thread-socket-线程" class="headerlink" title="thread_socket 线程"></a>thread_socket 线程</h1><p>这个线程会读取所有的网络消息，并转交到对应的消息队列中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/skyent_start.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">thread_socket(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> * <span class="title">m</span> = <span class="title">p</span>;</span></span><br><span class="line">        skynet_initthread(THREAD_SOCKET);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = skynet_socket_poll();</span><br><span class="line">                <span class="keyword">if</span> (r==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                        CHECK_ABORT</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup(m,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="skynet-socket-poll"><a href="#skynet-socket-poll" class="headerlink" title="skynet_socket_poll"></a>skynet_socket_poll</h1><p>此函数会根据得到的消息类型，然后进行转发：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/skynet_start.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_socket_poll() &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> = <span class="title">SOCKET_SERVER</span>;</span></span><br><span class="line">        assert(ss);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_message</span> <span class="title">result</span>;</span></span><br><span class="line">        <span class="keyword">int</span> more = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> type = socket_server_poll(ss, &amp;result, &amp;more);</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_EXIT:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_DATA:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_DATA, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_CLOSE:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_CLOSE, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_OPEN:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_CONNECT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_ERR:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_ERROR, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_ACCEPT:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_ACCEPT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_UDP:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_UDP, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOCKET_WARNING:</span><br><span class="line">                forward_message(SKYNET_SOCKET_TYPE_WARNING, <span class="literal">false</span>, &amp;result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                skynet_error(<span class="literal">NULL</span>, <span class="string">"Unknown socket message type %d."</span>,type);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="socket-server-poll"><a href="#socket-server-poll" class="headerlink" title="socket_server_poll"></a>socket_server_poll</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/sokcet_server.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">socket_server_poll(struct socket_server *ss, struct socket_message * result, <span class="keyword">int</span> * more) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        			<span class="comment">// 是否检查控制命令，也就是说对应的管道有无套接字服务的请求</span></span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;checkctrl) &#123;</span><br><span class="line">                			<span class="comment">// 管道内有无请求？</span></span><br><span class="line">                        <span class="keyword">if</span> (has_cmd(ss)) &#123;</span><br><span class="line">                        			<span class="comment">// 获取请求类型和结果</span></span><br><span class="line">                                <span class="keyword">int</span> type = ctrl_cmd(ss, result);</span><br><span class="line">                                <span class="keyword">if</span> (type != <span class="number">-1</span>) &#123;</span><br><span class="line">                                        clear_closed_event(ss, result, type);</span><br><span class="line">                                        <span class="keyword">return</span> type;</span><br><span class="line">                                &#125; <span class="keyword">else</span></span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ss-&gt;checkctrl = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;event_index == ss-&gt;event_n) &#123;</span><br><span class="line">                        ss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);</span><br><span class="line">                        ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                                *more = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ss-&gt;event_n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">ev</span>[<span class="title">ss</span>-&gt;<span class="title">event_index</span>++];</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = <span class="title">e</span>-&gt;<span class="title">s</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="comment">// dispatch pipe message at beginning</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">                socket_lock_init(s, &amp;l);</span><br><span class="line">                <span class="keyword">switch</span> (s-&gt;type) &#123;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_CONNECTING:</span><br><span class="line">                        <span class="keyword">return</span> report_connect(ss, s, &amp;l, result);</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_LISTEN: &#123;</span><br><span class="line">                        <span class="keyword">int</span> ok = report_accept(ss, s, result);</span><br><span class="line">                        <span class="keyword">if</span> (ok &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ACCEPT;</span><br><span class="line">                        &#125; <span class="keyword">if</span> (ok &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// when ok == 0, retry</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_INVALID:</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: invalid socket\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;read) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type;</span><br><span class="line">                                <span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">                                        type = forward_message_tcp(ss, s, &amp;l, result);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        type = forward_message_udp(ss, s, &amp;l, result);</span><br><span class="line">                                        <span class="keyword">if</span> (type == SOCKET_UDP) &#123;</span><br><span class="line">                                                <span class="comment">// try read again</span></span><br><span class="line">                                                --ss-&gt;event_index;</span><br><span class="line">                                                <span class="keyword">return</span> SOCKET_UDP;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (e-&gt;write &amp;&amp; type != SOCKET_CLOSE &amp;&amp; type != SOCKET_ERR) &#123;</span><br><span class="line">                                        <span class="comment">// Try to dispatch write message next step if write flag set.</span></span><br><span class="line">                                        e-&gt;read = <span class="literal">false</span>;</span><br><span class="line">                                        --ss-&gt;event_index;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;write) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type = send_buffer(ss, s, &amp;l, result);</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;error) &#123;</span><br><span class="line">                                <span class="comment">// close when error</span></span><br><span class="line">                                <span class="keyword">int</span> error;</span><br><span class="line">                                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">                                <span class="keyword">int</span> code = getsockopt(s-&gt;fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span> * err = <span class="literal">NULL</span>;</span><br><span class="line">                                <span class="keyword">if</span> (code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(errno);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(error);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        err = <span class="string">"Unknown error"</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                force_close(ss, s, &amp;l, result);</span><br><span class="line">                                result-&gt;data = (<span class="keyword">char</span> *)err;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ctrl_cmd(ss, result);</span><br><span class="line">```c</span><br><span class="line"><span class="comment">// skynet-src/socket_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return type</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">ctrl_cmd(struct socket_server *ss, struct socket_message *result) &#123;</span><br><span class="line">			<span class="comment">// 控制管道读端</span></span><br><span class="line">        <span class="keyword">int</span> fd = ss-&gt;recvctrl_fd;</span><br><span class="line">        <span class="comment">// the length of message is one byte, so 256+8 buffer size is enough.</span></span><br><span class="line">        <span class="keyword">uint8_t</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">uint8_t</span> header[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 读请求的前两字节 （type, len)</span></span><br><span class="line">        block_readpipe(fd, header, <span class="keyword">sizeof</span>(header));</span><br><span class="line">        <span class="keyword">int</span> type = header[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = header[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 读请求内容</span></span><br><span class="line">        block_readpipe(fd, buffer, len);</span><br><span class="line">        <span class="comment">// ctrl command only exist in local fd, so don't worry about endian.</span></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                <span class="keyword">return</span> start_socket(ss,(struct request_start *)buffer, result);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">                <span class="keyword">return</span> bind_socket(ss,(struct request_bind *)buffer, result);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                <span class="keyword">return</span> listen_socket(ss,(struct request_listen *)buffer, result);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'K'</span>:</span><br><span class="line">                <span class="keyword">return</span> close_socket(ss,(struct request_close *)buffer, result);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">                <span class="keyword">return</span> open_socket(ss, (struct request_open *)buffer, result);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">                result-&gt;opaque = <span class="number">0</span>;</span><br><span class="line">                result-&gt;id = <span class="number">0</span>;</span><br><span class="line">                result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">                result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> SOCKET_EXIT;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'P'</span>: &#123;</span><br><span class="line">                <span class="keyword">int</span> priority = (type == <span class="string">'D'</span>) ? PRIORITY_HIGH : PRIORITY_LOW;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_send</span> * <span class="title">request</span> = (<span class="title">struct</span> <span class="title">request_send</span> *) <span class="title">buffer</span>;</span></span><br><span class="line">                <span class="keyword">int</span> ret = send_socket(ss, request, result, priority, <span class="literal">NULL</span>);</span><br><span class="line">                dec_sending_ref(ss, request-&gt;id);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>: &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request_send_udp</span> * <span class="title">rsu</span> = (<span class="title">struct</span> <span class="title">request_send_udp</span> *)<span class="title">buffer</span>;</span></span><br><span class="line">                <span class="keyword">return</span> send_socket(ss, &amp;rsu-&gt;send, result, PRIORITY_HIGH, rsu-&gt;address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                <span class="keyword">return</span> set_udp_address(ss, (struct request_setudp *)buffer, result);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">                setopt_socket(ss, (struct request_setopt *)buffer);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                add_udp_socket(ss, (struct request_udp *)buffer);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: Unknown ctrl %c.\n"</span>,type);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">```                                                                </span><br><span class="line">我们在 `send_request`中发送的是 `L`类型的消息，所以返回的是`listen_socket(ss,(struct request_listen *)buffer, result);`</span><br><span class="line"></span><br><span class="line">## listen_socket</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">// skynet-src/socket_server.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">listen_socket(struct socket_server *ss, struct request_listen * request, struct socket_message *result) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = request-&gt;id;</span><br><span class="line">        <span class="keyword">int</span> listen_fd = request-&gt;fd;</span><br><span class="line">        <span class="comment">// 获取一个 socket结构，此结构会放在全局服务 SOCKET_SERVER中</span></span><br><span class="line">       </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = <span class="title">new_fd</span>(<span class="title">ss</span>, <span class="title">id</span>, <span class="title">listen_fd</span>, <span class="title">PROTOCOL_TCP</span>, <span class="title">request</span>-&gt;<span class="title">opaque</span>, <span class="title">false</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> _failed;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;type = SOCKET_TYPE_PLISTEN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">_failed:</span><br><span class="line">        close(listen_fd);</span><br><span class="line">        result-&gt;opaque = request-&gt;opaque;</span><br><span class="line">        result-&gt;id = id;</span><br><span class="line">        result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">        result-&gt;data = <span class="string">"reach skynet socket number limit"</span>;</span><br><span class="line">        ss-&gt;slot[HASH_ID(id)].type = SOCKET_TYPE_INVALID;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个参数，代表是否要把这个套接字放到 epoll 的监听中去，现在listen阶段不需要加入，在start阶段才会加入</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *</span></span><br><span class="line"><span class="class"><span class="title">new_fd</span>(<span class="title">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span>, <span class="title">int</span> <span class="title">id</span>, <span class="title">int</span> <span class="title">fd</span>, <span class="title">int</span> <span class="title">protocol</span>, <span class="title">uintptr_t</span> <span class="title">opaque</span>, <span class="title">bool</span> <span class="title">add</span>) &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">s</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">slot</span>[<span class="title">HASH_ID</span>(<span class="title">id</span>)];</span></span><br><span class="line">        assert(s-&gt;type == SOCKET_TYPE_RESERVE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sp_add(ss-&gt;event_fd, fd, s)) &#123;</span><br><span class="line">                        s-&gt;type = SOCKET_TYPE_INVALID;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;id = id;</span><br><span class="line">        s-&gt;fd = fd;</span><br><span class="line">        s-&gt;sending = ID_TAG16(id) &lt;&lt; <span class="number">16</span> | <span class="number">0</span>;</span><br><span class="line">        s-&gt;protocol = protocol;</span><br><span class="line">        s-&gt;p.size = MIN_READ_BUFFER;</span><br><span class="line">        s-&gt;opaque = opaque;</span><br><span class="line">        s-&gt;wb_size = <span class="number">0</span>;</span><br><span class="line">        s-&gt;warn_size = <span class="number">0</span>;</span><br><span class="line">        check_wb_list(&amp;s-&gt;high);</span><br><span class="line">        check_wb_list(&amp;s-&gt;low);</span><br><span class="line">        spinlock_init(&amp;s-&gt;dw_lock);</span><br><span class="line">        s-&gt;dw_buffer = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;dw_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="start-socket"><a href="#start-socket" class="headerlink" title="start_socket"></a>start_socket</h2><p>调用<code>start_socket(ss,(struct request_start *)buffer, result);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">start_socket(struct socket_server *ss, struct request_start *request, struct socket_message *result) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = request-&gt;id;</span><br><span class="line">        result-&gt;id = id;</span><br><span class="line">        result-&gt;opaque = request-&gt;opaque;</span><br><span class="line">        result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">        result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">slot</span>[<span class="title">HASH_ID</span>(<span class="title">id</span>)];</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_INVALID || s-&gt;id !=id) &#123;</span><br><span class="line">                result-&gt;data = <span class="string">"invalid socket"</span>;</span><br><span class="line">                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">        socket_lock_init(s, &amp;l);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_PACCEPT || s-&gt;type == SOCKET_TYPE_PLISTEN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sp_add(ss-&gt;event_fd, s-&gt;fd, s)) &#123;</span><br><span class="line">                        force_close(ss, s, &amp;l, result);</span><br><span class="line">                        result-&gt;data = strerror(errno);</span><br><span class="line">                        <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                &#125;</span><br><span class="line">                s-&gt;type = (s-&gt;type == SOCKET_TYPE_PACCEPT) ? SOCKET_TYPE_CONNECTED : SOCKET_TYPE_LISTEN;</span><br><span class="line">                s-&gt;opaque = request-&gt;opaque;</span><br><span class="line">                result-&gt;data = <span class="string">"start"</span>;</span><br><span class="line">                <span class="keyword">return</span> SOCKET_OPEN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_CONNECTED) &#123;</span><br><span class="line">                <span class="comment">// todo: maybe we should send a message SOCKET_TRANSFER to s-&gt;opaque</span></span><br><span class="line">                s-&gt;opaque = request-&gt;opaque;</span><br><span class="line">                result-&gt;data = <span class="string">"transfer"</span>;</span><br><span class="line">                <span class="keyword">return</span> SOCKET_OPEN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if s-&gt;type == SOCKET_TYPE_HALFCLOSE , SOCKET_CLOSE message will send later</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="socket中的普通事件"><a href="#socket中的普通事件" class="headerlink" title="socket中的普通事件"></a>socket中的普通事件</h2><p>多数时候我们更关注的时从外部来的网络数据。</p>
<p>其基本流程就是，通过 epoll全局服务中的套接字，对应的事件触发操作。然后获取一个 <code>socket</code>结构，根据返回结构的事件来转发消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/socket_server.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">socket_server_poll(struct socket_server *ss, struct socket_message * result, <span class="keyword">int</span> * more) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        			<span class="comment">// 是否检查控制命令，也就是说对应的管道有无套接字服务的请求</span></span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;checkctrl) &#123;</span><br><span class="line">                			<span class="comment">// 管道内有无请求？</span></span><br><span class="line">                        <span class="keyword">if</span> (has_cmd(ss)) &#123;</span><br><span class="line">                        			<span class="comment">// 获取请求类型和结果</span></span><br><span class="line">                                <span class="keyword">int</span> type = ctrl_cmd(ss, result);</span><br><span class="line">                                <span class="keyword">if</span> (type != <span class="number">-1</span>) &#123;</span><br><span class="line">                                        clear_closed_event(ss, result, type);</span><br><span class="line">                                        <span class="keyword">return</span> type;</span><br><span class="line">                                &#125; <span class="keyword">else</span></span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ss-&gt;checkctrl = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ss-&gt;event_index == ss-&gt;event_n) &#123;</span><br><span class="line">                        ss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);</span><br><span class="line">                        ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (more) &#123;</span><br><span class="line">                                *more = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ss-&gt;event_n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> = &amp;<span class="title">ss</span>-&gt;<span class="title">ev</span>[<span class="title">ss</span>-&gt;<span class="title">event_index</span>++];</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> = <span class="title">e</span>-&gt;<span class="title">s</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="comment">// dispatch pipe message at beginning</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">                socket_lock_init(s, &amp;l);</span><br><span class="line">                <span class="keyword">switch</span> (s-&gt;type) &#123;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_CONNECTING:</span><br><span class="line">                        <span class="keyword">return</span> report_connect(ss, s, &amp;l, result);</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_LISTEN: &#123;</span><br><span class="line">                        <span class="keyword">int</span> ok = report_accept(ss, s, result);</span><br><span class="line">                        <span class="keyword">if</span> (ok &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ACCEPT;</span><br><span class="line">                        &#125; <span class="keyword">if</span> (ok &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// when ok == 0, retry</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> SOCKET_TYPE_INVALID:</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: invalid socket\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">// 绝大部分流程都会走到这。</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;read) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type;</span><br><span class="line">                                <span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">                                        type = forward_message_tcp(ss, s, &amp;l, result);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        type = forward_message_udp(ss, s, &amp;l, result);</span><br><span class="line">                                        <span class="keyword">if</span> (type == SOCKET_UDP) &#123;</span><br><span class="line">                                                <span class="comment">// try read again</span></span><br><span class="line">                                                --ss-&gt;event_index;</span><br><span class="line">                                                <span class="keyword">return</span> SOCKET_UDP;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (e-&gt;write &amp;&amp; type != SOCKET_CLOSE &amp;&amp; type != SOCKET_ERR) &#123;</span><br><span class="line">                                        <span class="comment">// Try to dispatch write message next step if write flag set.</span></span><br><span class="line">                                        e-&gt;read = <span class="literal">false</span>;</span><br><span class="line">                                        --ss-&gt;event_index;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;write) &#123;</span><br><span class="line">                                <span class="keyword">int</span> type = send_buffer(ss, s, &amp;l, result);</span><br><span class="line">                                <span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">return</span> type;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (e-&gt;error) &#123;</span><br><span class="line">                                <span class="comment">// close when error</span></span><br><span class="line">                                <span class="keyword">int</span> error;</span><br><span class="line">                                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">                                <span class="keyword">int</span> code = getsockopt(s-&gt;fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span> * err = <span class="literal">NULL</span>;</span><br><span class="line">                                <span class="keyword">if</span> (code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(errno);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">                                        err = strerror(error);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        err = <span class="string">"Unknown error"</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                force_close(ss, s, &amp;l, result);</span><br><span class="line">                                result-&gt;data = (<span class="keyword">char</span> *)err;</span><br><span class="line">                                <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 tcp 套接字的内容，其会进行如下的转发：</p>
<h2 id="forward-message-tcp"><a href="#forward-message-tcp" class="headerlink" title="forward_message_tcp"></a>forward_message_tcp</h2><p>根据对应的套接字结构，获得套接字，然后把消息读到缓存中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/socket_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">forward_message_tcp(struct socket_server *ss, struct socket *s, struct socket_lock *l, struct socket_message * result) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = s-&gt;p.size;</span><br><span class="line">        <span class="keyword">char</span> * buffer = MALLOC(sz);</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)read(s-&gt;fd, buffer, sz);</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                FREE(buffer);</span><br><span class="line">                <span class="keyword">switch</span>(errno) &#123;</span><br><span class="line">                <span class="keyword">case</span> EINTR:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AGAIN_WOULDBLOCK:</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket-server: EAGAIN capture.\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// close when error</span></span><br><span class="line">                        force_close(ss, s, l, result);</span><br><span class="line">                        result-&gt;data = strerror(errno);</span><br><span class="line">                        <span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">                FREE(buffer);</span><br><span class="line">                force_close(ss, s, l, result);</span><br><span class="line">                <span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_HALFCLOSE) &#123;</span><br><span class="line">                <span class="comment">// discard recv data</span></span><br><span class="line">                FREE(buffer);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == sz) &#123;</span><br><span class="line">                s-&gt;p.size *= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sz &gt; MIN_READ_BUFFER &amp;&amp; n*<span class="number">2</span> &lt; sz) &#123;</span><br><span class="line">                s-&gt;p.size /= <span class="number">2</span>;</span><br><span class="line">                s-&gt;p.size /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result-&gt;opaque = s-&gt;opaque;</span><br><span class="line">        result-&gt;id = s-&gt;id;</span><br><span class="line">        result-&gt;ud = n;</span><br><span class="line">        result-&gt;data = buffer;</span><br><span class="line">        <span class="keyword">return</span> SOCKET_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，事件 <code>SOCKET_DATA</code>和 消息 <code>result</code>返回到了主线程中。主线程会将消息进行转发。</p>
<h1 id="forward-message"><a href="#forward-message" class="headerlink" title="forward_message"></a>forward_message</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet-src/skynet_socket.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainloop thread</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forward_message(<span class="keyword">int</span> type, <span class="keyword">bool</span> padding, struct socket_message * result) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_socket_message</span> *<span class="title">sm</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(*sm);</span><br><span class="line">        <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result-&gt;data) &#123;</span><br><span class="line">                        <span class="keyword">size_t</span> msg_sz = <span class="built_in">strlen</span>(result-&gt;data);</span><br><span class="line">                        <span class="keyword">if</span> (msg_sz &gt; <span class="number">128</span>) &#123;</span><br><span class="line">                                msg_sz = <span class="number">128</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sz += msg_sz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result-&gt;data = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sm = (struct skynet_socket_message *)skynet_malloc(sz);</span><br><span class="line">        sm-&gt;type = type;</span><br><span class="line">        sm-&gt;id = result-&gt;id;</span><br><span class="line">        sm-&gt;ud = result-&gt;ud;</span><br><span class="line">        <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">                sm-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(sm+<span class="number">1</span>, result-&gt;data, sz - <span class="keyword">sizeof</span>(*sm));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sm-&gt;buffer = result-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">message</span>;</span></span><br><span class="line">        message.source = <span class="number">0</span>;</span><br><span class="line">        message.session = <span class="number">0</span>;</span><br><span class="line">        message.data = sm;</span><br><span class="line">        message.sz = sz | ((<span class="keyword">size_t</span>)PTYPE_SOCKET &lt;&lt; MESSAGE_TYPE_SHIFT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skynet_context_push((<span class="keyword">uint32_t</span>)result-&gt;opaque, &amp;message)) &#123;</span><br><span class="line">                <span class="comment">// todo: report somewhere to close socket</span></span><br><span class="line">                <span class="comment">// don't call skynet_socket_close here (It will block mainloop)</span></span><br><span class="line">                skynet_free(sm-&gt;buffer);</span><br><span class="line">                skynet_free(sm-&gt;buffer);</span><br><span class="line">                skynet_free(sm);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其最终是构造了一个消息发送到对应服务消息队列中去。  而对应服务就会根据注册的消息回调函数进行处理了。                          </p>
</div><div class="post-copyright"><blockquote><p>原文作者: Gowa2017 Zhang</p><p>原文链接: <a href="https://gowa2017.github.io/Lua/skynet中的网络服务与消息处理.html">https://gowa2017.github.io/Lua/skynet中的网络服务与消息处理.html</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Lua/">Lua</a><a href="/tags/skynet/">skynet</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/Linux-Unix/IO的阻塞与多路复用.html" class="pre">IO的阻塞与多路复用</a><a href="/Lua/skynet中服务分析(wathchdog,gate,snxa.gateserver).html" class="next">skynet中服务分析(wathchdog,gate,snxa.gateserver)</a></div><div id="comments"><div id="disqus_thread"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#服务注册流程"><span class="toc-text">服务注册流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#消息处理流程"><span class="toc-text">消息处理流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gateserver"><span class="toc-text">gateserver</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socketdriver-listen"><span class="toc-text">socketdriver.listen</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#skynet-socket-listen"><span class="toc-text">skynet_socket_listen</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket-server-listen"><span class="toc-text">socket_server_listen</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#send-request"><span class="toc-text">send_request</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#thread-socket-线程"><span class="toc-text">thread_socket 线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#skynet-socket-poll"><span class="toc-text">skynet_socket_poll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket-server-poll"><span class="toc-text">socket_server_poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#start-socket"><span class="toc-text">start_socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket中的普通事件"><span class="toc-text">socket中的普通事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forward-message-tcp"><span class="toc-text">forward_message_tcp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#forward-message"><span class="toc-text">forward_message</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Lua/PIL.15.数据文件与序列化.html">PIL.15.数据文件与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux-Unix/在安卓中进行共享库的注入.html">在安卓中进行共享库的注入</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/Windows反调试技术.html">Windows反调试技术</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/Windows反虚拟机技术.html">Windows反虚拟机技术</a></li><li class="post-list-item"><a class="post-list-link" href="/Oracle/使用Sqlplus动态执行SQL命令.html">使用Sqlplus动态执行SQL命令</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/关于汇编中的PTR操作符.html">关于汇编中的PTR操作符</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/汇编中关于对于Pointer的一个描述.html">汇编中关于对于Pointer的一个描述</a></li><li class="post-list-item"><a class="post-list-link" href="/Asm/CheatEngine入门指南.html">CheatEngine入门指南</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/在macOS-Mojave上编译Lua失败的经历.html">在macOS-Mojave上编译Lua失败的经历</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/PIL.30.编写C函数的.html">PIL.30.编写C函数的</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">43</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Asm/">Asm</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos-Creator/">Cocos Creator</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-X/">Cocos2d-X</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Device/">Device</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GTD/">GTD</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kindle/">Kindle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Unix/">Linux/Unix</a><span class="category-list-count">35</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Office/">Office</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Oracle/">Oracle</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PIL/">PIL</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SED-AWK/">SED&AWK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TensorFlow/">TensorFlow</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Work/">Work</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS/">macOS</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/curl/" style="font-size: 15px;">curl</a> <a href="/tags/brew/" style="font-size: 15px;">brew</a> <a href="/tags/装修/" style="font-size: 15px;">装修</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/弯头/" style="font-size: 15px;">弯头</a> <a href="/tags/管件/" style="font-size: 15px;">管件</a> <a href="/tags/水管/" style="font-size: 15px;">水管</a> <a href="/tags/Word/" style="font-size: 15px;">Word</a> <a href="/tags/Office/" style="font-size: 15px;">Office</a> <a href="/tags/sed/" style="font-size: 15px;">sed</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/Cocos2d-X/" style="font-size: 15px;">Cocos2d-X</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/LVM/" style="font-size: 15px;">LVM</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/android-studio/" style="font-size: 15px;">android studio</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/word/" style="font-size: 15px;">word</a> <a href="/tags/REST/" style="font-size: 15px;">REST</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/VNC/" style="font-size: 15px;">VNC</a> <a href="/tags/Docx/" style="font-size: 15px;">Docx</a> <a href="/tags/X5/" style="font-size: 15px;">X5</a> <a href="/tags/Tbs/" style="font-size: 15px;">Tbs</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/Cocos-Creator/" style="font-size: 15px;">Cocos Creator</a> <a href="/tags/Cocos-Js/" style="font-size: 15px;">Cocos-Js</a> <a href="/tags/Cocos-Creator/" style="font-size: 15px;">Cocos-Creator</a> <a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/ML/" style="font-size: 15px;">ML</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Sqlplus/" style="font-size: 15px;">Sqlplus</a> <a href="/tags/Application/" style="font-size: 15px;">Application</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/PAC/" style="font-size: 15px;">PAC</a> <a href="/tags/NFS/" style="font-size: 15px;">NFS</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/Dagger/" style="font-size: 15px;">Dagger</a> <a href="/tags/Pomelo/" style="font-size: 15px;">Pomelo</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/AppExecutors/" style="font-size: 15px;">AppExecutors</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/Gson/" style="font-size: 15px;">Gson</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Bash/" style="font-size: 15px;">Bash</a> <a href="/tags/Selector/" style="font-size: 15px;">Selector</a> <a href="/tags/GTD/" style="font-size: 15px;">GTD</a> <a href="/tags/AAR/" style="font-size: 15px;">AAR</a> <a href="/tags/Room/" style="font-size: 15px;">Room</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/MFC/" style="font-size: 15px;">MFC</a> <a href="/tags/Cpp/" style="font-size: 15px;">Cpp</a> <a href="/tags/Work/" style="font-size: 15px;">Work</a> <a href="/tags/AAA/" style="font-size: 15px;">AAA</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/加固/" style="font-size: 15px;">加固</a> <a href="/tags/RegEx/" style="font-size: 15px;">RegEx</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/POSIX/" style="font-size: 15px;">POSIX</a> <a href="/tags/Kindle/" style="font-size: 15px;">Kindle</a> <a href="/tags/小说/" style="font-size: 15px;">小说</a> <a href="/tags/F5/" style="font-size: 15px;">F5</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/iptables/" style="font-size: 15px;">iptables</a> <a href="/tags/越狱/" style="font-size: 15px;">越狱</a> <a href="/tags/阅读/" style="font-size: 15px;">阅读</a> <a href="/tags/Cron/" style="font-size: 15px;">Cron</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/Unix/" style="font-size: 15px;">Unix</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/OSPF/" style="font-size: 15px;">OSPF</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Oralce/" style="font-size: 15px;">Oralce</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/OpenSSH/" style="font-size: 15px;">OpenSSH</a> <a href="/tags/OpenSSL/" style="font-size: 15px;">OpenSSL</a> <a href="/tags/ntpd/" style="font-size: 15px;">ntpd</a> <a href="/tags/tcpdump/" style="font-size: 15px;">tcpdump</a> <a href="/tags/抓包/" style="font-size: 15px;">抓包</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Gowa2017 Zhang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-137245514-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><<<<<<< Updated upstream<script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>var disqus_shortname = 'gowa-1';
var disqus_identifier = 'Lua/skynet中的网络服务与消息处理.html';
var disqus_title = 'skynet中的网络服务与消息处理';
var disqus_url = 'https://gowa2017.github.io/Lua/skynet中的网络服务与消息处理.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//gowa-1.disqus.com/count.js" async></script><script type="text/javascript" src="//gowa-1.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></body></html>