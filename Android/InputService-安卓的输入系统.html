<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>InputService-安卓的输入系统 | 退思园</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">InputService-安卓的输入系统</h1><a id="logo" href="/.">退思园</a><p class="description">烦恼一般都是想太多了。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/workflow"><i class="fa fa-rss"> workflow</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">InputService-安卓的输入系统</h1><div class="post-meta"><a href="/Android/InputService-安卓的输入系统.html#comments" class="comment-count"><i data-disqus-identifier="Android/InputService-安卓的输入系统.html" class="disqus-comment-count"></i>留言</a><p><span class="date">Nov 10, 2019</span><span><a href="/categories/Android/" class="category">Android</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>我们来探究一下，从我们手指按压屏幕，到界面上做出响应，背后的过程是怎么样的。我们能否做到模拟一下这个过程呢？不过这又有想远了。</p>
<a id="more"></a>
<p>一直想来研究一下这个过程的，但是这个过程实在是复杂，在对 C 和 Linux<br>， Jni 不熟的情况下会是一脸懵逼的。但这个就需要从安卓系统的启动说起了。</p>
<h1 id="关于安卓的输入"><a href="#关于安卓的输入" class="headerlink" title="关于安卓的输入"></a>关于安卓的输入</h1><p><a href="https://source.android.com/devices/input/touch-devices" target="_blank" rel="noopener">官方有一个描述性的文档说明了输入过程</a>：</p>
<p>下面简要汇总了 Android 上的触摸设备操作。</p>
<ol>
<li><code>EventHub</code> 从 <code>evdev</code> 驱动程序读取原始事件。</li>
<li><code>InputReader</code> 消耗原始事件，并更新关于每个工具的位置和其他特征的内部状态。它还会跟踪按钮状态。</li>
<li>如果按下或释放“后退”或“前进”按钮，<code>InputReader</code> 会向 <code>InputDispatcher</code> 发出按键事件通知。</li>
<li><code>InputReader</code> 确定是否发生了虚拟按键的按压操作。如果是，它会向 <code>InputDispatcher</code> 发出按键事件通知。</li>
<li><code>InputReader</code> 确定触摸行为是否在显示范围内发起的。如果是，它会向 <code>InputDispatcher</code> 发出触摸事件通知。</li>
<li>如果没有触摸工具，但至少有一个悬停工具，则 <code>InputReader</code> 会向 <code>InputDispatcher</code> 发出悬停事件通知。</li>
<li>如果触摸设备类型是指控设备，则 <code>InputReader</code> 会执行指针手势检测，相应地移动指针和相关点，并通知 <code>InputDispatcher</code> 指针事件。</li>
<li><code>InputDispatcher</code> 使用 <code>WindowManagerPolicy</code> 来确定是否应该调度这些事件，以及它们是否应该唤醒设备。然后，<code>InputDispatcher</code> 将事件传递给相应的应用。</li>
</ol>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>安卓系统是如何启动的呢？</p>
<p>我们来看一张图</p>
<p><img src="../res/1*oVJgKQJMm0p1-whfB6W4kg.png" alt="img"></p>
<p>大概可以看到系统的启动分为几个部分：</p>
<ol>
<li>启动内核。</li>
<li>启动第一个进程 <strong>init</strong></li>
<li><strong>init</strong>  启动 Zygote 进程，这个进程就会启动安卓框架相关的</li>
<li>Zygote 启动 AppRuntime(AndroidRunTime)</li>
<li>运行时，启动 Java 层的服务。</li>
</ol>
<p>init 启动的时候会解析 init.rc 文件，然后根据文件中的配置来启动系统服务。</p>
<p>我们的 <strong>zygote</strong> 服务定义在 <code>/init.${ro.zygote}.rc</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>
<p>下面就开始看 zygote 服务的启动流程了</p>
<h1 id="app-process-命令"><a href="#app-process-命令" class="headerlink" title="app_process 命令"></a>app_process 命令</h1><p>其源代码位于 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/cmds/app_process/app_main.cpp" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/frameworks/base/cmds/app_process/app_main.cpp</a></p>
<p>其只是一个工具，用来启动 zygote（其实就是 app_process 本身） 这么个进程。在这里定义了几个关键的概念：</p>
<ul>
<li>AppRuntime 应用的运行时，表示每个应用都需要的运行环境</li>
<li>AndroidRuntime 安卓运行时，安卓系统的运行环境。</li>
</ul>
<p>其实，我们最主要看两个地方，就知道是怎么样启动 zygote 了：</p>
<p>app_process 的命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">app_process [java-options] cmd-dir start-class-name [options]</span><br></pre></td></tr></table></figure>
<p>也就是说启动的时候需要指定命令目录，启动类名，已经可选的 Java 启动选项和参数选项。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>app_process 命令会构造一个 AppRuntime ，其父类是 AndroiRunTime，然后在此运行时内启动 <code>com.android.internal.os.ZygoteInit</code>。</p>
<h2 id="AppRuntime"><a href="#AppRuntime" class="headerlink" title="AppRuntime"></a>AppRuntime</h2><p>这个类是 AndroidRuntime 的子类。其定义了一个 APP，或者说一个安卓系统上进程相关的内容。其成员和方法并不多，从他的定义上来理解这个运行时到底是做什么的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> [functions]</span><br><span class="line">+AppRuntime(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> argBlockLength)</span><br><span class="line">+onExit(<span class="keyword">int</span> code)</span><br><span class="line">+onStarted()</span><br><span class="line">+onVmCreated(JNIEnv* env)</span><br><span class="line">+onZygoteInit()</span><br><span class="line">+setClassNameAndArgs(<span class="keyword">const</span> String8&amp; className, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> *argv)</span><br><span class="line"> [members]</span><br><span class="line">+mArgs</span><br><span class="line">+mClass</span><br><span class="line">+mClassName</span><br></pre></td></tr></table></figure>
<p>成员就三个：启动类名，启动 Java类在 Cpp 的表示，启动类的参数。</p>
<p>onStarted 会在非 Zygote 启动时被 AndroidRunTime 回调，而 onZygoteInit 会在启动 Zygote 时回调。</p>
<h2 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h2><p>AndroidRuntime 是 C++ 与 Java 进行沟通的桥梁，其源代码位于<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/AndroidRuntime.cpp" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/AndroidRuntime.cpp</a></p>
<p>其干的最主要的事情就是：</p>
<ul>
<li>开启 Java VM</li>
<li>建立 Jni 环境</li>
<li>将安卓框架 Native 层的内容注入到 JNI 去。</li>
<li>Java VM 内初始化 ZygoteInit</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGD(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</span><br><span class="line">            className != <span class="literal">NULL</span> ? className : <span class="string">"(unknown)"</span>, getuid());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 'startSystemServer == true' means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">"/system"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /android does not exist."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></span><br><span class="line">    <span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终 AndroidRuntime 有一个对 Java VM 的引用。</p>
<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>我们在 Zygote 中，调用了 <code>runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</code> 方法，这就在 Java VM 类，启动了初始化过程。这是第一个启动的 Java 类。</p>
<p>Java VM 的初始化工作，代码位于</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</a>)</p>
<p>从这个时候开始，代码的运行逻辑就交了 Java VM了。这会启动一个 ZygoteServer，然后开启一个套接字监听，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Report Zygote start time to tron unless it is a runtime restart</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>))) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_zygote_init"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String bootTimeTag = Process.is64Bit() ? <span class="string">"Zygote64Timing"</span> : <span class="string">"Zygote32Timing"</span>;</span><br><span class="line">        TimingsTraceLog bootTimingsTraceLog = <span class="keyword">new</span> TimingsTraceLog(bootTimeTag,</span><br><span class="line">                Trace.TRACE_TAG_DALVIK);</span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">"ZygoteInit"</span>);</span><br><span class="line">        RuntimeInit.enableDdms();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (abiList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No ABI list supplied."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">        <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">        <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">"ZygotePreload"</span>);</span><br><span class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">            bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Zygote.resetNicePriority();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">"PostZygoteInitGC"</span>);</span><br><span class="line">        gcAndFinalize();</span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// PostZygoteInitGC</span></span><br><span class="line"></span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygoteInit</span></span><br><span class="line">        <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags from</span></span><br><span class="line">        <span class="comment">// Zygote.</span></span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Zygote.nativeSecurityInit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">        Zygote.nativeUnmountStorageOnInit();</span><br><span class="line"></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">            <span class="comment">// child (system_server) process.</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">    <span class="comment">// command.</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZygoteServer-runSelectLoop"><a href="#ZygoteServer-runSelectLoop" class="headerlink" title="ZygoteServer.runSelectLoop()"></a>ZygoteServer.runSelectLoop()</h3><p>这个服务主要是接受主要的套接字上的命令，然后进行处理，启动其他服务。这个服务相对简单一些，所以放在前面来看。在复制完 SystemServer 进程后，流程就会走到这里。</p>
<p>对于 SystemServer 进程，则不会进入这个循环，因为其在 fork 后其任务就变更了。</p>
<p>这个循环会从套接字内接收收到的请求，然后进行处理，需要注意的是：<code>ZygoteConnection. processOneCommand()</code> 会 <code>Zygote.forkAndSpecialize()</code> fork  一个新的进程来执行请求。新的进行会从此循环内返回，执行对应命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                  	<span class="comment">// fork 子进程，并返回包含子进程 main() 函数的 Runnable 对象</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                        <span class="comment">// not until we attempt to read from it from processOneCommand. This shows up as</span></span><br><span class="line">                        <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the server so any exception here is one that has taken place</span></span><br><span class="line">                        <span class="comment">// pre-fork while processing commands or reading / writing from the</span></span><br><span class="line">                        <span class="comment">// control socket. Make a loud noise about any such exceptions so that</span></span><br><span class="line">                        <span class="comment">// we know exactly what failed and why.</span></span><br><span class="line"></span><br><span class="line">                        Slog.e(TAG, <span class="string">"Exception executing zygote command: "</span>, e);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Make sure the socket is closed so that the other end knows immediately</span></span><br><span class="line">                        <span class="comment">// that something has gone wrong and doesn't time out waiting for a</span></span><br><span class="line">                        <span class="comment">// response.</span></span><br><span class="line">                        ZygoteConnection conn = peers.remove(i);</span><br><span class="line">                        conn.closeSocket();</span><br><span class="line"></span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the child so any exception caught here has happened post</span></span><br><span class="line">                        <span class="comment">// fork and before we execute ActivityThread.main (or any other main()</span></span><br><span class="line">                        <span class="comment">// method). Log the details of the exception and bring down the process.</span></span><br><span class="line">                        Log.e(TAG, <span class="string">"Caught post-fork exception in child process."</span>, e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Reset the child flag, in the event that the child process is a child-</span></span><br><span class="line">                    <span class="comment">// zygote. The flag will not be consulted this loop pass after the Runnable</span></span><br><span class="line">                    <span class="comment">// is returned.</span></span><br><span class="line">                    mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java#123</span></span><br><span class="line">    <span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        String args[];</span><br><span class="line">        Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">        FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args = readArgumentList();</span><br><span class="line">            descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"IOException on command socket"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// readArgumentList returns null only when it has reached EOF with no available</span></span><br><span class="line">        <span class="comment">// data to read. This will only happen when the remote socket has disconnected.</span></span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            isEof = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line">        FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.abiListQuery) &#123;</span><br><span class="line">            handleAbiListQuery();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.preloadDefault) &#123;</span><br><span class="line">            handlePreload();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.preloadPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlePreloadPackage(parsedArgs.preloadPackage, parsedArgs.preloadPackageLibs,</span><br><span class="line">                    parsedArgs.preloadPackageLibFileName, parsedArgs.preloadPackageCacheKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.apiBlacklistExemptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleApiBlacklistExemptions(parsedArgs.apiBlacklistExemptions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.hiddenApiAccessLogSampleRate != -<span class="number">1</span>) &#123;</span><br><span class="line">            handleHiddenApiAccessLogSampleRate(parsedArgs.hiddenApiAccessLogSampleRate);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.permittedCapabilities != <span class="number">0</span> || parsedArgs.effectiveCapabilities != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteSecurityException(<span class="string">"Client may not specify capabilities: "</span> +</span><br><span class="line">                    <span class="string">"permitted=0x"</span> + Long.toHexString(parsedArgs.permittedCapabilities) +</span><br><span class="line">                    <span class="string">", effective=0x"</span> + Long.toHexString(parsedArgs.effectiveCapabilities));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        applyUidSecurityPolicy(parsedArgs, peer);</span><br><span class="line">        applyInvokeWithSecurityPolicy(parsedArgs, peer);</span><br><span class="line"></span><br><span class="line">        applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] rlimits = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.rlimits != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rlimits = parsedArgs.rlimits.toArray(intArray2d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] fdsToIgnore = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</span><br><span class="line">                childPipeFd = pipeFds[<span class="number">1</span>];</span><br><span class="line">                serverPipeFd = pipeFds[<span class="number">0</span>];</span><br><span class="line">                Os.fcntlInt(childPipeFd, F_SETFD, <span class="number">0</span>);</span><br><span class="line">                fdsToIgnore = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;childPipeFd.getInt$(), serverPipeFd.getInt$()&#125;;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException errnoEx) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to set up pipe for invoke-with"</span>, errnoEx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * In order to avoid leaking descriptors to the Zygote child,</span></span><br><span class="line"><span class="comment">         * the native code must close the two Zygote socket descriptors</span></span><br><span class="line"><span class="comment">         * in the child process before it switches from Zygote-root to</span></span><br><span class="line"><span class="comment">         * the UID and privileges of the application being launched.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * In order to avoid "bad file descriptor" errors when the</span></span><br><span class="line"><span class="comment">         * two LocalSocket objects are closed, the Posix file</span></span><br><span class="line"><span class="comment">         * descriptors are released via a dup2() call which closes</span></span><br><span class="line"><span class="comment">         * the socket and substitutes an open descriptor to /dev/null.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] fdsToClose = &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = mSocket.getFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">0</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = zygoteServer.getServerSocketFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">1</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,</span><br><span class="line">                parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in child</span></span><br><span class="line">                zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                        parsedArgs.startChildZygote);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span></span><br><span class="line">                <span class="comment">// handleParentProc.</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer()"></a>forkSystemServer()</h3><p><em>com.android.server.SystemServer</em> 指定了要启动的 SystemServer。在这里实际上是会调用 linux 的 fork 系统调用，来复制一个新的进程。当复制完成后，会向父进程，也就是我们的 app_process 所在的进程返回 null，而向子进程，返回一个 Runnable。</p>
<p>在这里还会关闭 ZygoteServer 开启的套接字监听，因为不需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zygoteServer.closeServerSocket();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the arguments and forks for the system server process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Runnable&#125; that provides an entrypoint into system_server code in the</span></span><br><span class="line"><span class="comment"> * child process, and &#123;<span class="doctag">@code</span> null&#125; in the parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_IPC_LOCK,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_PTRACE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG,</span><br><span class="line">        OsConstants.CAP_WAKE_ALARM,</span><br><span class="line">        OsConstants.CAP_BLOCK_SUSPEND</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* Containers run without some capabilities, so drop any caps that are not available. */</span></span><br><span class="line">    StructCapUserHeader header = <span class="keyword">new</span> StructCapUserHeader(</span><br><span class="line">            OsConstants._LINUX_CAPABILITY_VERSION_3, <span class="number">0</span>);</span><br><span class="line">    StructCapUserData[] data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        data = Os.capget(header);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to capget()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    capabilities &amp;= ((<span class="keyword">long</span>) data[<span class="number">0</span>].effective) | (((<span class="keyword">long</span>) data[<span class="number">1</span>].effective) &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                <span class="string">"dalvik.vm.profilesystemserver"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (profileSystemServer) &#123;</span><br><span class="line">            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.runtimeFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess()"></a>handleSystemServerProcess()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish remaining work for the newly forked system server process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set umask to 0077 so new files and directories will default to owner-only permissions.</span></span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">    <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">        <span class="comment">// Capturing profiles is only supported for debug or eng builds since selinux normally</span></span><br><span class="line">        <span class="comment">// prevents it.</span></span><br><span class="line">        <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                <span class="string">"dalvik.vm.profilesystemserver"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (profileSystemServer &amp;&amp; (Build.IS_USERDEBUG || Build.IS_ENG)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                prepareSystemServerProfile(systemServerClasspath);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Failed to set up system server profile"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] args = parsedArgs.remainingArgs;</span><br><span class="line">        <span class="comment">// If we have a non-null system server class path, we'll have to duplicate the</span></span><br><span class="line">        <span class="comment">// existing arguments and append the classpath to it. ART will handle the classpath</span></span><br><span class="line">        <span class="comment">// correctly when we exec a new process.</span></span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] amendedArgs = <span class="keyword">new</span> String[args.length + <span class="number">2</span>];</span><br><span class="line">            amendedArgs[<span class="number">0</span>] = <span class="string">"-cp"</span>;</span><br><span class="line">            amendedArgs[<span class="number">1</span>] = systemServerClasspath;</span><br><span class="line">            System.arraycopy(args, <span class="number">0</span>, amendedArgs, <span class="number">2</span>, args.length);</span><br><span class="line">            args = amendedArgs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(), <span class="keyword">null</span>, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected return from WrapperInit.execApplication"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit.zygoteInit()"></a>ZygoteInit.zygoteInit()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main function called when started through the zygote process. This</span></span><br><span class="line"><span class="comment"> * could be unified with main(), if the native code in nativeFinishInit()</span></span><br><span class="line"><span class="comment"> * were rationalized with Zygote startup.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Current recognized args:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt;  &amp;lt;args&amp;gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSdkVersion target SDK version</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> argv arg strings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RuntimeInit.DEBUG) &#123;</span><br><span class="line">        Slog.d(RuntimeInit.TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ZygoteInit"</span>);</span><br><span class="line">    RuntimeInit.redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZygoteInit-nativeZygoteInit"><a href="#ZygoteInit-nativeZygoteInit" class="headerlink" title="ZygoteInit.nativeZygoteInit()"></a>ZygoteInit.nativeZygoteInit()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AndroidRunTime</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppRunTime -&gt; app_main.cpp</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">        ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">        proc-&gt;startThreadPool();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit.applicationInit()"></a>RuntimeInit.applicationInit()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">        <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">        <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">        <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">        <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">        nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></span><br><span class="line">        <span class="comment">// holding on to a lot of memory that isn't needed.</span></span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">        <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes a static "main(argv[]) method on class "className".</span></span><br><span class="line"><span class="comment">     * Converts various failing exceptions into RuntimeExceptions, with</span></span><br><span class="line"><span class="comment">     * the assumption that they will then cause the VM instance to exit.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className Fully-qualified class name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argv Argument vector for main()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader the classLoader to load &#123;<span class="doctag">@className</span>&#125; with</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">         * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">         * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">         * up the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Helper class which holds a method and arguments and can call them. This is used as part of</span></span><br><span class="line"><span class="comment">     * a trampoline to get rid of the initial process setup stack frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** method to call */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** argument array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">            mMethod = method;</span><br><span class="line">            mArgs = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main()"></a>SystemServer.main()</h1><p>在子进程中，将会启动很多的安卓系统服务了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startBootstrapServices();</span><br><span class="line">startCoreServices();</span><br><span class="line">startOtherServices();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main entry point from zygote.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">"InitBeforeStartServices"</span>);</span><br><span class="line">            <span class="comment">// If a device's clock is before 1970 (before 0), a lot of</span></span><br><span class="line">            <span class="comment">// APIs crash dealing with negative numbers, notably</span></span><br><span class="line">            <span class="comment">// java.io.File#setLastModified, so instead we fake it and</span></span><br><span class="line">            <span class="comment">// hope that time from cell towers or NTP fixes it shortly.</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"System clock is before 1970; setting to 1970."</span>);</span><br><span class="line">                SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Default the timezone property to GMT if not set.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            String timezoneProperty =  SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">            <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">                SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the system has "persist.sys.language" and friends set, replace them with</span></span><br><span class="line">            <span class="comment">// "persist.sys.locale". Note that the default locale at this point is calculated</span></span><br><span class="line">            <span class="comment">// using the "-Duser.locale" command line flag. That flag is usually populated by</span></span><br><span class="line">            <span class="comment">// AndroidRuntime using the same set of system properties, but only the system_server</span></span><br><span class="line">            <span class="comment">// and system apps are allowed to set them.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Most changes made here will need an equivalent change to</span></span><br><span class="line">            <span class="comment">// core/jni/AndroidRuntime.cpp</span></span><br><span class="line">            <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">                SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">                SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">                SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">                SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The system server should never make non-oneway calls</span></span><br><span class="line">            Binder.setWarnOnBlocking(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// The system server should always load safe labels</span></span><br><span class="line">            PackageItemInfo.setForceSafeLabels(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// Deactivate SQLiteCompatibilityWalFlags until settings provider is initialized</span></span><br><span class="line">            SQLiteCompatibilityWalFlags.init(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Here we go!</span></span><br><span class="line">            Slog.i(TAG, <span class="string">"Entered the Android system server!"</span>);</span><br><span class="line">            <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);</span><br><span class="line">            <span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">                MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_system_server_init"</span>, uptimeMillis);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In case the runtime switched since last boot (such as when</span></span><br><span class="line">            <span class="comment">// the old runtime was removed in an OTA), set the system</span></span><br><span class="line">            <span class="comment">// property so that it is in sync. We can | xq oqi't do this in</span></span><br><span class="line">            <span class="comment">// libnativehelper's JniInvocation::Init code where we already</span></span><br><span class="line">            <span class="comment">// had to fallback to a different runtime because it is</span></span><br><span class="line">            <span class="comment">// running as root and we need to be the system user to set</span></span><br><span class="line">            <span class="comment">// the property. http://b/11463182</span></span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mmmmmm... more memory!</span></span><br><span class="line">            VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The system server has to run all of the time, so it needs to be</span></span><br><span class="line">            <span class="comment">// as efficient as possible with its memory usage.</span></span><br><span class="line">            VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line">            <span class="comment">// we've defined it before booting further.</span></span><br><span class="line">            Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Within the system server, it is an error to access Environment paths without</span></span><br><span class="line">            <span class="comment">// explicitly specifying a user.</span></span><br><span class="line">            Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Within the system server, any incoming Bundles should be defused</span></span><br><span class="line">            <span class="comment">// to avoid throwing BadParcelableException.</span></span><br><span class="line">            BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Within the system server, when parceling exceptions, include the stack trace</span></span><br><span class="line">            Parcel.setStackTraceParceling(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">            BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Increase the number of binder threads in system_server</span></span><br><span class="line">            BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">            android.os.Process.setThreadPriority(</span><br><span class="line">                android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">            android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">            Looper.prepareMainLooper();</span><br><span class="line">            Looper.getMainLooper().setSlowLogThresholdMs(</span><br><span class="line">                    SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize native services.</span></span><br><span class="line">            System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check whether we failed to shut down last time we tried.</span></span><br><span class="line">            <span class="comment">// This call may not return.</span></span><br><span class="line">            performPendingShutdown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize the system context.</span></span><br><span class="line">            createSystemContext();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the system service manager.</span></span><br><span class="line">            mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">            mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">                    mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">            <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">            SystemServerInitThreadPool.get();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start services.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">"StartServices"</span>);</span><br><span class="line">            startBootstrapServices();</span><br><span class="line">            startCoreServices();</span><br><span class="line">            startOtherServices();</span><br><span class="line">            SystemServerInitThreadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">            Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StrictMode.initVmDefaults(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">            <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_system_server_ready"</span>, uptimeMillis);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> MAX_UPTIME_MILLIS = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (uptimeMillis &gt; MAX_UPTIME_MILLIS) &#123;</span><br><span class="line">                Slog.wtf(SYSTEM_SERVER_TIMING_TAG,</span><br><span class="line">                        <span class="string">"SystemServer init took too long. uptimeMillis="</span> + uptimeMillis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop forever.</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="安卓的输入栈"><a href="#安卓的输入栈" class="headerlink" title="安卓的输入栈"></a>安卓的输入栈</h1><p><img src="../res/image-20191113173055018.png" alt="image-20191113173055018"></p>
<h1 id="InputManagerService"><a href="#InputManagerService" class="headerlink" title="InputManagerService"></a>InputManagerService</h1><p>这个服务在 <code>startOtherService()</code> 中启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputManagerService inputManager = <span class="keyword">null</span>;</span><br><span class="line">WindowManagerService wm = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartInputManagerService"</span>);</span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">    wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">            !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());</span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">            <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartInputManager"</span>);</span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">    inputManager.start();</span><br><span class="line">    traceEnd();</span><br></pre></td></tr></table></figure>
<p>可以看到， InputManagerService 与 WindowManagerService 是相互持有，相互通信的。</p>
<p>InputManagerService 的回调设置成了 WindowManagerService 的监控器。</p>
<h2 id="InputManagerService-1"><a href="#InputManagerService-1" class="headerlink" title="InputManagerService()"></a>InputManagerService()</h2><p>InputManagerService 服务的初始化，实际上还会在 C 层面有一个对象来关联，而 InputManagerService 则通过 一个 C 指针 <strong>mPtr</strong>来进行引用**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    mUseDevInputEventForAudioJack =</span><br><span class="line">            context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line">    Slog.i(TAG, <span class="string">"Initializing input manager, mUseDevInputEventForAudioJack="</span></span><br><span class="line">            + mUseDevInputEventForAudioJack);</span><br><span class="line">    mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">    String doubleTouchGestureEnablePath = context.getResources().getString(</span><br><span class="line">            R.string.config_doubleTouchGestureEnableFile);</span><br><span class="line">    mDoubleTouchGestureEnableFile = TextUtils.isEmpty(doubleTouchGestureEnablePath) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> File(doubleTouchGestureEnablePath);</span><br><span class="line"></span><br><span class="line">    LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nativeInit"><a href="#nativeInit" class="headerlink" title="nativeInit()"></a>nativeInit()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NativeInputManager"><a href="#NativeInputManager" class="headerlink" title="NativeInputManager"></a>NativeInputManager</h3><p>NativeInputManager 属于 C 层的输入管理器，用来管理相关输入逻辑。其构造了一个 InputManager 来管理 EventHub 上的事件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">        mLocked.pointerCapture = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInteractive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EventHub"><a href="#EventHub" class="headerlink" title="EventHub"></a>EventHub</h3><p>EventHub 会监控 <code>/dev/input</code> 目录下的删除和新建事件，同时还建立了一个管道，根据管道是否有数据来确定是否有唤醒事件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/native/services/inputflinger/EventHub.cpp#201</span></span><br><span class="line"></span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventHub-getEvents"><a href="#EventHub-getEvents" class="headerlink" title="EventHub.getEvents()"></a>EventHub.getEvents()</h4><p>EventHub 在构造的时候会监控 /dev/input 目录的新增和删除事件，还会监控一个管道 mWakeReadPipeFd 的数据到达事件。但是，这个时候实际上还没有将所有的设备监控起来，只有在我们第一地调用这个方法的时候，会进行设备的扫描。</p>
<p>在这里面如果没有其他事件，只是获取事件的话，那么会调用  epoll_wait 等待事件到达。如果有事件，会将事件放到 buff 里面，供 InputReader 使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis, RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line">    ALOG_ASSERT(bufferSize &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">readBuffer</span>[<span class="title">bufferSize</span>];</span></span><br><span class="line"></span><br><span class="line">    RawEvent* event = buffer;</span><br><span class="line">    <span class="keyword">size_t</span> capacity = bufferSize;</span><br><span class="line">    <span class="keyword">bool</span> awoken = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reopen input devices if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedToReopenDevices) &#123;</span><br><span class="line">            mNeedToReopenDevices = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            ALOGI(<span class="string">"Reopening all input devices due to a configuration change."</span>);</span><br><span class="line"></span><br><span class="line">            closeAllDevicesLocked();</span><br><span class="line">            mNeedToScanDevices = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// return to the caller before we actually rescan</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Report any devices that had last been added/removed.</span></span><br><span class="line">        <span class="keyword">while</span> (mClosingDevices) &#123;</span><br><span class="line">            Device* device = mClosingDevices;</span><br><span class="line">            ALOGV(<span class="string">"Reporting device closed: id=%d, name=%s\n"</span>,</span><br><span class="line">                 device-&gt;id, device-&gt;path.<span class="built_in">string</span>());</span><br><span class="line">            mClosingDevices = device-&gt;next;</span><br><span class="line">            event-&gt;when = now;</span><br><span class="line">            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id;</span><br><span class="line">            event-&gt;type = DEVICE_REMOVED;</span><br><span class="line">            event += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">delete</span> device;</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 第一次调用的时候，会执行这里，进行设备的扫描</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedToScanDevices) &#123;</span><br><span class="line">            mNeedToScanDevices = <span class="literal">false</span>;</span><br><span class="line">            scanDevicesLocked();</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mOpeningDevices != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Device* device = mOpeningDevices;</span><br><span class="line">            ALOGV(<span class="string">"Reporting device opened: id=%d, name=%s\n"</span>,</span><br><span class="line">                 device-&gt;id, device-&gt;path.<span class="built_in">string</span>());</span><br><span class="line">            mOpeningDevices = device-&gt;next;</span><br><span class="line">            event-&gt;when = now;</span><br><span class="line">            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="number">0</span> : device-&gt;id;</span><br><span class="line">            event-&gt;type = DEVICE_ADDED;</span><br><span class="line">            event += <span class="number">1</span>;</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNeedToSendFinishedDeviceScan) &#123;</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">false</span>;</span><br><span class="line">            event-&gt;when = now;</span><br><span class="line">            event-&gt;type = FINISHED_DEVICE_SCAN;</span><br><span class="line">            event += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Grab the next input event.</span></span><br><span class="line">        <span class="keyword">bool</span> deviceChanged = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> = <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line">            <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">                    mPendingINotify = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for INotify."</span>, eventItem.events);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_WAKE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">                    ALOGV(<span class="string">"awoken after wake()"</span>);</span><br><span class="line">                    awoken = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">                    <span class="keyword">ssize_t</span> nRead;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for wake read pipe."</span>,</span><br><span class="line">                            eventItem.events);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(eventItem.data.u32);</span><br><span class="line">            <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for unknown device id %d."</span>,</span><br><span class="line">                        eventItem.events, eventItem.data.u32);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Device* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">            <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="keyword">int32_t</span> readSize = read(device-&gt;fd, readBuffer,</span><br><span class="line">                        <span class="keyword">sizeof</span>(struct input_event) * capacity);</span><br><span class="line">                <span class="keyword">if</span> (readSize == <span class="number">0</span> || (readSize &lt; <span class="number">0</span> &amp;&amp; errno == ENODEV)) &#123;</span><br><span class="line">                    <span class="comment">// Device was removed before INotify noticed.</span></span><br><span class="line">                    ALOGW(<span class="string">"could not get event, removed? (fd: %d size: %"</span> PRId32</span><br><span class="line">                            <span class="string">" bufferSize: %zu capacity: %zu errno: %d)\n"</span>,</span><br><span class="line">                            device-&gt;fd, readSize, bufferSize, capacity, errno);</span><br><span class="line">                    deviceChanged = <span class="literal">true</span>;</span><br><span class="line">                    closeDeviceLocked(device);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"could not get event (errno=%d)"</span>, errno);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((readSize % <span class="keyword">sizeof</span>(struct input_event)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"could not get event (wrong size: %d)"</span>, readSize);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int32_t</span> deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="number">0</span> : device-&gt;id;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">size_t</span> count = <span class="keyword">size_t</span>(readSize) / <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span>&amp; <span class="title">iev</span> = <span class="title">readBuffer</span>[<span class="title">i</span>];</span></span><br><span class="line">                        ALOGV(<span class="string">"%s got: time=%d.%06d, type=%d, code=%d, value=%d"</span>,</span><br><span class="line">                                device-&gt;path.<span class="built_in">string</span>(),</span><br><span class="line">                                (<span class="keyword">int</span>) iev.time.tv_sec, (<span class="keyword">int</span>) iev.time.tv_usec,</span><br><span class="line">                                iev.type, iev.code, iev.value);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Some input devices may have a better concept of the time</span></span><br><span class="line">                        <span class="comment">// when an input event was actually generated than the kernel</span></span><br><span class="line">                        <span class="comment">// which simply timestamps all events on entry to evdev.</span></span><br><span class="line">                        <span class="comment">// This is a custom Android extension of the input protocol</span></span><br><span class="line">                        <span class="comment">// mainly intended for use with uinput based device drivers.</span></span><br><span class="line">                        <span class="keyword">if</span> (iev.type == EV_MSC) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (iev.code == MSC_ANDROID_TIME_SEC) &#123;</span><br><span class="line">                                device-&gt;timestampOverrideSec = iev.value;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iev.code == MSC_ANDROID_TIME_USEC) &#123;</span><br><span class="line">                                device-&gt;timestampOverrideUsec = iev.value;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (device-&gt;timestampOverrideSec || device-&gt;timestampOverrideUsec) &#123;</span><br><span class="line">                            iev.time.tv_sec = device-&gt;timestampOverrideSec;</span><br><span class="line">                            iev.time.tv_usec = device-&gt;timestampOverrideUsec;</span><br><span class="line">                            <span class="keyword">if</span> (iev.type == EV_SYN &amp;&amp; iev.code == SYN_REPORT) &#123;</span><br><span class="line">                                device-&gt;timestampOverrideSec = <span class="number">0</span>;</span><br><span class="line">                                device-&gt;timestampOverrideUsec = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ALOGV(<span class="string">"applied override time %d.%06d"</span>,</span><br><span class="line">                                    <span class="keyword">int</span>(iev.time.tv_sec), <span class="keyword">int</span>(iev.time.tv_usec));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Use the time specified in the event instead of the current time</span></span><br><span class="line">                        <span class="comment">// so that downstream code can get more accurate estimates of</span></span><br><span class="line">                        <span class="comment">// event dispatch latency from the time the event is enqueued onto</span></span><br><span class="line">                        <span class="comment">// the evdev client buffer.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// The event's timestamp fortuitously uses the same monotonic clock</span></span><br><span class="line">                        <span class="comment">// time base as the rest of Android.  The kernel event device driver</span></span><br><span class="line">                        <span class="comment">// (drivers/input/evdev.c) obtains timestamps using ktime_get_ts().</span></span><br><span class="line">                        <span class="comment">// The systemTime(SYSTEM_TIME_MONOTONIC) function we use everywhere</span></span><br><span class="line">                        <span class="comment">// calls clock_gettime(CLOCK_MONOTONIC) which is implemented as a</span></span><br><span class="line">                        <span class="comment">// system call that also queries ktime_get_ts().</span></span><br><span class="line">                        event-&gt;when = <span class="keyword">nsecs_t</span>(iev.time.tv_sec) * <span class="number">1000000000L</span>L</span><br><span class="line">                                + <span class="keyword">nsecs_t</span>(iev.time.tv_usec) * <span class="number">1000L</span>L;</span><br><span class="line">                        ALOGV(<span class="string">"event time %"</span> PRId64 <span class="string">", now %"</span> PRId64, event-&gt;when, now);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Bug 7291243: Add a guard in case the kernel generates timestamps</span></span><br><span class="line">                        <span class="comment">// that appear to be far into the future because they were generated</span></span><br><span class="line">                        <span class="comment">// using the wrong clock source.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// This can happen because when the input device is initially opened</span></span><br><span class="line">                        <span class="comment">// it has a default clock source of CLOCK_REALTIME.  Any input events</span></span><br><span class="line">                        <span class="comment">// enqueued right after the device is opened will have timestamps</span></span><br><span class="line">                        <span class="comment">// generated using CLOCK_REALTIME.  We later set the clock source</span></span><br><span class="line">                        <span class="comment">// to CLOCK_MONOTONIC but it is already too late.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// Invalid input event timestamps can result in ANRs, crashes and</span></span><br><span class="line">                        <span class="comment">// and other issues that are hard to track down.  We must not let them</span></span><br><span class="line">                        <span class="comment">// propagate through the system.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// Log a warning so that we notice the problem and recover gracefully.</span></span><br><span class="line">                        <span class="keyword">if</span> (event-&gt;when &gt;= now + <span class="number">10</span> * <span class="number">1000000000L</span>L) &#123;</span><br><span class="line">                            <span class="comment">// Double-check.  Time may have moved on.</span></span><br><span class="line">                            <span class="keyword">nsecs_t</span> time = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                            <span class="keyword">if</span> (event-&gt;when &gt; time) &#123;</span><br><span class="line">                                ALOGW(<span class="string">"An input event from %s has a timestamp that appears to "</span></span><br><span class="line">                                        <span class="string">"have been generated using the wrong clock source "</span></span><br><span class="line">                                        <span class="string">"(expected CLOCK_MONOTONIC): "</span></span><br><span class="line">                                        <span class="string">"event time %"</span> PRId64 <span class="string">", current time %"</span> PRId64</span><br><span class="line">                                        <span class="string">", call time %"</span> PRId64 <span class="string">".  "</span></span><br><span class="line">                                        <span class="string">"Using current time instead."</span>,</span><br><span class="line">                                        device-&gt;path.<span class="built_in">string</span>(), event-&gt;when, time, now);</span><br><span class="line">                                event-&gt;when = time;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ALOGV(<span class="string">"Event time is ok but failed the fast path and required "</span></span><br><span class="line">                                        <span class="string">"an extra call to systemTime: "</span></span><br><span class="line">                                        <span class="string">"event time %"</span> PRId64 <span class="string">", current time %"</span> PRId64</span><br><span class="line">                                        <span class="string">", call time %"</span> PRId64 <span class="string">"."</span>,</span><br><span class="line">                                        event-&gt;when, time, now);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        event-&gt;deviceId = deviceId;</span><br><span class="line">                        event-&gt;type = iev.type;</span><br><span class="line">                        event-&gt;code = iev.code;</span><br><span class="line">                        event-&gt;value = iev.value;</span><br><span class="line">                        event += <span class="number">1</span>;</span><br><span class="line">                        capacity -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// The result buffer is full.  Reset the pending event index</span></span><br><span class="line">                        <span class="comment">// so we will try to read the device again on the next iteration.</span></span><br><span class="line">                        mPendingEventIndex -= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventItem.events &amp; EPOLLHUP) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Removing device %s due to epoll hang-up event."</span>,</span><br><span class="line">                        device-&gt;identifier.name.<span class="built_in">string</span>());</span><br><span class="line">                deviceChanged = <span class="literal">true</span>;</span><br><span class="line">                closeDeviceLocked(device);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for device %s."</span>,</span><br><span class="line">                        eventItem.events, device-&gt;identifier.name.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// readNotify() will modify the list of devices so this must be done after</span></span><br><span class="line">        <span class="comment">// processing all other events to ensure that we read all remaining events</span></span><br><span class="line">        <span class="comment">// before closing the devices.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;</span><br><span class="line">            mPendingINotify = <span class="literal">false</span>;</span><br><span class="line">            readNotifyLocked();</span><br><span class="line">            deviceChanged = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Report added or removed devices immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (deviceChanged) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return now if we have collected any events or if we were explicitly awoken.</span></span><br><span class="line">        <span class="keyword">if</span> (event != buffer || awoken) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll for events.  Mind the wake lock dance!</span></span><br><span class="line">        <span class="comment">// We hold a wake lock at all times except during epoll_wait().  This works due to some</span></span><br><span class="line">        <span class="comment">// subtle choreography.  When a device driver has pending (unread) events, it acquires</span></span><br><span class="line">        <span class="comment">// a kernel wake lock.  However, once the last pending event has been read, the device</span></span><br><span class="line">        <span class="comment">// driver will release the kernel wake lock.  To prevent the system from going to sleep</span></span><br><span class="line">        <span class="comment">// when this happens, the EventHub holds onto its own user wake lock while the client</span></span><br><span class="line">        <span class="comment">// is processing events.  Thus the system can only sleep if there are no events</span></span><br><span class="line">        <span class="comment">// pending or currently being processed.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The timeout is advisory only.  If the device is asleep, it will not wake just to</span></span><br><span class="line">        <span class="comment">// service the timeout.</span></span><br><span class="line">        mPendingEventIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mLock.unlock(); <span class="comment">// release lock before poll, must be before release_wake_lock</span></span><br><span class="line">        release_wake_lock(WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">        acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line">        mLock.lock(); <span class="comment">// reacquire lock after poll, must be after acquire_wake_lock</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollResult == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Timed out.</span></span><br><span class="line">            mPendingEventCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// An error occurred.</span></span><br><span class="line">            mPendingEventCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sleep after errors to avoid locking up the system.</span></span><br><span class="line">            <span class="comment">// Hopefully the error is transient.</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">                ALOGW(<span class="string">"poll failed (errno=%d)\n"</span>, errno);</span><br><span class="line">                usleep(<span class="number">100000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Some events occurred.</span></span><br><span class="line">            mPendingEventCount = <span class="keyword">size_t</span>(pollResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All done, return the number of events we read.</span></span><br><span class="line">    <span class="keyword">return</span> event - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设备扫描"><a href="#设备扫描" class="headerlink" title="设备扫描"></a>设备扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventHub::scanDevicesLocked() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = scanDirLocked(DEVICE_PATH);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"scan dir failed for %s\n"</span>, DEVICE_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        createVirtualKeyboardLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> EventHub::scanDirLocked(<span class="keyword">const</span> <span class="keyword">char</span> *dirname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> devname[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> *filename;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    dir = opendir(dirname);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(devname, dirname);</span><br><span class="line">    filename = devname + <span class="built_in">strlen</span>(devname);</span><br><span class="line">    *filename++ = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">while</span>((de = readdir(dir))) &#123;</span><br><span class="line">        <span class="keyword">if</span>(de-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp;</span><br><span class="line">           (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'\0'</span> ||</span><br><span class="line">            (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; de-&gt;d_name[<span class="number">2</span>] == <span class="string">'\0'</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, de-&gt;d_name);</span><br><span class="line">        openDeviceLocked(devname);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventHub::openDeviceLocked(<span class="keyword">const</span> <span class="keyword">char</span> *devicePath) &#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Opening device: %s"</span>, devicePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(devicePath, O_RDWR | O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not open %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDeviceIdentifier identifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device name.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGNAME(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get device name for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.name.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if the device is on our excluded list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mExcludedDevices.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; item = mExcludedDevices.itemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (identifier.name == item) &#123;</span><br><span class="line">            ALOGI(<span class="string">"ignoring event id %s driver %s\n"</span>, devicePath, item.<span class="built_in">string</span>());</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device driver version.</span></span><br><span class="line">    <span class="keyword">int</span> driverVersion;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGVERSION, &amp;driverVersion)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not get driver version for %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device identifier.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">inputId</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGID, &amp;inputId)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not get device input id for %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    identifier.bus = inputId.bustype;</span><br><span class="line">    identifier.product = inputId.product;</span><br><span class="line">    identifier.vendor = inputId.vendor;</span><br><span class="line">    identifier.version = inputId.version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device physical location.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGPHYS(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get location for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.location.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device unique id.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGUNIQ(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get idstring for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.uniqueId.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill in the descriptor.</span></span><br><span class="line">    assignDescriptorLocked(identifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device.  (The device object takes ownership of the fd at this point.)</span></span><br><span class="line">    <span class="keyword">int32_t</span> deviceId = mNextDeviceId++;</span><br><span class="line">    Device* device = <span class="keyword">new</span> Device(fd, deviceId, String8(devicePath), identifier);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"add device %d: %s\n"</span>, deviceId, devicePath);</span><br><span class="line">    ALOGV(<span class="string">"  bus:        %04x\n"</span></span><br><span class="line">         <span class="string">"  vendor      %04x\n"</span></span><br><span class="line">         <span class="string">"  product     %04x\n"</span></span><br><span class="line">         <span class="string">"  version     %04x\n"</span>,</span><br><span class="line">        identifier.bus, identifier.vendor, identifier.product, identifier.version);</span><br><span class="line">    ALOGV(<span class="string">"  name:       \"%s\"\n"</span>, identifier.name.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  location:   \"%s\"\n"</span>, identifier.location.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  unique id:  \"%s\"\n"</span>, identifier.uniqueId.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  descriptor: \"%s\"\n"</span>, identifier.descriptor.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  driver:     v%d.%d.%d\n"</span>,</span><br><span class="line">        driverVersion &gt;&gt; <span class="number">16</span>, (driverVersion &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>, driverVersion &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the configuration file for the device.</span></span><br><span class="line">    loadConfigurationLocked(device);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out the kinds of events the device reports.</span></span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_KEY, <span class="keyword">sizeof</span>(device-&gt;keyBitmask)), device-&gt;keyBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_ABS, <span class="keyword">sizeof</span>(device-&gt;absBitmask)), device-&gt;absBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_REL, <span class="keyword">sizeof</span>(device-&gt;relBitmask)), device-&gt;relBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_SW, <span class="keyword">sizeof</span>(device-&gt;swBitmask)), device-&gt;swBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_LED, <span class="keyword">sizeof</span>(device-&gt;ledBitmask)), device-&gt;ledBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_FF, <span class="keyword">sizeof</span>(device-&gt;ffBitmask)), device-&gt;ffBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGPROP(<span class="keyword">sizeof</span>(device-&gt;propBitmask)), device-&gt;propBitmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a keyboard.  Ignore everything in the button range except for</span></span><br><span class="line">    <span class="comment">// joystick and gamepad buttons which are handled like keyboards for the most part.</span></span><br><span class="line">    <span class="keyword">bool</span> haveKeyboardKeys = containsNonZeroByte(device-&gt;keyBitmask, <span class="number">0</span>, sizeof_bit_array(BTN_MISC))</span><br><span class="line">            || containsNonZeroByte(device-&gt;keyBitmask, sizeof_bit_array(KEY_OK),</span><br><span class="line">                    sizeof_bit_array(KEY_MAX + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">bool</span> haveGamepadButtons = containsNonZeroByte(device-&gt;keyBitmask, sizeof_bit_array(BTN_MISC),</span><br><span class="line">                    sizeof_bit_array(BTN_MOUSE))</span><br><span class="line">            || containsNonZeroByte(device-&gt;keyBitmask, sizeof_bit_array(BTN_JOYSTICK),</span><br><span class="line">                    sizeof_bit_array(BTN_DIGI));</span><br><span class="line">    <span class="keyword">if</span> (haveKeyboardKeys || haveGamepadButtons) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_KEYBOARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a cursor device such as a trackball or mouse.</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(BTN_MOUSE, device-&gt;keyBitmask)</span><br><span class="line">            &amp;&amp; test_bit(REL_X, device-&gt;relBitmask)</span><br><span class="line">            &amp;&amp; test_bit(REL_Y, device-&gt;relBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_CURSOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a rotary encoder type device.</span></span><br><span class="line">    String8 deviceType = String8();</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;configuration &amp;&amp;</span><br><span class="line">        device-&gt;configuration-&gt;tryGetProperty(String8(<span class="string">"device.type"</span>), deviceType)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!deviceType.compare(String8(<span class="string">"rotaryEncoder"</span>))) &#123;</span><br><span class="line">                device-&gt;classes |= INPUT_DEVICE_CLASS_ROTARY_ENCODER;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a touch pad.</span></span><br><span class="line">    <span class="comment">// Is this a new modern multi-touch driver?</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(ABS_MT_POSITION_X, device-&gt;absBitmask)</span><br><span class="line">            &amp;&amp; test_bit(ABS_MT_POSITION_Y, device-&gt;absBitmask)) &#123;</span><br><span class="line">        <span class="comment">// Some joysticks such as the PS3 controller report axes that conflict</span></span><br><span class="line">        <span class="comment">// with the ABS_MT range.  Try to confirm that the device really is</span></span><br><span class="line">        <span class="comment">// a touch screen.</span></span><br><span class="line">        <span class="keyword">if</span> (test_bit(BTN_TOUCH, device-&gt;keyBitmask) || !haveGamepadButtons) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_TOUCH | INPUT_DEVICE_CLASS_TOUCH_MT;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// Is this an old style single-touch driver?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_bit(BTN_TOUCH, device-&gt;keyBitmask)</span><br><span class="line">            &amp;&amp; test_bit(ABS_X, device-&gt;absBitmask)</span><br><span class="line">            &amp;&amp; test_bit(ABS_Y, device-&gt;absBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_TOUCH;</span><br><span class="line">    <span class="comment">// Is this a BT stylus?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test_bit(ABS_PRESSURE, device-&gt;absBitmask) ||</span><br><span class="line">                test_bit(BTN_TOUCH, device-&gt;keyBitmask))</span><br><span class="line">            &amp;&amp; !test_bit(ABS_X, device-&gt;absBitmask)</span><br><span class="line">            &amp;&amp; !test_bit(ABS_Y, device-&gt;absBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_EXTERNAL_STYLUS;</span><br><span class="line">        <span class="comment">// Keyboard will try to claim some of the buttons but we really want to reserve those so we</span></span><br><span class="line">        <span class="comment">// can fuse it with the touch screen data, so just take them back. Note this means an</span></span><br><span class="line">        <span class="comment">// external stylus cannot also be a keyboard device.</span></span><br><span class="line">        device-&gt;classes &amp;= ~INPUT_DEVICE_CLASS_KEYBOARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this device is a joystick.</span></span><br><span class="line">    <span class="comment">// Assumes that joysticks always have gamepad buttons in order to distinguish them</span></span><br><span class="line">    <span class="comment">// from other devices such as accelerometers that also have absolute axes.</span></span><br><span class="line">    <span class="keyword">if</span> (haveGamepadButtons) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> assumedClasses = device-&gt;classes | INPUT_DEVICE_CLASS_JOYSTICK;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ABS_MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (test_bit(i, device-&gt;absBitmask)</span><br><span class="line">                    &amp;&amp; (getAbsAxisUsage(i, assumedClasses) &amp; INPUT_DEVICE_CLASS_JOYSTICK)) &#123;</span><br><span class="line">                device-&gt;classes = assumedClasses;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether this device has switches.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= SW_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test_bit(i, device-&gt;swBitmask)) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_SWITCH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether this device supports the vibrator.</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(FF_RUMBLE, device-&gt;ffBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_VIBRATOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure virtual keys.</span></span><br><span class="line">    <span class="keyword">if</span> ((device-&gt;classes &amp; INPUT_DEVICE_CLASS_TOUCH)) &#123;</span><br><span class="line">        <span class="comment">// Load the virtual keys for the touch screen, if any.</span></span><br><span class="line">        <span class="comment">// We do this now so that we can make sure to load the keymap if necessary.</span></span><br><span class="line">        <span class="keyword">status_t</span> status = loadVirtualKeyMapLocked(device);</span><br><span class="line">        <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_KEYBOARD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the key map.</span></span><br><span class="line">    <span class="comment">// We need to do this for joysticks too because the key layout may specify axes.</span></span><br><span class="line">    <span class="keyword">status_t</span> keyMapStatus = NAME_NOT_FOUND;</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes &amp; (INPUT_DEVICE_CLASS_KEYBOARD | INPUT_DEVICE_CLASS_JOYSTICK)) &#123;</span><br><span class="line">        <span class="comment">// Load the keymap for the device.</span></span><br><span class="line">        keyMapStatus = loadKeyMapLocked(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the keyboard, gamepad or virtual keyboard.</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes &amp; INPUT_DEVICE_CLASS_KEYBOARD) &#123;</span><br><span class="line">        <span class="comment">// Register the keyboard as a built-in keyboard if it is eligible.</span></span><br><span class="line">        <span class="keyword">if</span> (!keyMapStatus</span><br><span class="line">                &amp;&amp; mBuiltInKeyboardId == NO_BUILT_IN_KEYBOARD</span><br><span class="line">                &amp;&amp; isEligibleBuiltInKeyboard(device-&gt;identifier,</span><br><span class="line">                        device-&gt;configuration, &amp;device-&gt;keyMap)) &#123;</span><br><span class="line">            mBuiltInKeyboardId = device-&gt;id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'Q' key support = cheap test of whether this is an alpha-capable kbd</span></span><br><span class="line">        <span class="keyword">if</span> (hasKeycodeLocked(device, AKEYCODE_Q)) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_ALPHAKEY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See if this device has a DPAD.</span></span><br><span class="line">        <span class="keyword">if</span> (hasKeycodeLocked(device, AKEYCODE_DPAD_UP) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_DOWN) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_LEFT) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_RIGHT) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_CENTER)) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_DPAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See if this device has a gamepad.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(GAMEPAD_KEYCODES)/<span class="keyword">sizeof</span>(GAMEPAD_KEYCODES[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasKeycodeLocked(device, GAMEPAD_KEYCODES[i])) &#123;</span><br><span class="line">                device-&gt;classes |= INPUT_DEVICE_CLASS_GAMEPAD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the device isn't recognized as something we handle, don't monitor it.</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"Dropping device: id=%d, path='%s', name='%s'"</span>,</span><br><span class="line">                deviceId, devicePath, device-&gt;identifier.name.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">delete</span> device;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether the device has a mic.</span></span><br><span class="line">    <span class="keyword">if</span> (deviceHasMicLocked(device)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_MIC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether the device is external or internal.</span></span><br><span class="line">    <span class="keyword">if</span> (isExternalDeviceLocked(device)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_EXTERNAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes &amp; (INPUT_DEVICE_CLASS_JOYSTICK | INPUT_DEVICE_CLASS_DPAD)</span><br><span class="line">            &amp;&amp; device-&gt;classes &amp; INPUT_DEVICE_CLASS_GAMEPAD) &#123;</span><br><span class="line">        device-&gt;controllerNumber = getNextControllerNumberLocked(device);</span><br><span class="line">        setLedForControllerLocked(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registerDeviceForEpollLocked(device) != OK) &#123;</span><br><span class="line">        <span class="keyword">delete</span> device;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configureFd(device);</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"New device: id=%d, fd=%d, path='%s', name='%s', classes=0x%x, "</span></span><br><span class="line">            <span class="string">"configuration='%s', keyLayout='%s', keyCharacterMap='%s', builtinKeyboard=%s, "</span>,</span><br><span class="line">         deviceId, fd, devicePath, device-&gt;identifier.name.<span class="built_in">string</span>(),</span><br><span class="line">         device-&gt;classes,</span><br><span class="line">         device-&gt;configurationFile.<span class="built_in">string</span>(),</span><br><span class="line">         device-&gt;keyMap.keyLayoutFile.<span class="built_in">string</span>(),</span><br><span class="line">         device-&gt;keyMap.keyCharacterMapFile.<span class="built_in">string</span>(),</span><br><span class="line">         toString(mBuiltInKeyboardId == deviceId));</span><br><span class="line"></span><br><span class="line">    addDeviceLocked(device);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到设备列表</span></span><br><span class="line"><span class="keyword">void</span> EventHub::addDeviceLocked(Device* device) &#123;</span><br><span class="line">    mDevices.add(device-&gt;id, device);</span><br><span class="line">    device-&gt;next = mOpeningDevices;</span><br><span class="line">    mOpeningDevices = device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册到epoll监控事件"><a href="#注册到epoll监控事件" class="headerlink" title="注册到epoll监控事件"></a>注册到epoll监控事件</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventHub::registerDeviceForEpollLocked(Device* device) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mUsingEpollWakeup) &#123;</span><br><span class="line">        eventItem.events |= EPOLLWAKEUP;</span><br><span class="line">    &#125;</span><br><span class="line">    eventItem.data.u32 = device-&gt;id;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(mEpollFd, EPOLL_CTL_ADD, device-&gt;fd, &amp;eventItem)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not add device fd to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InputManager"><a href="#InputManager" class="headerlink" title="InputManager"></a>InputManager</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://androidxref.com/9.0.0_r3/xref/frameworks/native/services/inputflinger/InputManager.cpp</span></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputManager 建立了一个 InputReader 进行读取输入，一个 InputDispatcher 进行分发输出。同时，将 InputReader 的回调设置为 InputDispatcher。</p>
<p>同时开启了两个线程：InputReaderThread，InputDispatcherThread。</p>
<h2 id="InputManagerService-start"><a href="#InputManagerService-start" class="headerlink" title="InputManagerService.start()"></a>InputManagerService.start()</h2><p>InputManagerService 会先启动 C 层的服务，再进行 Java 层的操作。主要是注册了几个设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Starting input manager"</span>);</span><br><span class="line">        nativeStart(mPtr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">        Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        registerPointerSpeedSettingObserver();</span><br><span class="line">        registerShowTouchesSettingObserver();</span><br><span class="line">        registerAccessibilityLargePointerSettingObserver();</span><br><span class="line"></span><br><span class="line">        mContext.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">                updatePointerSpeedFromSettings();</span><br><span class="line">                updateShowTouchesFromSettings();</span><br><span class="line">                updateAccessibilityLargePointerFromSettings();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_SWITCHED), <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">        updatePointerSpeedFromSettings();</span><br><span class="line">        updateShowTouchesFromSettings();</span><br><span class="line">        updateAccessibilityLargePointerFromSettings();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="nativeStart"><a href="#nativeStart" class="headerlink" title="nativeStart()"></a>nativeStart()</h3><p>在 C 层面，将输入事件读取线程，分发线程都启动了起来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not start InputDispatcher thread due to error %d."</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not start InputReader thread due to error %d."</span>, result);</span><br><span class="line"></span><br><span class="line">        mDispatcherThread-&gt;requestExit();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h2><p>InputReader 在构造的时候，会有一个队列，队列的回调就是 Dipatcher：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputReaderThread"><a href="#InputReaderThread" class="headerlink" title="InputReaderThread"></a>InputReaderThread</h2><p>InputReaderThread 继承自 <strong>utils/thread.h</strong>中的  Thread。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/system/core/include/utils/Thread.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Create a Thread object, but doesn't create or start the associated</span></span><br><span class="line">    <span class="comment">// thread. See the run() method.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span>            <span class="title">Thread</span><span class="params">(<span class="keyword">bool</span> canCallJava = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span>             ~Thread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t    <span class="title">run</span><span class="params">(    <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="built_in">stack</span> = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask this object's thread to exit. This function is asynchronous, when the</span></span><br><span class="line">    <span class="comment">// function returns the thread might still be running. Of course, this</span></span><br><span class="line">    <span class="comment">// function can be called from a different thread.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>        <span class="title">requestExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Good place to do one-time initializations</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t    <span class="title">readyToRun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call requestExit() and wait until this object's thread exits.</span></span><br><span class="line">    <span class="comment">// BE VERY CAREFUL of deadlocks. In particular, it would be silly to call</span></span><br><span class="line">    <span class="comment">// this function from this object's thread. Will return WOULD_BLOCK in</span></span><br><span class="line">    <span class="comment">// that case.</span></span><br><span class="line">            <span class="keyword">status_t</span>    requestExitAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until this object's thread exits. Returns immediately if not yet running.</span></span><br><span class="line">    <span class="comment">// Do not call from this object's thread; will return WOULD_BLOCK in that case.</span></span><br><span class="line">            <span class="keyword">status_t</span>    join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicates whether this thread is running or not.</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span>        <span class="title">isRunning</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">    <span class="comment">// Return the thread's kernel ID, same as the thread itself calling gettid(),</span></span><br><span class="line">    <span class="comment">// or -1 if the thread is not running.</span></span><br><span class="line">            <span class="keyword">pid_t</span>       getTid() <span class="keyword">const</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// exitPending() returns true if requestExit() has been called.</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span>        <span class="title">exitPending</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></span><br><span class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></span><br><span class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></span><br><span class="line">    <span class="comment">//          requestExit() wasn't called.</span></span><br><span class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">threadLoop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thread&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Thread&amp;);</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span>             _threadLoop(<span class="keyword">void</span>* user);</span><br><span class="line">    <span class="keyword">const</span>   <span class="keyword">bool</span>            mCanCallJava;</span><br><span class="line">    <span class="comment">// always hold mLock when reading or writing</span></span><br><span class="line">            <span class="keyword">thread_id_t</span>     mThread;</span><br><span class="line">    <span class="keyword">mutable</span> Mutex           mLock;</span><br><span class="line">            Condition       mThreadExitedCondition;</span><br><span class="line">            <span class="keyword">status_t</span>        mStatus;</span><br><span class="line">    <span class="comment">// note that all accesses of mExitPending and mRunning need to hold mLock</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span>           mExitPending;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span>           mRunning;</span><br><span class="line">            sp&lt;Thread&gt;      mHoldSelf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">    <span class="comment">// legacy for debugging, not used by getTid() as it is set by the child thread</span></span><br><span class="line">    <span class="comment">// and so is not initialized until the child reaches that point</span></span><br><span class="line">            <span class="keyword">pid_t</span>           mTid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用 run 方法，实际上就是开始线程的 threadLoop 循环而已了。</p>
<h4 id="InputReader-loopOnce"><a href="#InputReader-loopOnce" class="headerlink" title="InputReader::loopOnce"></a>InputReader::loopOnce</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/native/services/inputflinger/InputReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">    mReader-&gt;loopOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        oldGeneration = mGeneration;</span><br><span class="line">        timeoutMillis = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> changes = mConfigurationChangesToRefresh;</span><br><span class="line">        <span class="keyword">if</span> (changes) &#123;</span><br><span class="line">            mConfigurationChangesToRefresh = <span class="number">0</span>;</span><br><span class="line">            timeoutMillis = <span class="number">0</span>;</span><br><span class="line">            refreshConfigurationLocked(changes);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mReaderIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            processEventsLocked(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= mNextTimeout) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">                ALOGD(<span class="string">"Timeout expired, latency=%0.3fms"</span>, (now - mNextTimeout) * <span class="number">0.000001f</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                mNextTimeout = LLONG_MAX;</span><br><span class="line">                timeoutExpiredLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldGeneration != mGeneration) &#123;</span><br><span class="line">            inputDevicesChanged = <span class="literal">true</span>;</span><br><span class="line">            getInputDevicesLocked(inputDevices);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send out a message that the describes the changed input devices.</span></span><br><span class="line">    <span class="keyword">if</span> (inputDevicesChanged) &#123;</span><br><span class="line">        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush queued events out to the listener.</span></span><br><span class="line">    <span class="comment">// This must happen outside of the lock because the listener could potentially call</span></span><br><span class="line">    <span class="comment">// back into the InputReader's methods, such as getScanCodeState, or become blocked</span></span><br><span class="line">    <span class="comment">// on another thread similarly waiting to acquire the InputReader lock thereby</span></span><br><span class="line">    <span class="comment">// resulting in a deadlock.  This situation is actually quite plausible because the</span></span><br><span class="line">    <span class="comment">// listener is actually the input dispatcher, which calls into the window manager,</span></span><br><span class="line">    <span class="comment">// which occasionally calls into the input reader.</span></span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputReader-processEventsLocked"><a href="#InputReader-processEventsLocked" class="headerlink" title="InputReader::processEventsLocked"></a>InputReader::processEventsLocked</h4><p>每次循环都会从 EventHub 中读取事件，然后进行处理，对于在 EventHub 内扫描后会出现的新增，删除事件， InputReader 会被对应的设备进行存储，同时为设备建立 mapper。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::processEventsLocked(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> type = rawEvent-&gt;type;</span><br><span class="line">        <span class="keyword">size_t</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">            <span class="keyword">while</span> (batchSize &lt; count) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT</span><br><span class="line">                        || rawEvent[batchSize].deviceId != deviceId) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                batchSize += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">            ALOGD(<span class="string">"BatchSize: %zu Count: %zu"</span>, batchSize, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_ADDED:</span><br><span class="line">                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_REMOVED:</span><br><span class="line">                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:</span><br><span class="line">                handleConfigurationChangedLocked(rawEvent-&gt;when);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOG_ASSERT(<span class="literal">false</span>); <span class="comment">// can't happen</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count -= batchSize;</span><br><span class="line">        rawEvent += batchSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::addDeviceLocked(<span class="keyword">nsecs_t</span> when, <span class="keyword">int32_t</span> deviceId) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    <span class="keyword">if</span> (deviceIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Ignoring spurious device added event for deviceId %d."</span>, deviceId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDeviceIdentifier identifier = mEventHub-&gt;getDeviceIdentifier(deviceId);</span><br><span class="line">    <span class="keyword">uint32_t</span> classes = mEventHub-&gt;getDeviceClasses(deviceId);</span><br><span class="line">    <span class="keyword">int32_t</span> controllerNumber = mEventHub-&gt;getDeviceControllerNumber(deviceId);</span><br><span class="line"></span><br><span class="line">    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);</span><br><span class="line">    device-&gt;configure(when, &amp;mConfig, <span class="number">0</span>);</span><br><span class="line">    device-&gt;reset(when);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;isIgnored()) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Device added: id=%d, name='%s' (ignored non-input device)"</span>, deviceId,</span><br><span class="line">                identifier.name.<span class="built_in">string</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGI(<span class="string">"Device added: id=%d, name='%s', sources=0x%08x"</span>, deviceId,</span><br><span class="line">                identifier.name.<span class="built_in">string</span>(), device-&gt;getSources());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDevices.add(deviceId, device);</span><br><span class="line">    bumpGenerationLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;getClasses() &amp; INPUT_DEVICE_CLASS_EXTERNAL_STYLUS) &#123;</span><br><span class="line">        notifyExternalStylusPresenceChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InputDevice* InputReader::createDeviceLocked(<span class="keyword">int32_t</span> deviceId, <span class="keyword">int32_t</span> controllerNumber,</span><br><span class="line">        <span class="keyword">const</span> InputDeviceIdentifier&amp; identifier, <span class="keyword">uint32_t</span> classes) &#123;</span><br><span class="line">    InputDevice* device = <span class="keyword">new</span> InputDevice(&amp;mContext, deviceId, bumpGenerationLocked(),</span><br><span class="line">            controllerNumber, identifier, classes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// External devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_EXTERNAL) &#123;</span><br><span class="line">        device-&gt;setExternal(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Devices with mics.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_MIC) &#123;</span><br><span class="line">        device-&gt;setMic(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_SWITCH) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> SwitchInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scroll wheel-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_ROTARY_ENCODER) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> RotaryEncoderInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vibrator-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_VIBRATOR) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> VibratorInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keyboard-like devices.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> keyboardSource = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> keyboardType = AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_KEYBOARD) &#123;</span><br><span class="line">        keyboardSource |= AINPUT_SOURCE_KEYBOARD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_ALPHAKEY) &#123;</span><br><span class="line">        keyboardType = AINPUT_KEYBOARD_TYPE_ALPHABETIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_DPAD) &#123;</span><br><span class="line">        keyboardSource |= AINPUT_SOURCE_DPAD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_GAMEPAD) &#123;</span><br><span class="line">        keyboardSource |= AINPUT_SOURCE_GAMEPAD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyboardSource != <span class="number">0</span>) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> KeyboardInputMapper(device, keyboardSource, keyboardType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cursor-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_CURSOR) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> CursorInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Touchscreens and touchpad devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> MultiTouchInputMapper(device));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> SingleTouchInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Joystick-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_JOYSTICK) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> JoystickInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// External stylus-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_EXTERNAL_STYLUS) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> ExternalStylusInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputReader-processEventsForDeviceLocked"><a href="#InputReader-processEventsForDeviceLocked" class="headerlink" title="InputReader::processEventsForDeviceLocked"></a>InputReader::processEventsForDeviceLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理设备添加，移除，扫描外的事件</span></span><br><span class="line"><span class="keyword">void</span> InputReader::processEventsForDeviceLocked(<span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        <span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Discarding event for unknown deviceId %d."</span>, deviceId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;isIgnored()) &#123;</span><br><span class="line">        <span class="comment">//ALOGD("Discarding event for ignored deviceId %d.", deviceId);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputDevice-process"><a href="#InputDevice-process" class="headerlink" title="InputDevice::process"></a>InputDevice::process</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDevice::process(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="comment">// Process all of the events in order for each mapper.</span></span><br><span class="line">    <span class="comment">// We cannot simply ask each mapper to process them in bulk because mappers may</span></span><br><span class="line">    <span class="comment">// have side-effects that must be interleaved.  For example, joystick movement events and</span></span><br><span class="line">    <span class="comment">// gamepad button presses are handled by different mappers but they should be dispatched</span></span><br><span class="line">    <span class="comment">// in the order received.</span></span><br><span class="line">    <span class="keyword">size_t</span> numMappers = mMappers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count != <span class="number">0</span>; rawEvent++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">        ALOGD(<span class="string">"Input event: device=%d type=0x%04x code=0x%04x value=0x%08x when=%"</span> PRId64,</span><br><span class="line">                rawEvent-&gt;deviceId, rawEvent-&gt;type, rawEvent-&gt;code, rawEvent-&gt;value,</span><br><span class="line">                rawEvent-&gt;when);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDropUntilNextSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">                mDropUntilNextSync = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">                ALOGD(<span class="string">"Recovered from input event buffer overrun."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_RAW_EVENTS</span><br><span class="line">                ALOGD(<span class="string">"Dropped input event while waiting for next input sync."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Detected input event buffer overrun for device %s."</span>, getName().<span class="built_in">string</span>());</span><br><span class="line">            mDropUntilNextSync = <span class="literal">true</span>;</span><br><span class="line">            reset(rawEvent-&gt;when);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numMappers; i++) &#123;</span><br><span class="line">                InputMapper* mapper = mMappers[i];</span><br><span class="line">                mapper-&gt;process(rawEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeyboardInputMapper-process"><a href="#KeyboardInputMapper-process" class="headerlink" title="KeyboardInputMapper::process"></a>KeyboardInputMapper::process</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::process(<span class="keyword">const</span> RawEvent* rawEvent) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY: &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode = rawEvent-&gt;code;</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode = mCurrentHidUsage;</span><br><span class="line">        mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyboardOrGamepadKey(scanCode)) &#123;</span><br><span class="line">            processKey(rawEvent-&gt;when, rawEvent-&gt;value != <span class="number">0</span>, scanCode, usageCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_MSC: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == MSC_SCAN) &#123;</span><br><span class="line">            mCurrentHidUsage = rawEvent-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_SYN: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">            mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeyboardInputMapper-processKey"><a href="#KeyboardInputMapper-processKey" class="headerlink" title="KeyboardInputMapper::processKey"></a>KeyboardInputMapper::processKey</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::processKey(<span class="keyword">nsecs_t</span> when, <span class="keyword">bool</span> down, <span class="keyword">int32_t</span> scanCode,</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> keyCode;</span><br><span class="line">    <span class="keyword">int32_t</span> keyMetaState;</span><br><span class="line">    <span class="keyword">uint32_t</span> policyFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, mMetaState,</span><br><span class="line">                              &amp;keyCode, &amp;keyMetaState, &amp;policyFlags)) &#123;</span><br><span class="line">        keyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">        keyMetaState = mMetaState;</span><br><span class="line">        policyFlags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">        <span class="comment">// Rotate key codes according to orientation if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (mParameters.orientationAware &amp;&amp; mParameters.hasAssociatedDisplay) &#123;</span><br><span class="line">            keyCode = rotateKeyCode(keyCode, mOrientation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add key down.</span></span><br><span class="line">        <span class="keyword">ssize_t</span> keyDownIndex = findKeyDown(scanCode);</span><br><span class="line">        <span class="keyword">if</span> (keyDownIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// key repeat, be sure to use same keycode as before in case of rotation</span></span><br><span class="line">            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key down</span></span><br><span class="line">            <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL)</span><br><span class="line">                    &amp;&amp; mContext-&gt;shouldDropVirtualKey(when,</span><br><span class="line">                            getDevice(), keyCode, scanCode)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (policyFlags &amp; POLICY_FLAG_GESTURE) &#123;</span><br><span class="line">                mDevice-&gt;cancelTouch(when);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mKeyDowns.push();</span><br><span class="line">            KeyDown&amp; keyDown = mKeyDowns.editTop();</span><br><span class="line">            keyDown.keyCode = keyCode;</span><br><span class="line">            keyDown.scanCode = scanCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDownTime = when;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove key down.</span></span><br><span class="line">        <span class="keyword">ssize_t</span> keyDownIndex = findKeyDown(scanCode);</span><br><span class="line">        <span class="keyword">if</span> (keyDownIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// key up, be sure to use same keycode as before in case of rotation</span></span><br><span class="line">            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;</span><br><span class="line">            mKeyDowns.removeAt(<span class="keyword">size_t</span>(keyDownIndex));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key was not actually down</span></span><br><span class="line">            ALOGI(<span class="string">"Dropping key up from device %s because the key was not down.  "</span></span><br><span class="line">                    <span class="string">"keyCode=%d, scanCode=%d"</span>,</span><br><span class="line">                    getDeviceName().<span class="built_in">string</span>(), keyCode, scanCode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (updateMetaStateIfNeeded(keyCode, down)) &#123;</span><br><span class="line">        <span class="comment">// If global meta state changed send it along with the key.</span></span><br><span class="line">        <span class="comment">// If it has not changed then we'll use what keymap gave us,</span></span><br><span class="line">        <span class="comment">// since key replacement logic might temporarily reset a few</span></span><br><span class="line">        <span class="comment">// meta bits for given key.</span></span><br><span class="line">        keyMetaState = mMetaState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> downTime = mDownTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key down on external an keyboard should wake the device.</span></span><br><span class="line">    <span class="comment">// We don't do this for internal keyboards to prevent them from waking up in your pocket.</span></span><br><span class="line">    <span class="comment">// For internal keyboards, the key layout file should specify the policy flags for</span></span><br><span class="line">    <span class="comment">// each wake key individually.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Use the input device configuration to control this behavior more finely.</span></span><br><span class="line">    <span class="keyword">if</span> (down &amp;&amp; getDevice()-&gt;isExternal() &amp;&amp; !isMediaKey(keyCode)) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_WAKE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParameters.handlesKeyRepeat) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_DISABLE_KEY_REPEAT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,</span><br><span class="line">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span><br><span class="line">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, keyMetaState, downTime);</span><br><span class="line">    getListener()-&gt;notifyKey(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里就会将按键信息，通知到 mQueuedListener。</p>
<h4 id="QueuedInputListener-notifyKey"><a href="#QueuedInputListener-notifyKey" class="headerlink" title="QueuedInputListener::notifyKey"></a>QueuedInputListener::notifyKey</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    mArgsQueue.push(<span class="keyword">new</span> NotifyKeyArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="QueuedInputListener-flush"><a href="#QueuedInputListener-flush" class="headerlink" title="QueuedInputListener::flush"></a>QueuedInputListener::flush</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mQueuedListener 中。mQueuedListener.flush() 会将所有的事件通知到 Dispatcher（mInnerListener 就是 Dispatcher）。</p>
<h4 id="InputDispatcher-notifyKey"><a href="#InputDispatcher-notifyKey" class="headerlink" title="InputDispatcher::notifyKey"></a>InputDispatcher::notifyKey</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_INBOUND_EVENT_DETAILS</span></span><br><span class="line">    ALOGD(<span class="string">"notifyKey - eventTime=%"</span> PRId64</span><br><span class="line">            <span class="string">", deviceId=%d, source=0x%x, policyFlags=0x%x, action=0x%x, "</span></span><br><span class="line">            <span class="string">"flags=0x%x, keyCode=0x%x, scanCode=0x%x, metaState=0x%x, downTime=%"</span> PRId64,</span><br><span class="line">            args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;policyFlags,</span><br><span class="line">            args-&gt;action, args-&gt;flags, args-&gt;keyCode, args-&gt;scanCode,</span><br><span class="line">            args-&gt;metaState, args-&gt;downTime);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!validateKeyEvent(args-&gt;action)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> policyFlags = args-&gt;policyFlags;</span><br><span class="line">    <span class="keyword">int32_t</span> flags = args-&gt;flags;</span><br><span class="line">    <span class="keyword">int32_t</span> metaState = args-&gt;metaState;</span><br><span class="line">    <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL) || (flags &amp; AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_VIRTUAL;</span><br><span class="line">        flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (policyFlags &amp; POLICY_FLAG_FUNCTION) &#123;</span><br><span class="line">        metaState |= AMETA_FUNCTION_ON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyFlags |= POLICY_FLAG_TRUSTED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> keyCode = args-&gt;keyCode;</span><br><span class="line">    <span class="keyword">if</span> (metaState &amp; AMETA_META_ON &amp;&amp; args-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> newKeyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == AKEYCODE_DEL) &#123;</span><br><span class="line">            newKeyCode = AKEYCODE_BACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyCode == AKEYCODE_ENTER) &#123;</span><br><span class="line">            newKeyCode = AKEYCODE_HOME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newKeyCode != AKEYCODE_UNKNOWN) &#123;</span><br><span class="line">            AutoMutex _l(mLock);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">KeyReplacement</span> <span class="title">replacement</span> = &#123;</span>keyCode, args-&gt;deviceId&#125;;</span><br><span class="line">            mReplacedKeys.add(replacement, newKeyCode);</span><br><span class="line">            keyCode = newKeyCode;</span><br><span class="line">            metaState &amp;= ~(AMETA_META_ON | AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args-&gt;action == AKEY_EVENT_ACTION_UP) &#123;</span><br><span class="line">        <span class="comment">// In order to maintain a consistent stream of up and down events, check to see if the key</span></span><br><span class="line">        <span class="comment">// going up is one we've replaced in a down event and haven't yet replaced in an up event,</span></span><br><span class="line">        <span class="comment">// even if the modifier was released between the down and the up events.</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">KeyReplacement</span> <span class="title">replacement</span> = &#123;</span>keyCode, args-&gt;deviceId&#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> index = mReplacedKeys.indexOfKey(replacement);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            keyCode = mReplacedKeys.valueAt(index);</span><br><span class="line">            mReplacedKeys.removeItemsAt(index);</span><br><span class="line">            metaState &amp;= ~(AMETA_META_ON | AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">            flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">            args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"></span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line">    <span class="keyword">if</span> (t.duration() &gt; SLOW_INTERCEPTION_THRESHOLD) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Excessive delay in interceptKeyBeforeQueueing; took %s ms"</span>,</span><br><span class="line">                <span class="built_in">std</span>::to_string(t.duration().count()).c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NativeInputManager-interceptKeyBeforeQueueing"><a href="#NativeInputManager-interceptKeyBeforeQueueing" class="headerlink" title="NativeInputManager::interceptKeyBeforeQueueing"></a>NativeInputManager::interceptKeyBeforeQueueing</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeInputManager::interceptKeyBeforeQueueing(<span class="keyword">const</span> KeyEvent* keyEvent,</span><br><span class="line">        <span class="keyword">uint32_t</span>&amp; policyFlags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// Policy:</span></span><br><span class="line">    <span class="comment">// - Ignore untrusted events and pass them along.</span></span><br><span class="line">    <span class="comment">// - Ask the window manager what to do with normal events and trusted injected events.</span></span><br><span class="line">    <span class="comment">// - For normal events wake and brighten the screen if currently off or dim.</span></span><br><span class="line">    <span class="keyword">bool</span> interactive = mInteractive.load();</span><br><span class="line">    <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_INTERACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_TRUSTED)) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> when = keyEvent-&gt;getEventTime();</span><br><span class="line">        JNIEnv* env = jniEnv();</span><br><span class="line">        jobject keyEventObj = android_view_KeyEvent_fromNative(env, keyEvent);</span><br><span class="line">        jint wmActions;</span><br><span class="line">        <span class="keyword">if</span> (keyEventObj) &#123;</span><br><span class="line">            wmActions = env-&gt;CallIntMethod(mServiceObj,</span><br><span class="line">                    gServiceClassInfo.interceptKeyBeforeQueueing,</span><br><span class="line">                    keyEventObj, policyFlags);</span><br><span class="line">            <span class="keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="string">"interceptKeyBeforeQueueing"</span>)) &#123;</span><br><span class="line">                wmActions = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android_view_KeyEvent_recycle(env, keyEventObj);</span><br><span class="line">            env-&gt;DeleteLocalRef(keyEventObj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"Failed to obtain key event object for interceptKeyBeforeQueueing."</span>);</span><br><span class="line">            wmActions = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleInterceptActions(wmActions, when, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">            policyFlags |= POLICY_FLAG_PASS_TO_USER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputManagerService-interceptKeyBeforeQueueing"><a href="#InputManagerService-interceptKeyBeforeQueueing" class="headerlink" title="InputManagerService.interceptKeyBeforeQueueing"></a>InputManagerService.interceptKeyBeforeQueueing</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Native callback.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindowManagerCallbacks.interceptKeyBeforeQueueing(event, policyFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Provides an opportunity for the window manager policy to intercept early key</span></span><br><span class="line"><span class="comment">     * processing as soon as the key has been read from the device. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService.mPolicy.interceptKeyBeforeQueueing(event, policyFlags);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="PhoneWindowManager-interceptKeyBeforeQueueing"><a href="#PhoneWindowManager-interceptKeyBeforeQueueing" class="headerlink" title="PhoneWindowManager:interceptKeyBeforeQueueing"></a>PhoneWindowManager:interceptKeyBeforeQueueing</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mSystemBooted) &#123;</span><br><span class="line">            <span class="comment">// If we have not yet booted, don't let key events do anything.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> interactive = (policyFlags &amp; FLAG_INTERACTIVE) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> down = event.getAction() == KeyEvent.ACTION_DOWN;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = event.isCanceled();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> keyCode = event.getKeyCode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isInjected = (policyFlags &amp; WindowManagerPolicy.FLAG_INJECTED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If screen is off then we treat the case where the keyguard is open but hidden</span></span><br><span class="line">        <span class="comment">// the same as if it were open and in front.</span></span><br><span class="line">        <span class="comment">// This will prevent any keys other than the power button from waking the screen</span></span><br><span class="line">        <span class="comment">// when the keyguard is hidden by another activity.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> keyguardActive = (mKeyguardDelegate == <span class="keyword">null</span> ? <span class="keyword">false</span> :</span><br><span class="line">                                            (interactive ?</span><br><span class="line">                                                isKeyguardShowingAndNotOccluded() :</span><br><span class="line">                                                mKeyguardDelegate.isShowing()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_INPUT) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"interceptKeyTq keycode="</span> + keyCode</span><br><span class="line">                    + <span class="string">" interactive="</span> + interactive + <span class="string">" keyguardActive="</span> + keyguardActive</span><br><span class="line">                    + <span class="string">" policyFlags="</span> + Integer.toHexString(policyFlags));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Basic policy based on interactive state.</span></span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> isWakeKey = (policyFlags &amp; WindowManagerPolicy.FLAG_WAKE) != <span class="number">0</span></span><br><span class="line">                || event.isWakeKey();</span><br><span class="line">        <span class="keyword">if</span> (interactive || (isInjected &amp;&amp; !isWakeKey)) &#123;</span><br><span class="line">            <span class="comment">// When the device is interactive or the key is injected pass the</span></span><br><span class="line">            <span class="comment">// key to the application.</span></span><br><span class="line">            result = ACTION_PASS_TO_USER;</span><br><span class="line">            isWakeKey = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">                <span class="comment">// If the screen is awake, but the button pressed was the one that woke the device</span></span><br><span class="line">                <span class="comment">// then don't pass it to the application</span></span><br><span class="line">                <span class="keyword">if</span> (keyCode == mPendingWakeKey &amp;&amp; !down) &#123;</span><br><span class="line">                    result = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Reset the pending key</span></span><br><span class="line">                mPendingWakeKey = PENDING_KEY_NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!interactive &amp;&amp; shouldDispatchInputWhenNonInteractive(event)) &#123;</span><br><span class="line">            <span class="comment">// If we're currently dozing with the screen on and the keyguard showing, pass the key</span></span><br><span class="line">            <span class="comment">// to the application but preserve its wake key status to make sure we still move</span></span><br><span class="line">            <span class="comment">// from dozing to fully interactive if we would normally go from off to fully</span></span><br><span class="line">            <span class="comment">// interactive.</span></span><br><span class="line">            result = ACTION_PASS_TO_USER;</span><br><span class="line">            <span class="comment">// Since we're dispatching the input, reset the pending key</span></span><br><span class="line">            mPendingWakeKey = PENDING_KEY_NULL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When the screen is off and the key is not injected, determine whether</span></span><br><span class="line">            <span class="comment">// to wake the device but don't pass the key to the application.</span></span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (isWakeKey &amp;&amp; (!down || !isWakeKeyWhenScreenOff(keyCode))) &#123;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Cache the wake key on down event so we can also avoid sending the up event to the app</span></span><br><span class="line">            <span class="keyword">if</span> (isWakeKey &amp;&amp; down) &#123;</span><br><span class="line">                mPendingWakeKey = keyCode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the key would be handled globally, just return the result, don't worry about special</span></span><br><span class="line">        <span class="comment">// key processing.</span></span><br><span class="line">        <span class="keyword">if</span> (isValidGlobalKey(keyCode)</span><br><span class="line">                &amp;&amp; mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isWakeKey) &#123;</span><br><span class="line">                wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, <span class="string">"android.policy:KEY"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable haptics if down and virtual key without multiple repetitions. If this is a hard</span></span><br><span class="line">        <span class="comment">// virtual key such as a navigation bar button, only vibrate if flag is enabled.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isNavBarVirtKey = ((event.getFlags() &amp; KeyEvent.FLAG_VIRTUAL_HARD_KEY) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> useHapticFeedback = down</span><br><span class="line">                &amp;&amp; (policyFlags &amp; WindowManagerPolicy.FLAG_VIRTUAL) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled)</span><br><span class="line">                &amp;&amp; event.getRepeatCount() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle special keys.</span></span><br><span class="line">        <span class="keyword">switch</span> (keyCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_BACK: &#123;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    interceptBackKeyDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> handled = interceptBackKeyUp(event);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Don't pass back press to app if we've already handled it via long press</span></span><br><span class="line">                    <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                        result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_DOWN:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_UP:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_MUTE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                        <span class="comment">// Any activity on the vol down button stops the ringer toggle shortcut</span></span><br><span class="line">                        cancelPendingRingerToggleChordAction();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == <span class="number">0</span>) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered = <span class="keyword">true</span>;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed = <span class="keyword">false</span>;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                            interceptAccessibilityShortcutChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mScreenshotChordVolumeDownKeyTriggered = <span class="keyword">false</span>;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                        cancelPendingAccessibilityShortcutAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_VOLUME_UP) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interactive &amp;&amp; !mA11yShortcutChordVolumeUpKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == <span class="number">0</span>) &#123;</span><br><span class="line">                            mA11yShortcutChordVolumeUpKeyTriggered = <span class="keyword">true</span>;</span><br><span class="line">                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();</span><br><span class="line">                            mA11yShortcutChordVolumeUpKeyConsumed = <span class="keyword">false</span>;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            cancelPendingScreenshotChordAction();</span><br><span class="line">                            cancelPendingRingerToggleChordAction();</span><br><span class="line"></span><br><span class="line">                            interceptAccessibilityShortcutChord();</span><br><span class="line">                            interceptRingerToggleChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mA11yShortcutChordVolumeUpKeyTriggered = <span class="keyword">false</span>;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                        cancelPendingAccessibilityShortcutAction();</span><br><span class="line">                        cancelPendingRingerToggleChordAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    sendSystemKeyToStatusBarAsync(event.getKeyCode());</span><br><span class="line"></span><br><span class="line">                    TelecomManager telecomManager = getTelecommService();</span><br><span class="line">                    <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span> &amp;&amp; !mHandleVolumeKeysInWM) &#123;</span><br><span class="line">                        <span class="comment">// When &#123;@link #mHandleVolumeKeysInWM&#125; is set, volume key events</span></span><br><span class="line">                        <span class="comment">// should be dispatched to WM.</span></span><br><span class="line">                        <span class="keyword">if</span> (telecomManager.isRinging()) &#123;</span><br><span class="line">                            <span class="comment">// If an incoming call is ringing, either VOLUME key means</span></span><br><span class="line">                            <span class="comment">// "silence ringer".  We handle these keys here, rather than</span></span><br><span class="line">                            <span class="comment">// in the InCallScreen, to make sure we'll respond to them</span></span><br><span class="line">                            <span class="comment">// even if the InCallScreen hasn't come to the foreground yet.</span></span><br><span class="line">                            <span class="comment">// Look for the DOWN event here, to agree with the "fallback"</span></span><br><span class="line">                            <span class="comment">// behavior in the InCallScreen.</span></span><br><span class="line">                            Log.i(TAG, <span class="string">"interceptKeyBeforeQueueing:"</span></span><br><span class="line">                                  + <span class="string">" VOLUME key-down while ringing: Silence ringer!"</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Silence the ringer.  (It's safe to call this</span></span><br><span class="line">                            <span class="comment">// even if the ringer has already been silenced.)</span></span><br><span class="line">                            telecomManager.silenceRinger();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// And *don't* pass this key thru to the current activity</span></span><br><span class="line">                            <span class="comment">// (which is probably the InCallScreen.)</span></span><br><span class="line">                            result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> audioMode = AudioManager.MODE_NORMAL;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        audioMode = getAudioService().getMode();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">"Error getting AudioService in interceptKeyBeforeQueueing."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> isInCall = (telecomManager != <span class="keyword">null</span> &amp;&amp; telecomManager.isInCall()) ||</span><br><span class="line">                            audioMode == AudioManager.MODE_IN_COMMUNICATION;</span><br><span class="line">                    <span class="keyword">if</span> (isInCall &amp;&amp; (result &amp; ACTION_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// If we are in call but we decided not to pass the key to</span></span><br><span class="line">                        <span class="comment">// the application, just pass it to the session service.</span></span><br><span class="line">                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(</span><br><span class="line">                                event, AudioManager.USE_DEFAULT_STREAM_TYPE, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mUseTvRouting || mHandleVolumeKeysInWM) &#123;</span><br><span class="line">                    <span class="comment">// Defer special key handlings to</span></span><br><span class="line">                    <span class="comment">// &#123;@link interceptKeyBeforeDispatching()&#125;.</span></span><br><span class="line">                    result |= ACTION_PASS_TO_USER;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((result &amp; ACTION_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// If we aren't passing to the user and no one else</span></span><br><span class="line">                    <span class="comment">// handled it send it to the session manager to</span></span><br><span class="line">                    <span class="comment">// figure out.</span></span><br><span class="line">                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(</span><br><span class="line">                            event, AudioManager.USE_DEFAULT_STREAM_TYPE, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_ENDCALL: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    TelecomManager telecomManager = getTelecommService();</span><br><span class="line">                    <span class="keyword">boolean</span> hungUp = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hungUp = telecomManager.endCall();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (interactive &amp;&amp; !hungUp) &#123;</span><br><span class="line">                        mEndCallKeyHandled = <span class="keyword">false</span>;</span><br><span class="line">                        mHandler.postDelayed(mEndCallLongPress,</span><br><span class="line">                                ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEndCallKeyHandled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mEndCallKeyHandled) &#123;</span><br><span class="line">                        mHandler.removeCallbacks(mEndCallLongPress);</span><br><span class="line">                        <span class="keyword">if</span> (!canceled) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((mEndcallBehavior</span><br><span class="line">                                    &amp; Settings.System.END_BUTTON_BEHAVIOR_HOME) != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (goHome()) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> ((mEndcallBehavior</span><br><span class="line">                                    &amp; Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != <span class="number">0</span>) &#123;</span><br><span class="line">                                goToSleep(event.getEventTime(),</span><br><span class="line">                                        PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, <span class="number">0</span>);</span><br><span class="line">                                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                <span class="comment">// Any activity on the power button stops the accessibility shortcut</span></span><br><span class="line">                cancelPendingAccessibilityShortcutAction();</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>; <span class="comment">// wake-up will be handled separately</span></span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                interceptSystemNavigationKey(event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SLEEP: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mPowerManager.isInteractive()) &#123;</span><br><span class="line">                    useHapticFeedback = <span class="keyword">false</span>; <span class="comment">// suppress feedback if already non-interactive</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    sleepPress();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sleepRelease(event.getEventTime());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SOFT_SLEEP: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!down) &#123;</span><br><span class="line">                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_WAKEUP: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PAUSE:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_HEADSETHOOK:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MUTE:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_STOP:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_NEXT:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PREVIOUS:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_REWIND:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_RECORD:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK: &#123;</span><br><span class="line">                <span class="keyword">if</span> (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) &#123;</span><br><span class="line">                    <span class="comment">// If the global session is active pass all media keys to it</span></span><br><span class="line">                    <span class="comment">// instead of the active window.</span></span><br><span class="line">                    result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((result &amp; ACTION_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Only do this if we would otherwise not pass it to the user. In that</span></span><br><span class="line">                    <span class="comment">// case, the PhoneWindow class will do the same thing, except it will</span></span><br><span class="line">                    <span class="comment">// only do it if the showing app doesn't process the key on its own.</span></span><br><span class="line">                    <span class="comment">// Note that we need to make a copy of the key event here because the</span></span><br><span class="line">                    <span class="comment">// original key event will be recycled when we return.</span></span><br><span class="line">                    mBroadcastWakeLock.acquire();</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK,</span><br><span class="line">                            <span class="keyword">new</span> KeyEvent(event));</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_CALL: &#123;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    TelecomManager telecomManager = getTelecommService();</span><br><span class="line">                    <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (telecomManager.isRinging()) &#123;</span><br><span class="line">                            Log.i(TAG, <span class="string">"interceptKeyBeforeQueueing:"</span></span><br><span class="line">                                  + <span class="string">" CALL key-down while ringing: Answer the call!"</span>);</span><br><span class="line">                            telecomManager.acceptRingingCall();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// And *don't* pass this key thru to the current activity</span></span><br><span class="line">                            <span class="comment">// (which is presumably the InCallScreen.)</span></span><br><span class="line">                            result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_ASSIST: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> longPressed = event.getRepeatCount() &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (down &amp;&amp; longPressed) &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!down &amp;&amp; !longPressed) &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(),</span><br><span class="line">                            <span class="number">0</span> <span class="comment">/* unused */</span>, <span class="keyword">null</span> <span class="comment">/* hint */</span>);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOICE_ASSIST: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!down) &#123;</span><br><span class="line">                    mBroadcastWakeLock.acquire();</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_WINDOW: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mPictureInPictureVisible) &#123;</span><br><span class="line">                        <span class="comment">// Consumes the key only if picture-in-picture is visible to show</span></span><br><span class="line">                        <span class="comment">// picture-in-picture control menu. This gives a chance to the foreground</span></span><br><span class="line">                        <span class="comment">// activity to customize PIP key behavior.</span></span><br><span class="line">                        <span class="keyword">if</span> (!down) &#123;</span><br><span class="line">                            showPictureInPictureMenu(event);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (useHapticFeedback) &#123;</span><br><span class="line">            performHapticFeedbackLw(<span class="keyword">null</span>, HapticFeedbackConstants.VIRTUAL_KEY, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isWakeKey) &#123;</span><br><span class="line">            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, <span class="string">"android.policy:KEY"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，事件已经进入了 dipatcher 的队列了，他就要准备开发发射数据。</p>
<p>## InputDispatcher</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">InputDispatcher::InputDispatcher(<span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(<span class="literal">NULL</span>), mLastDropReason(DROP_REASON_NOT_DROPPED),</span><br><span class="line">    mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(<span class="literal">NULL</span>),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputDispatcher-dispatchOnce"><a href="#InputDispatcher-dispatchOnce" class="headerlink" title="InputDispatcher::dispatchOnce"></a>InputDispatcher::dispatchOnce</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run a dispatch loop if there are no pending commands.</span></span><br><span class="line">        <span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputDispatcher-dispatchOnceInnerLocked"><a href="#InputDispatcher-dispatchOnceInnerLocked" class="headerlink" title="InputDispatcher::dispatchOnceInnerLocked"></a>InputDispatcher::dispatchOnceInnerLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the key repeat timer whenever normal dispatch is suspended while the</span></span><br><span class="line">    <span class="comment">// device is in a non-interactive state.  This is to ensure that we abort a key</span></span><br><span class="line">    <span class="comment">// repeat if the device is just coming out of sleep.</span></span><br><span class="line">    <span class="keyword">if</span> (!mDispatchEnabled) &#123;</span><br><span class="line">        resetKeyRepeatLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If dispatching is frozen, do not process timeouts or try to deliver any new events.</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchFrozen) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">        ALOGD(<span class="string">"Dispatch frozen.  Waiting some more."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimize latency of app switches.</span></span><br><span class="line">    <span class="comment">// Essentially we start a short timeout when an app switch key (HOME / ENDCALL) has</span></span><br><span class="line">    <span class="comment">// been pressed.  When it expires, we preempt dispatch and drop all other pending events.</span></span><br><span class="line">    <span class="keyword">bool</span> isAppSwitchDue = mAppSwitchDueTime &lt;= currentTime;</span><br><span class="line">    <span class="keyword">if</span> (mAppSwitchDueTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">        *nextWakeupTime = mAppSwitchDueTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">                <span class="comment">// The inbound queue is empty so the app switch key we were waiting</span></span><br><span class="line">                <span class="comment">// for will never arrive.  Stop waiting for it.</span></span><br><span class="line">                resetPendingAppSwitchLocked(<span class="literal">false</span>);</span><br><span class="line">                isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Synthesize a key repeat if appropriate.</span></span><br><span class="line">            <span class="keyword">if</span> (mKeyRepeatState.lastKeyEntry) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= mKeyRepeatState.nextRepeatTime) &#123;</span><br><span class="line">                    mPendingEvent = synthesizeKeyRepeatLocked(currentTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mKeyRepeatState.nextRepeatTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">                        *nextWakeupTime = mKeyRepeatState.nextRepeatTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Nothing to do if there is no pending event.</span></span><br><span class="line">            <span class="keyword">if</span> (!mPendingEvent) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have an event to dispatch.</span></span><br><span class="line">    <span class="comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    DropReason dropReason = DROP_REASON_NOT_DROPPED;</span><br><span class="line">    <span class="keyword">if</span> (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;</span><br><span class="line">        dropReason = DROP_REASON_POLICY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mDispatchEnabled) &#123;</span><br><span class="line">        dropReason = DROP_REASON_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNextUnblockedEvent == mPendingEvent) &#123;</span><br><span class="line">        mNextUnblockedEvent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">        ConfigurationChangedEntry* typedEntry =</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;ConfigurationChangedEntry*&gt;(mPendingEvent);</span><br><span class="line">        done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">        dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_DEVICE_RESET: &#123;</span><br><span class="line">        DeviceResetEntry* typedEntry =</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;DeviceResetEntry*&gt;(mPendingEvent);</span><br><span class="line">        done = dispatchDeviceResetLocked(currentTime, typedEntry);</span><br><span class="line">        dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// device resets are never dropped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchKeyEventLocked(typedEntry)) &#123;</span><br><span class="line">                resetPendingAppSwitchLocked(<span class="literal">true</span>);</span><br><span class="line">                isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">                dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;</span><br><span class="line">            dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputDispatcher-dispatchKeyLocked"><a href="#InputDispatcher-dispatchKeyLocked" class="headerlink" title="InputDispatcher::dispatchKeyLocked"></a>InputDispatcher::dispatchKeyLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="comment">// Preprocessing.</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;dispatchInProgress) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;repeatCount == <span class="number">0</span></span><br><span class="line">                &amp;&amp; entry-&gt;action == AKEY_EVENT_ACTION_DOWN</span><br><span class="line">                &amp;&amp; (entry-&gt;policyFlags &amp; POLICY_FLAG_TRUSTED)</span><br><span class="line">                &amp;&amp; (!(entry-&gt;policyFlags &amp; POLICY_FLAG_DISABLE_KEY_REPEAT))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mKeyRepeatState.lastKeyEntry</span><br><span class="line">                    &amp;&amp; mKeyRepeatState.lastKeyEntry-&gt;keyCode == entry-&gt;keyCode) &#123;</span><br><span class="line">                <span class="comment">// We have seen two identical key downs in a row which indicates that the device</span></span><br><span class="line">                <span class="comment">// driver is automatically generating key repeats itself.  We take note of the</span></span><br><span class="line">                <span class="comment">// repeat here, but we disable our own next key repeat timer since it is clear that</span></span><br><span class="line">                <span class="comment">// we will not need to synthesize key repeats ourselves.</span></span><br><span class="line">                entry-&gt;repeatCount = mKeyRepeatState.lastKeyEntry-&gt;repeatCount + <span class="number">1</span>;</span><br><span class="line">                resetKeyRepeatLocked();</span><br><span class="line">                mKeyRepeatState.nextRepeatTime = LONG_LONG_MAX; <span class="comment">// don't generate repeats ourselves</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Not a repeat.  Save key down state in case we do see a repeat later.</span></span><br><span class="line">                resetKeyRepeatLocked();</span><br><span class="line">                mKeyRepeatState.nextRepeatTime = entry-&gt;eventTime + mConfig.keyRepeatTimeout;</span><br><span class="line">            &#125;</span><br><span class="line">            mKeyRepeatState.lastKeyEntry = entry;</span><br><span class="line">            entry-&gt;refCount += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! entry-&gt;syntheticRepeat) &#123;</span><br><span class="line">            resetKeyRepeatLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;repeatCount == <span class="number">1</span>) &#123;</span><br><span class="line">            entry-&gt;flags |= AKEY_EVENT_FLAG_LONG_PRESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry-&gt;flags &amp;= ~AKEY_EVENT_FLAG_LONG_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entry-&gt;dispatchInProgress = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        logOutboundKeyDetailsLocked(<span class="string">"dispatchKey - "</span>, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle case where the policy asked us to try again later last time.</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentTime &lt; entry-&gt;interceptKeyWakeupTime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;interceptKeyWakeupTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">                *nextWakeupTime = entry-&gt;interceptKeyWakeupTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// wait until next wakeup</span></span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN;</span><br><span class="line">        entry-&gt;interceptKeyWakeupTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the policy a chance to intercept the key.</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">                    &amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible);</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                commandEntry-&gt;inputWindowHandle = mFocusedWindowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            commandEntry-&gt;keyEntry = entry;</span><br><span class="line">            entry-&gt;refCount += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// wait for the command to run</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_SKIP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            *dropReason = DROP_REASON_POLICY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up if dropping the event.</span></span><br><span class="line">    <span class="keyword">if</span> (*dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">        setInjectionResultLocked(entry, *dropReason == DROP_REASON_POLICY</span><br><span class="line">                ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="findFocusedWindowTargetsLocked"><a href="#findFocusedWindowTargetsLocked" class="headerlink" title="findFocusedWindowTargetsLocked"></a>findFocusedWindowTargetsLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> reason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is no currently focused window and no focused application</span></span><br><span class="line">    <span class="comment">// then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, <span class="literal">NULL</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"Dropping event because there is no focused window or focused application."</span>);</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check permissions.</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the window is ready for more input.</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.empty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.c_str());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Success!  Output targets.</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"findFocusedWindow finished: injectionResult=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatchEventLocked"><a href="#dispatchEventLocked" class="headerlink" title="dispatchEventLocked"></a>dispatchEventLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"dispatchEventToCurrentInputTargets"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_FOCUS</span><br><span class="line">            ALOGD(<span class="string">"Dropping event delivery to target with channel '%s' because it "</span></span><br><span class="line">                    <span class="string">"is no longer registered with the input dispatcher."</span>,</span><br><span class="line">                    inputTarget.inputChannel-&gt;getName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prepareDispatchCycleLocked"><a href="#prepareDispatchCycleLocked" class="headerlink" title="prepareDispatchCycleLocked"></a>prepareDispatchCycleLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ prepareDispatchCycle - flags=0x%08x, "</span></span><br><span class="line">            <span class="string">"xOffset=%f, yOffset=%f, scaleFactor=%f, "</span></span><br><span class="line">            <span class="string">"pointerIds=0x%x"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str(), inputTarget-&gt;flags,</span><br><span class="line">            inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor, inputTarget-&gt;pointerIds.value);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip this event if the connection status is not normal.</span></span><br><span class="line">    <span class="comment">// We don't want to enqueue additional outbound events if the connection is broken.</span></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;status != Connection::STATUS_NORMAL) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">        ALOGD(<span class="string">"channel '%s' ~ Dropping event because the channel status is %s"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str(), connection-&gt;getStatusLabel());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split a motion event if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123;</span><br><span class="line">        ALOG_ASSERT(eventEntry-&gt;type == EventEntry::TYPE_MOTION);</span><br><span class="line"></span><br><span class="line">        MotionEntry* originalMotionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123;</span><br><span class="line">            MotionEntry* splitMotionEntry = splitMotionEvent(</span><br><span class="line">                    originalMotionEntry, inputTarget-&gt;pointerIds);</span><br><span class="line">            <span class="keyword">if</span> (!splitMotionEntry) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// split event was dropped</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' ~ Split motion event."</span>,</span><br><span class="line">                    connection-&gt;getInputChannelName().c_str());</span><br><span class="line">            logOutboundMotionDetailsLocked(<span class="string">"  "</span>, splitMotionEntry);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line">                    splitMotionEntry, inputTarget);</span><br><span class="line">            splitMotionEntry-&gt;release();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enqueueDispatchEntriesLocked"><a href="#enqueueDispatchEntriesLocked" class="headerlink" title="enqueueDispatchEntriesLocked"></a>enqueueDispatchEntriesLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntryLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span><br><span class="line">        <span class="keyword">int32_t</span> dispatchMode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a new event.</span></span><br><span class="line">    <span class="comment">// Enqueue a new dispatch entry onto the outbound queue for this connection.</span></span><br><span class="line">    DispatchEntry* dispatchEntry = <span class="keyword">new</span> DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply target flags and update the connection's input state.</span></span><br><span class="line">    <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line">        dispatchEntry-&gt;resolvedAction = keyEntry-&gt;action;</span><br><span class="line">        dispatchEntry-&gt;resolvedFlags = keyEntry-&gt;flags;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!connection-&gt;inputState.trackKey(keyEntry,</span><br><span class="line">                dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event"</span>,</span><br><span class="line">                    connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">delete</span> dispatchEntry;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// skip the inconsistent event</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_OUTSIDE) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_CANCEL;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = motionEntry-&gt;action;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dispatchEntry-&gt;resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE</span><br><span class="line">                &amp;&amp; !connection-&gt;inputState.isHovering(</span><br><span class="line">                        motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">        ALOGD(<span class="string">"channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatchEntry-&gt;resolvedFlags = motionEntry-&gt;flags;</span><br><span class="line">        <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_OBSCURED) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!connection-&gt;inputState.trackMotion(motionEntry,</span><br><span class="line">                dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event"</span>,</span><br><span class="line">                    connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">delete</span> dispatchEntry;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// skip the inconsistent event</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember that we are waiting for this dispatch to complete.</span></span><br><span class="line">    <span class="keyword">if</span> (dispatchEntry-&gt;hasForegroundTarget()) &#123;</span><br><span class="line">        incrementPendingForegroundDispatchesLocked(eventEntry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">    traceOutboundQueueLengthLocked(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            PointerCoords scaledCoords[MAX_POINTERS];</span><br><span class="line">            <span class="keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the X and Y offset depending on the input source.</span></span><br><span class="line">            <span class="keyword">float</span> xOffset, yOffset;</span><br><span class="line">            <span class="keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)</span><br><span class="line">                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;</span><br><span class="line">                <span class="keyword">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;</span><br><span class="line">                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;</span><br><span class="line">                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;</span><br><span class="line">                <span class="keyword">if</span> (scaleFactor != <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];</span><br><span class="line">                        scaledCoords[i].scale(scaleFactor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xOffset = <span class="number">0.0f</span>;</span><br><span class="line">                yOffset = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We don't want the dispatch target to know.</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i].clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the result.</span></span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;waitQueue.isEmpty()) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full. "</span></span><br><span class="line">                            <span class="string">"This is unexpected because the wait queue is empty, so the pipe "</span></span><br><span class="line">                            <span class="string">"should be empty and we shouldn't have any problems writing an "</span></span><br><span class="line">                            <span class="string">"event to it, status=%d"</span>, connection-&gt;getInputChannelName().c_str(),</span><br><span class="line">                            status);</span><br><span class="line">                    abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Pipe is full and we are waiting for the app to finish process some events</span></span><br><span class="line">                    <span class="comment">// before sending more events to it.</span></span><br><span class="line">#<span class="keyword">if</span> DEBUG_DISPATCH_CYCLE</span><br><span class="line">                    ALOGD(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full, "</span></span><br><span class="line">                            <span class="string">"waiting for the application to catch up"</span>,</span><br><span class="line">                            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    connection-&gt;inputPublisherBlocked = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Could not publish event due to an unexpected error, "</span></span><br><span class="line">                        <span class="string">"status=%d"</span>, connection-&gt;getInputChannelName().c_str(), status);</span><br><span class="line">                abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="startDispatchCycleLocked"><a href="#startDispatchCycleLocked" class="headerlink" title="startDispatchCycleLocked"></a>startDispatchCycleLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            PointerCoords scaledCoords[MAX_POINTERS];</span><br><span class="line">            <span class="keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the X and Y offset depending on the input source.</span></span><br><span class="line">            <span class="keyword">float</span> xOffset, yOffset;</span><br><span class="line">            <span class="keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)</span><br><span class="line">                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;</span><br><span class="line">                <span class="keyword">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;</span><br><span class="line">                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;</span><br><span class="line">                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;</span><br><span class="line">                <span class="keyword">if</span> (scaleFactor != <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];</span><br><span class="line">                        scaledCoords[i].scale(scaleFactor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xOffset = <span class="number">0.0f</span>;</span><br><span class="line">                yOffset = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We don't want the dispatch target to know.</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i].clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the result.</span></span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;waitQueue.isEmpty()) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full. "</span></span><br><span class="line">                            <span class="string">"This is unexpected because the wait queue is empty, so the pipe "</span></span><br><span class="line">                            <span class="string">"should be empty and we shouldn't have any problems writing an "</span></span><br><span class="line">                            <span class="string">"event to it, status=%d"</span>, connection-&gt;getInputChannelName().c_str(),</span><br><span class="line">                            status);</span><br><span class="line">                    abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Pipe is full and we are waiting for the app to finish process some events</span></span><br><span class="line">                    <span class="comment">// before sending more events to it.</span></span><br><span class="line">#<span class="keyword">if</span> DEBUG_DISPATCH_CYCLE</span><br><span class="line">                    ALOGD(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full, "</span></span><br><span class="line">                            <span class="string">"waiting for the application to catch up"</span>,</span><br><span class="line">                            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    connection-&gt;inputPublisherBlocked = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Could not publish event due to an unexpected error, "</span></span><br><span class="line">                        <span class="string">"status=%d"</span>, connection-&gt;getInputChannelName().c_str(), status);</span><br><span class="line">                abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="handleReceiveCallback"><a href="#handleReceiveCallback" class="headerlink" title="handleReceiveCallback"></a>handleReceiveCallback</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> InputDispatcher::handleReceiveCallback(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    InputDispatcher* d = <span class="keyword">static_cast</span>&lt;InputDispatcher*&gt;(data);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(d-&gt;mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = d-&gt;mConnectionsByFd.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Received spurious receive callback for unknown input channel.  "</span></span><br><span class="line">                    <span class="string">"fd=%d, events=0x%x"</span>, fd, events);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> notify;</span><br><span class="line">        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        <span class="keyword">if</span> (!(events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(events &amp; ALOOPER_EVENT_INPUT)) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName().c_str(), events);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">            <span class="keyword">bool</span> gotOne = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">status_t</span> status;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> seq;</span><br><span class="line">                <span class="keyword">bool</span> handled;</span><br><span class="line">                status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);</span><br><span class="line">                <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);</span><br><span class="line">                gotOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotOne) &#123;</span><br><span class="line">                d-&gt;runCommandsLockedInterruptible();</span><br><span class="line">                <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notify = status != DEAD_OBJECT || !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Failed to receive finished signal.  status=%d"</span>,</span><br><span class="line">                        connection-&gt;getInputChannelName().c_str(), status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Monitor channels are never explicitly unregistered.</span></span><br><span class="line">            <span class="comment">// We do it automatically when the remote endpoint is closed so don't warn</span></span><br><span class="line">            <span class="comment">// about them.</span></span><br><span class="line">            notify = !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Consumer closed input channel or an error occurred.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName().c_str(), events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unregister the channel.</span></span><br><span class="line">        d-&gt;unregisterInputChannelLocked(connection-&gt;inputChannel, notify);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><blockquote><p>原文作者: Gowa2017 Zhang</p><p>原文链接: <a href="https://gowa.club/Android/InputService-安卓的输入系统.html">https://gowa.club/Android/InputService-安卓的输入系统.html</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/逆向/">逆向</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/Lua/luasocket中的http实现.html" class="pre">luasocket中的http实现</a><a href="/Android/安卓原生模拟器进行root操作.html" class="next">安卓原生模拟器进行root操作</a></div><div id="comments"><div id="disqus_thread"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#关于安卓的输入"><span class="toc-text">关于安卓的输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init"><span class="toc-text">init</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#app-process-命令"><span class="toc-text">app_process 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AppRuntime"><span class="toc-text">AppRuntime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AndroidRuntime"><span class="toc-text">AndroidRuntime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZygoteInit-main"><span class="toc-text">ZygoteInit.main()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZygoteServer-runSelectLoop"><span class="toc-text">ZygoteServer.runSelectLoop()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkSystemServer"><span class="toc-text">forkSystemServer()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#handleSystemServerProcess"><span class="toc-text">handleSystemServerProcess()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZygoteInit-zygoteInit"><span class="toc-text">ZygoteInit.zygoteInit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZygoteInit-nativeZygoteInit"><span class="toc-text">ZygoteInit.nativeZygoteInit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RuntimeInit-applicationInit"><span class="toc-text">RuntimeInit.applicationInit()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SystemServer-main"><span class="toc-text">SystemServer.main()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安卓的输入栈"><span class="toc-text">安卓的输入栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InputManagerService"><span class="toc-text">InputManagerService</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputManagerService-1"><span class="toc-text">InputManagerService()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nativeInit"><span class="toc-text">nativeInit()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NativeInputManager"><span class="toc-text">NativeInputManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventHub"><span class="toc-text">EventHub</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventHub-getEvents"><span class="toc-text">EventHub.getEvents()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设备扫描"><span class="toc-text">设备扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打开设备"><span class="toc-text">打开设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册到epoll监控事件"><span class="toc-text">注册到epoll监控事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputManager"><span class="toc-text">InputManager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputManagerService-start"><span class="toc-text">InputManagerService.start()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nativeStart"><span class="toc-text">nativeStart()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputReader"><span class="toc-text">InputReader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputReaderThread"><span class="toc-text">InputReaderThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputReader-loopOnce"><span class="toc-text">InputReader::loopOnce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputReader-processEventsLocked"><span class="toc-text">InputReader::processEventsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputReader-processEventsForDeviceLocked"><span class="toc-text">InputReader::processEventsForDeviceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputDevice-process"><span class="toc-text">InputDevice::process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardInputMapper-process"><span class="toc-text">KeyboardInputMapper::process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardInputMapper-processKey"><span class="toc-text">KeyboardInputMapper::processKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QueuedInputListener-notifyKey"><span class="toc-text">QueuedInputListener::notifyKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QueuedInputListener-flush"><span class="toc-text">QueuedInputListener::flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputDispatcher-notifyKey"><span class="toc-text">InputDispatcher::notifyKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NativeInputManager-interceptKeyBeforeQueueing"><span class="toc-text">NativeInputManager::interceptKeyBeforeQueueing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputManagerService-interceptKeyBeforeQueueing"><span class="toc-text">InputManagerService.interceptKeyBeforeQueueing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PhoneWindowManager-interceptKeyBeforeQueueing"><span class="toc-text">PhoneWindowManager:interceptKeyBeforeQueueing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputDispatcher-dispatchOnce"><span class="toc-text">InputDispatcher::dispatchOnce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputDispatcher-dispatchOnceInnerLocked"><span class="toc-text">InputDispatcher::dispatchOnceInnerLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputDispatcher-dispatchKeyLocked"><span class="toc-text">InputDispatcher::dispatchKeyLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findFocusedWindowTargetsLocked"><span class="toc-text">findFocusedWindowTargetsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchEventLocked"><span class="toc-text">dispatchEventLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prepareDispatchCycleLocked"><span class="toc-text">prepareDispatchCycleLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enqueueDispatchEntriesLocked"><span class="toc-text">enqueueDispatchEntriesLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#startDispatchCycleLocked"><span class="toc-text">startDispatchCycleLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#handleReceiveCallback"><span class="toc-text">handleReceiveCallback</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Android/Hooking-Linux中的共享库函数.html">Hooking-Linux中的共享库函数</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Riru来注入Zygote进程.html">Riru来注入Zygote进程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Android的权限检查过程.html">Android的权限检查过程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Android的服务管理.html">Android的服务管理</a></li><li class="post-list-item"><a class="post-list-link" href="/Cpp/使用Clang进行交叉编译.html">使用Clang进行交叉编译</a></li><li class="post-list-item"><a class="post-list-link" href="/Cocos-Creator/Cocos-Creator安卓下的启动流程.html">Cocos-Creator安卓下的启动流程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Android中模拟输入的实现.html">Android中模拟输入的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/Lua中的协程.html">Lua中的协程</a></li><li class="post-list-item"><a class="post-list-link" href="/Android/Auto.js截图后在相册无法立即显示.html">Auto.js截图后在相册无法立即显示</a></li><li class="post-list-item"><a class="post-list-link" href="/Lua/luasocket中的http实现.html">luasocket中的http实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Asm/">Asm</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos-Creator/">Cocos Creator</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-X/">Cocos2d-X</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Device/">Device</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GTD/">GTD</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kindle/">Kindle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Unix/">Linux/Unix</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS/">macOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">25</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Curl/" style="font-size: 15px;">Curl</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/brew/" style="font-size: 15px;">brew</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SED/" style="font-size: 15px;">SED</a> <a href="/tags/SHELL/" style="font-size: 15px;">SHELL</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/Cocos2d-X/" style="font-size: 15px;">Cocos2d-X</a> <a href="/tags/LVM/" style="font-size: 15px;">LVM</a> <a href="/tags/The-Java-Tutorial/" style="font-size: 15px;">The Java Tutorial</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Svn/" style="font-size: 15px;">Svn</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Docx/" style="font-size: 15px;">Docx</a> <a href="/tags/CentOS/" style="font-size: 15px;">CentOS</a> <a href="/tags/REST/" style="font-size: 15px;">REST</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/VNC/" style="font-size: 15px;">VNC</a> <a href="/tags/Poi/" style="font-size: 15px;">Poi</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/X5/" style="font-size: 15px;">X5</a> <a href="/tags/Tbs/" style="font-size: 15px;">Tbs</a> <a href="/tags/Cocos-Creator/" style="font-size: 15px;">Cocos Creator</a> <a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/ML/" style="font-size: 15px;">ML</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/KVM/" style="font-size: 15px;">KVM</a> <a href="/tags/Sqlplus/" style="font-size: 15px;">Sqlplus</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/Dagger/" style="font-size: 15px;">Dagger</a> <a href="/tags/PAC/" style="font-size: 15px;">PAC</a> <a href="/tags/Pandas/" style="font-size: 15px;">Pandas</a> <a href="/tags/NFS/" style="font-size: 15px;">NFS</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/Pomelo/" style="font-size: 15px;">Pomelo</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Gson/" style="font-size: 15px;">Gson</a> <a href="/tags/GTD/" style="font-size: 15px;">GTD</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Room/" style="font-size: 15px;">Room</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/MFC/" style="font-size: 15px;">MFC</a> <a href="/tags/Cpp/" style="font-size: 15px;">Cpp</a> <a href="/tags/ffmpeg/" style="font-size: 15px;">ffmpeg</a> <a href="/tags/PIL/" style="font-size: 15px;">PIL</a> <a href="/tags/Asm/" style="font-size: 15px;">Asm</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/Auto-js/" style="font-size: 15px;">Auto.js</a> <a href="/tags/Hooking/" style="font-size: 15px;">Hooking</a> <a href="/tags/Aix/" style="font-size: 15px;">Aix</a> <a href="/tags/RegEx/" style="font-size: 15px;">RegEx</a> <a href="/tags/Kindle/" style="font-size: 15px;">Kindle</a> <a href="/tags/F5/" style="font-size: 15px;">F5</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/AWK/" style="font-size: 15px;">AWK</a> <a href="/tags/Iptables/" style="font-size: 15px;">Iptables</a> <a href="/tags/Apue/" style="font-size: 15px;">Apue</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/OSPF/" style="font-size: 15px;">OSPF</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Oralce/" style="font-size: 15px;">Oralce</a> <a href="/tags/Device/" style="font-size: 15px;">Device</a> <a href="/tags/Raid/" style="font-size: 15px;">Raid</a> <a href="/tags/磁盘阵列/" style="font-size: 15px;">磁盘阵列</a> <a href="/tags/Syslog/" style="font-size: 15px;">Syslog</a> <a href="/tags/Tcpdump/" style="font-size: 15px;">Tcpdump</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Php/" style="font-size: 15px;">Php</a> <a href="/tags/设备信息查看/" style="font-size: 15px;">设备信息查看</a> <a href="/tags/Skynet/" style="font-size: 15px;">Skynet</a> <a href="/tags/Rsync/" style="font-size: 15px;">Rsync</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/networksetup/" style="font-size: 15px;">networksetup</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/VIM/" style="font-size: 15px;">VIM</a> <a href="/tags/DHCP/" style="font-size: 15px;">DHCP</a> <a href="/tags/PPPoE/" style="font-size: 15px;">PPPoE</a> <a href="/tags/launchd/" style="font-size: 15px;">launchd</a> <a href="/tags/So/" style="font-size: 15px;">So</a> <a href="/tags/Docx4j/" style="font-size: 15px;">Docx4j</a> <a href="/tags/Lsyncd/" style="font-size: 15px;">Lsyncd</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/Activiti/" style="font-size: 15px;">Activiti</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Gowa2017 Zhang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-137245514-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><<<<<<< Updated upstream<script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>var disqus_shortname = 'gowa-1';
var disqus_identifier = 'Android/InputService-安卓的输入系统.html';
var disqus_title = 'InputService-安卓的输入系统';
var disqus_url = 'https://gowa.club/Android/InputService-安卓的输入系统.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//gowa-1.disqus.com/count.js" async></script><script type="text/javascript" src="//gowa-1.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></body></html>