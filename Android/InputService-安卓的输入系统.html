<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="退思园" type="application/atom+xml">
  <meta name="google-site-verification" content="EDvvZZUFkxy_QUzZTaqwsG_9VHqFthY-NhQE4j6WL-s">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'LHD9LWONQ3',
      apiKey: '23a113c49e36d8cc93f61239cb530b43',
      indexName: 'gowa.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="我们来探究一下，从我们手指按压屏幕，到界面上做出响应，背后的过程是怎么样的。我们能否做到模拟一下这个过程呢？不过这又有想远了。在 Android系统的启动过程 我们介绍了安卓系统的启动过程。我们就以  InputManagerService 为例来看 一下服务的启动。">
<meta name="keywords" content="Android,逆向,Android Input">
<meta property="og:type" content="article">
<meta property="og:title" content="InputService-安卓的输入系统">
<meta property="og:url" content="https://gowa.club/Android/InputService-安卓的输入系统.html">
<meta property="og:site_name" content="退思园">
<meta property="og:description" content="我们来探究一下，从我们手指按压屏幕，到界面上做出响应，背后的过程是怎么样的。我们能否做到模拟一下这个过程呢？不过这又有想远了。在 Android系统的启动过程 我们介绍了安卓系统的启动过程。我们就以  InputManagerService 为例来看 一下服务的启动。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://gowa.club/res/image-20191113173055018.png">
<meta property="og:updated_time" content="2019-11-10T15:59:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="InputService-安卓的输入系统">
<meta name="twitter:description" content="我们来探究一下，从我们手指按压屏幕，到界面上做出响应，背后的过程是怎么样的。我们能否做到模拟一下这个过程呢？不过这又有想远了。在 Android系统的启动过程 我们介绍了安卓系统的启动过程。我们就以  InputManagerService 为例来看 一下服务的启动。">
<meta name="twitter:image" content="https://gowa.club/res/image-20191113173055018.png">

<link rel="canonical" href="https://gowa.club/Android/InputService-安卓的输入系统.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>InputService-安卓的输入系统 | 退思园</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137245514-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-137245514-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">退思园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">烦恼一般都是想太多了。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-soft">

    <a href="/soft/" rel="section"><i class="fa fa-fw fa-rocket"></i>soft</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gowa.club/Android/InputService-安卓的输入系统.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gowa2017 Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="退思园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          InputService-安卓的输入系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-10 23:59:44" itemprop="dateCreated datePublished" datetime="2019-11-10T23:59:44+08:00">2019-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/Android/InputService-安卓的输入系统.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/InputService-安卓的输入系统.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我们来探究一下，从我们手指按压屏幕，到界面上做出响应，背后的过程是怎么样的。我们能否做到模拟一下这个过程呢？不过这又有想远了。在 <a href="/Android/Android系统的启动过程.html" title="Android系统的启动过程">Android系统的启动过程</a> 我们介绍了安卓系统的启动过程。我们就以  InputManagerService 为例来看 一下服务的启动。</p>
<a id="more"></a>
<p>一直想来研究一下这个过程的，但是这个过程实在是复杂，在对 C 和 Linux<br>， Jni 不熟的情况下会是一脸懵逼的。但这个就需要从安卓系统的启动说起了。</p>
<h1 id="关于安卓的输入"><a href="#关于安卓的输入" class="headerlink" title="关于安卓的输入"></a>关于安卓的输入</h1><p><a href="https://source.android.com/devices/input/touch-devices" target="_blank" rel="noopener">官方有一个描述性的文档说明了输入过程</a>：</p>
<p>下面简要汇总了 Android 上的触摸设备操作。</p>
<ol>
<li><code>EventHub</code> 从 <code>evdev</code> 驱动程序读取原始事件。</li>
<li><code>InputReader</code> 消耗原始事件，并更新关于每个工具的位置和其他特征的内部状态。它还会跟踪按钮状态。</li>
<li>如果按下或释放“后退”或“前进”按钮，<code>InputReader</code> 会向 <code>InputDispatcher</code> 发出按键事件通知。</li>
<li><code>InputReader</code> 确定是否发生了虚拟按键的按压操作。如果是，它会向 <code>InputDispatcher</code> 发出按键事件通知。</li>
<li><code>InputReader</code> 确定触摸行为是否在显示范围内发起的。如果是，它会向 <code>InputDispatcher</code> 发出触摸事件通知。</li>
<li>如果没有触摸工具，但至少有一个悬停工具，则 <code>InputReader</code> 会向 <code>InputDispatcher</code> 发出悬停事件通知。</li>
<li>如果触摸设备类型是指控设备，则 <code>InputReader</code> 会执行指针手势检测，相应地移动指针和相关点，并通知 <code>InputDispatcher</code> 指针事件。</li>
<li><code>InputDispatcher</code> 使用 <code>WindowManagerPolicy</code> 来确定是否应该调度这些事件，以及它们是否应该唤醒设备。然后，<code>InputDispatcher</code> 将事件传递给相应的应用。</li>
</ol>
<h1 id="安卓的输入栈"><a href="#安卓的输入栈" class="headerlink" title="安卓的输入栈"></a>安卓的输入栈</h1><p><img src="../res/image-20191113173055018.png" alt="image-20191113173055018"></p>
<h1 id="InputManagerService"><a href="#InputManagerService" class="headerlink" title="InputManagerService"></a>InputManagerService</h1><p>这个服务在 <code>startOtherService()</code> 中启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputManagerService inputManager = <span class="keyword">null</span>;</span><br><span class="line">WindowManagerService wm = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartInputManagerService"</span>);</span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">    wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">            !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());</span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">            <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartInputManager"</span>);</span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">    inputManager.start();</span><br><span class="line">    traceEnd();</span><br></pre></td></tr></table></figure>
<p>可以看到， InputManagerService 与 WindowManagerService 是相互持有，相互通信的。</p>
<p>InputManagerService 的回调设置成了 WindowManagerService 的监控器。</p>
<h2 id="InputManagerService-1"><a href="#InputManagerService-1" class="headerlink" title="InputManagerService()"></a>InputManagerService()</h2><p>InputManagerService 服务的初始化，实际上还会在 C 层面有一个对象来关联，而 InputManagerService 则通过 一个 C 指针 <strong>mPtr</strong>来进行引用**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    mUseDevInputEventForAudioJack =</span><br><span class="line">            context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line">    Slog.i(TAG, <span class="string">"Initializing input manager, mUseDevInputEventForAudioJack="</span></span><br><span class="line">            + mUseDevInputEventForAudioJack);</span><br><span class="line">    mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">    String doubleTouchGestureEnablePath = context.getResources().getString(</span><br><span class="line">            R.string.config_doubleTouchGestureEnableFile);</span><br><span class="line">    mDoubleTouchGestureEnableFile = TextUtils.isEmpty(doubleTouchGestureEnablePath) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> File(doubleTouchGestureEnablePath);</span><br><span class="line"></span><br><span class="line">    LocalServices.addService(InputManagerInternal<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalService</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nativeInit"><a href="#nativeInit" class="headerlink" title="nativeInit()"></a>nativeInit()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NativeInputManager"><a href="#NativeInputManager" class="headerlink" title="NativeInputManager"></a>NativeInputManager</h3><p>NativeInputManager 属于 C 层的输入管理器，用来管理相关输入逻辑。其构造了一个 InputManager 来管理 EventHub 上的事件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">        mLocked.pointerCapture = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInteractive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EventHub"><a href="#EventHub" class="headerlink" title="EventHub"></a>EventHub</h3><p>EventHub 会监控 <code>/dev/input</code> 目录下的删除和新建事件，同时还建立了一个管道，根据管道是否有数据来确定是否有唤醒事件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/native/services/inputflinger/EventHub.cpp#201</span></span><br><span class="line"></span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventHub-getEvents"><a href="#EventHub-getEvents" class="headerlink" title="EventHub.getEvents()"></a>EventHub.getEvents()</h4><p>EventHub 在构造的时候会监控 /dev/input 目录的新增和删除事件，还会监控一个管道 mWakeReadPipeFd 的数据到达事件。但是，这个时候实际上还没有将所有的设备监控起来，只有在我们第一地调用这个方法的时候，会进行设备的扫描。</p>
<p>在这里面如果没有其他事件，只是获取事件的话，那么会调用  epoll_wait 等待事件到达。如果有事件，会将事件放到 buff 里面，供 InputReader 使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis, RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line">    ALOG_ASSERT(bufferSize &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">readBuffer</span>[<span class="title">bufferSize</span>];</span></span><br><span class="line"></span><br><span class="line">    RawEvent* event = buffer;</span><br><span class="line">    <span class="keyword">size_t</span> capacity = bufferSize;</span><br><span class="line">    <span class="keyword">bool</span> awoken = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reopen input devices if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedToReopenDevices) &#123;</span><br><span class="line">            mNeedToReopenDevices = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            ALOGI(<span class="string">"Reopening all input devices due to a configuration change."</span>);</span><br><span class="line"></span><br><span class="line">            closeAllDevicesLocked();</span><br><span class="line">            mNeedToScanDevices = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// return to the caller before we actually rescan</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Report any devices that had last been added/removed.</span></span><br><span class="line">        <span class="keyword">while</span> (mClosingDevices) &#123;</span><br><span class="line">            Device* device = mClosingDevices;</span><br><span class="line">            ALOGV(<span class="string">"Reporting device closed: id=%d, name=%s\n"</span>,</span><br><span class="line">                 device-&gt;id, device-&gt;path.<span class="built_in">string</span>());</span><br><span class="line">            mClosingDevices = device-&gt;next;</span><br><span class="line">            event-&gt;when = now;</span><br><span class="line">            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id;</span><br><span class="line">            event-&gt;type = DEVICE_REMOVED;</span><br><span class="line">            event += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">delete</span> device;</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 第一次调用的时候，会执行这里，进行设备的扫描</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedToScanDevices) &#123;</span><br><span class="line">            mNeedToScanDevices = <span class="literal">false</span>;</span><br><span class="line">            scanDevicesLocked();</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mOpeningDevices != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Device* device = mOpeningDevices;</span><br><span class="line">            ALOGV(<span class="string">"Reporting device opened: id=%d, name=%s\n"</span>,</span><br><span class="line">                 device-&gt;id, device-&gt;path.<span class="built_in">string</span>());</span><br><span class="line">            mOpeningDevices = device-&gt;next;</span><br><span class="line">            event-&gt;when = now;</span><br><span class="line">            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="number">0</span> : device-&gt;id;</span><br><span class="line">            event-&gt;type = DEVICE_ADDED;</span><br><span class="line">            event += <span class="number">1</span>;</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNeedToSendFinishedDeviceScan) &#123;</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">false</span>;</span><br><span class="line">            event-&gt;when = now;</span><br><span class="line">            event-&gt;type = FINISHED_DEVICE_SCAN;</span><br><span class="line">            event += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Grab the next input event.</span></span><br><span class="line">        <span class="keyword">bool</span> deviceChanged = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> = <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line">            <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">                    mPendingINotify = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for INotify."</span>, eventItem.events);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_WAKE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">                    ALOGV(<span class="string">"awoken after wake()"</span>);</span><br><span class="line">                    awoken = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">                    <span class="keyword">ssize_t</span> nRead;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for wake read pipe."</span>,</span><br><span class="line">                            eventItem.events);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(eventItem.data.u32);</span><br><span class="line">            <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for unknown device id %d."</span>,</span><br><span class="line">                        eventItem.events, eventItem.data.u32);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Device* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">            <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="keyword">int32_t</span> readSize = read(device-&gt;fd, readBuffer,</span><br><span class="line">                        <span class="keyword">sizeof</span>(struct input_event) * capacity);</span><br><span class="line">                <span class="keyword">if</span> (readSize == <span class="number">0</span> || (readSize &lt; <span class="number">0</span> &amp;&amp; errno == ENODEV)) &#123;</span><br><span class="line">                    <span class="comment">// Device was removed before INotify noticed.</span></span><br><span class="line">                    ALOGW(<span class="string">"could not get event, removed? (fd: %d size: %"</span> PRId32</span><br><span class="line">                            <span class="string">" bufferSize: %zu capacity: %zu errno: %d)\n"</span>,</span><br><span class="line">                            device-&gt;fd, readSize, bufferSize, capacity, errno);</span><br><span class="line">                    deviceChanged = <span class="literal">true</span>;</span><br><span class="line">                    closeDeviceLocked(device);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"could not get event (errno=%d)"</span>, errno);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((readSize % <span class="keyword">sizeof</span>(struct input_event)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"could not get event (wrong size: %d)"</span>, readSize);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int32_t</span> deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="number">0</span> : device-&gt;id;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">size_t</span> count = <span class="keyword">size_t</span>(readSize) / <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span>&amp; <span class="title">iev</span> = <span class="title">readBuffer</span>[<span class="title">i</span>];</span></span><br><span class="line">                        ALOGV(<span class="string">"%s got: time=%d.%06d, type=%d, code=%d, value=%d"</span>,</span><br><span class="line">                                device-&gt;path.<span class="built_in">string</span>(),</span><br><span class="line">                                (<span class="keyword">int</span>) iev.time.tv_sec, (<span class="keyword">int</span>) iev.time.tv_usec,</span><br><span class="line">                                iev.type, iev.code, iev.value);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Some input devices may have a better concept of the time</span></span><br><span class="line">                        <span class="comment">// when an input event was actually generated than the kernel</span></span><br><span class="line">                        <span class="comment">// which simply timestamps all events on entry to evdev.</span></span><br><span class="line">                        <span class="comment">// This is a custom Android extension of the input protocol</span></span><br><span class="line">                        <span class="comment">// mainly intended for use with uinput based device drivers.</span></span><br><span class="line">                        <span class="keyword">if</span> (iev.type == EV_MSC) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (iev.code == MSC_ANDROID_TIME_SEC) &#123;</span><br><span class="line">                                device-&gt;timestampOverrideSec = iev.value;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iev.code == MSC_ANDROID_TIME_USEC) &#123;</span><br><span class="line">                                device-&gt;timestampOverrideUsec = iev.value;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (device-&gt;timestampOverrideSec || device-&gt;timestampOverrideUsec) &#123;</span><br><span class="line">                            iev.time.tv_sec = device-&gt;timestampOverrideSec;</span><br><span class="line">                            iev.time.tv_usec = device-&gt;timestampOverrideUsec;</span><br><span class="line">                            <span class="keyword">if</span> (iev.type == EV_SYN &amp;&amp; iev.code == SYN_REPORT) &#123;</span><br><span class="line">                                device-&gt;timestampOverrideSec = <span class="number">0</span>;</span><br><span class="line">                                device-&gt;timestampOverrideUsec = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ALOGV(<span class="string">"applied override time %d.%06d"</span>,</span><br><span class="line">                                    <span class="keyword">int</span>(iev.time.tv_sec), <span class="keyword">int</span>(iev.time.tv_usec));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Use the time specified in the event instead of the current time</span></span><br><span class="line">                        <span class="comment">// so that downstream code can get more accurate estimates of</span></span><br><span class="line">                        <span class="comment">// event dispatch latency from the time the event is enqueued onto</span></span><br><span class="line">                        <span class="comment">// the evdev client buffer.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// The event's timestamp fortuitously uses the same monotonic clock</span></span><br><span class="line">                        <span class="comment">// time base as the rest of Android.  The kernel event device driver</span></span><br><span class="line">                        <span class="comment">// (drivers/input/evdev.c) obtains timestamps using ktime_get_ts().</span></span><br><span class="line">                        <span class="comment">// The systemTime(SYSTEM_TIME_MONOTONIC) function we use everywhere</span></span><br><span class="line">                        <span class="comment">// calls clock_gettime(CLOCK_MONOTONIC) which is implemented as a</span></span><br><span class="line">                        <span class="comment">// system call that also queries ktime_get_ts().</span></span><br><span class="line">                        event-&gt;when = <span class="keyword">nsecs_t</span>(iev.time.tv_sec) * <span class="number">1000000000L</span>L</span><br><span class="line">                                + <span class="keyword">nsecs_t</span>(iev.time.tv_usec) * <span class="number">1000L</span>L;</span><br><span class="line">                        ALOGV(<span class="string">"event time %"</span> PRId64 <span class="string">", now %"</span> PRId64, event-&gt;when, now);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Bug 7291243: Add a guard in case the kernel generates timestamps</span></span><br><span class="line">                        <span class="comment">// that appear to be far into the future because they were generated</span></span><br><span class="line">                        <span class="comment">// using the wrong clock source.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// This can happen because when the input device is initially opened</span></span><br><span class="line">                        <span class="comment">// it has a default clock source of CLOCK_REALTIME.  Any input events</span></span><br><span class="line">                        <span class="comment">// enqueued right after the device is opened will have timestamps</span></span><br><span class="line">                        <span class="comment">// generated using CLOCK_REALTIME.  We later set the clock source</span></span><br><span class="line">                        <span class="comment">// to CLOCK_MONOTONIC but it is already too late.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// Invalid input event timestamps can result in ANRs, crashes and</span></span><br><span class="line">                        <span class="comment">// and other issues that are hard to track down.  We must not let them</span></span><br><span class="line">                        <span class="comment">// propagate through the system.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// Log a warning so that we notice the problem and recover gracefully.</span></span><br><span class="line">                        <span class="keyword">if</span> (event-&gt;when &gt;= now + <span class="number">10</span> * <span class="number">1000000000L</span>L) &#123;</span><br><span class="line">                            <span class="comment">// Double-check.  Time may have moved on.</span></span><br><span class="line">                            <span class="keyword">nsecs_t</span> time = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                            <span class="keyword">if</span> (event-&gt;when &gt; time) &#123;</span><br><span class="line">                                ALOGW(<span class="string">"An input event from %s has a timestamp that appears to "</span></span><br><span class="line">                                        <span class="string">"have been generated using the wrong clock source "</span></span><br><span class="line">                                        <span class="string">"(expected CLOCK_MONOTONIC): "</span></span><br><span class="line">                                        <span class="string">"event time %"</span> PRId64 <span class="string">", current time %"</span> PRId64</span><br><span class="line">                                        <span class="string">", call time %"</span> PRId64 <span class="string">".  "</span></span><br><span class="line">                                        <span class="string">"Using current time instead."</span>,</span><br><span class="line">                                        device-&gt;path.<span class="built_in">string</span>(), event-&gt;when, time, now);</span><br><span class="line">                                event-&gt;when = time;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ALOGV(<span class="string">"Event time is ok but failed the fast path and required "</span></span><br><span class="line">                                        <span class="string">"an extra call to systemTime: "</span></span><br><span class="line">                                        <span class="string">"event time %"</span> PRId64 <span class="string">", current time %"</span> PRId64</span><br><span class="line">                                        <span class="string">", call time %"</span> PRId64 <span class="string">"."</span>,</span><br><span class="line">                                        event-&gt;when, time, now);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        event-&gt;deviceId = deviceId;</span><br><span class="line">                        event-&gt;type = iev.type;</span><br><span class="line">                        event-&gt;code = iev.code;</span><br><span class="line">                        event-&gt;value = iev.value;</span><br><span class="line">                        event += <span class="number">1</span>;</span><br><span class="line">                        capacity -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// The result buffer is full.  Reset the pending event index</span></span><br><span class="line">                        <span class="comment">// so we will try to read the device again on the next iteration.</span></span><br><span class="line">                        mPendingEventIndex -= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventItem.events &amp; EPOLLHUP) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Removing device %s due to epoll hang-up event."</span>,</span><br><span class="line">                        device-&gt;identifier.name.<span class="built_in">string</span>());</span><br><span class="line">                deviceChanged = <span class="literal">true</span>;</span><br><span class="line">                closeDeviceLocked(device);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for device %s."</span>,</span><br><span class="line">                        eventItem.events, device-&gt;identifier.name.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// readNotify() will modify the list of devices so this must be done after</span></span><br><span class="line">        <span class="comment">// processing all other events to ensure that we read all remaining events</span></span><br><span class="line">        <span class="comment">// before closing the devices.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;</span><br><span class="line">            mPendingINotify = <span class="literal">false</span>;</span><br><span class="line">            readNotifyLocked();</span><br><span class="line">            deviceChanged = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Report added or removed devices immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (deviceChanged) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return now if we have collected any events or if we were explicitly awoken.</span></span><br><span class="line">        <span class="keyword">if</span> (event != buffer || awoken) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll for events.  Mind the wake lock dance!</span></span><br><span class="line">        <span class="comment">// We hold a wake lock at all times except during epoll_wait().  This works due to some</span></span><br><span class="line">        <span class="comment">// subtle choreography.  When a device driver has pending (unread) events, it acquires</span></span><br><span class="line">        <span class="comment">// a kernel wake lock.  However, once the last pending event has been read, the device</span></span><br><span class="line">        <span class="comment">// driver will release the kernel wake lock.  To prevent the system from going to sleep</span></span><br><span class="line">        <span class="comment">// when this happens, the EventHub holds onto its own user wake lock while the client</span></span><br><span class="line">        <span class="comment">// is processing events.  Thus the system can only sleep if there are no events</span></span><br><span class="line">        <span class="comment">// pending or currently being processed.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The timeout is advisory only.  If the device is asleep, it will not wake just to</span></span><br><span class="line">        <span class="comment">// service the timeout.</span></span><br><span class="line">        mPendingEventIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mLock.unlock(); <span class="comment">// release lock before poll, must be before release_wake_lock</span></span><br><span class="line">        release_wake_lock(WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">        acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line">        mLock.lock(); <span class="comment">// reacquire lock after poll, must be after acquire_wake_lock</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollResult == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Timed out.</span></span><br><span class="line">            mPendingEventCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// An error occurred.</span></span><br><span class="line">            mPendingEventCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sleep after errors to avoid locking up the system.</span></span><br><span class="line">            <span class="comment">// Hopefully the error is transient.</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">                ALOGW(<span class="string">"poll failed (errno=%d)\n"</span>, errno);</span><br><span class="line">                usleep(<span class="number">100000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Some events occurred.</span></span><br><span class="line">            mPendingEventCount = <span class="keyword">size_t</span>(pollResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All done, return the number of events we read.</span></span><br><span class="line">    <span class="keyword">return</span> event - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设备扫描"><a href="#设备扫描" class="headerlink" title="设备扫描"></a>设备扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventHub::scanDevicesLocked() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = scanDirLocked(DEVICE_PATH);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"scan dir failed for %s\n"</span>, DEVICE_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        createVirtualKeyboardLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> EventHub::scanDirLocked(<span class="keyword">const</span> <span class="keyword">char</span> *dirname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> devname[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> *filename;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    dir = opendir(dirname);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(devname, dirname);</span><br><span class="line">    filename = devname + <span class="built_in">strlen</span>(devname);</span><br><span class="line">    *filename++ = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">while</span>((de = readdir(dir))) &#123;</span><br><span class="line">        <span class="keyword">if</span>(de-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp;</span><br><span class="line">           (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'\0'</span> ||</span><br><span class="line">            (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; de-&gt;d_name[<span class="number">2</span>] == <span class="string">'\0'</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, de-&gt;d_name);</span><br><span class="line">        openDeviceLocked(devname);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventHub::openDeviceLocked(<span class="keyword">const</span> <span class="keyword">char</span> *devicePath) &#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Opening device: %s"</span>, devicePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(devicePath, O_RDWR | O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not open %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDeviceIdentifier identifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device name.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGNAME(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get device name for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.name.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if the device is on our excluded list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mExcludedDevices.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; item = mExcludedDevices.itemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (identifier.name == item) &#123;</span><br><span class="line">            ALOGI(<span class="string">"ignoring event id %s driver %s\n"</span>, devicePath, item.<span class="built_in">string</span>());</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device driver version.</span></span><br><span class="line">    <span class="keyword">int</span> driverVersion;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGVERSION, &amp;driverVersion)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not get driver version for %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device identifier.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">inputId</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGID, &amp;inputId)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not get device input id for %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    identifier.bus = inputId.bustype;</span><br><span class="line">    identifier.product = inputId.product;</span><br><span class="line">    identifier.vendor = inputId.vendor;</span><br><span class="line">    identifier.version = inputId.version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device physical location.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGPHYS(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get location for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.location.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device unique id.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGUNIQ(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get idstring for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.uniqueId.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill in the descriptor.</span></span><br><span class="line">    assignDescriptorLocked(identifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device.  (The device object takes ownership of the fd at this point.)</span></span><br><span class="line">    <span class="keyword">int32_t</span> deviceId = mNextDeviceId++;</span><br><span class="line">    Device* device = <span class="keyword">new</span> Device(fd, deviceId, String8(devicePath), identifier);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"add device %d: %s\n"</span>, deviceId, devicePath);</span><br><span class="line">    ALOGV(<span class="string">"  bus:        %04x\n"</span></span><br><span class="line">         <span class="string">"  vendor      %04x\n"</span></span><br><span class="line">         <span class="string">"  product     %04x\n"</span></span><br><span class="line">         <span class="string">"  version     %04x\n"</span>,</span><br><span class="line">        identifier.bus, identifier.vendor, identifier.product, identifier.version);</span><br><span class="line">    ALOGV(<span class="string">"  name:       \"%s\"\n"</span>, identifier.name.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  location:   \"%s\"\n"</span>, identifier.location.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  unique id:  \"%s\"\n"</span>, identifier.uniqueId.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  descriptor: \"%s\"\n"</span>, identifier.descriptor.<span class="built_in">string</span>());</span><br><span class="line">    ALOGV(<span class="string">"  driver:     v%d.%d.%d\n"</span>,</span><br><span class="line">        driverVersion &gt;&gt; <span class="number">16</span>, (driverVersion &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>, driverVersion &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the configuration file for the device.</span></span><br><span class="line">    loadConfigurationLocked(device);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out the kinds of events the device reports.</span></span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_KEY, <span class="keyword">sizeof</span>(device-&gt;keyBitmask)), device-&gt;keyBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_ABS, <span class="keyword">sizeof</span>(device-&gt;absBitmask)), device-&gt;absBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_REL, <span class="keyword">sizeof</span>(device-&gt;relBitmask)), device-&gt;relBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_SW, <span class="keyword">sizeof</span>(device-&gt;swBitmask)), device-&gt;swBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_LED, <span class="keyword">sizeof</span>(device-&gt;ledBitmask)), device-&gt;ledBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGBIT(EV_FF, <span class="keyword">sizeof</span>(device-&gt;ffBitmask)), device-&gt;ffBitmask);</span><br><span class="line">    ioctl(fd, EVIOCGPROP(<span class="keyword">sizeof</span>(device-&gt;propBitmask)), device-&gt;propBitmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a keyboard.  Ignore everything in the button range except for</span></span><br><span class="line">    <span class="comment">// joystick and gamepad buttons which are handled like keyboards for the most part.</span></span><br><span class="line">    <span class="keyword">bool</span> haveKeyboardKeys = containsNonZeroByte(device-&gt;keyBitmask, <span class="number">0</span>, sizeof_bit_array(BTN_MISC))</span><br><span class="line">            || containsNonZeroByte(device-&gt;keyBitmask, sizeof_bit_array(KEY_OK),</span><br><span class="line">                    sizeof_bit_array(KEY_MAX + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">bool</span> haveGamepadButtons = containsNonZeroByte(device-&gt;keyBitmask, sizeof_bit_array(BTN_MISC),</span><br><span class="line">                    sizeof_bit_array(BTN_MOUSE))</span><br><span class="line">            || containsNonZeroByte(device-&gt;keyBitmask, sizeof_bit_array(BTN_JOYSTICK),</span><br><span class="line">                    sizeof_bit_array(BTN_DIGI));</span><br><span class="line">    <span class="keyword">if</span> (haveKeyboardKeys || haveGamepadButtons) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_KEYBOARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a cursor device such as a trackball or mouse.</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(BTN_MOUSE, device-&gt;keyBitmask)</span><br><span class="line">            &amp;&amp; test_bit(REL_X, device-&gt;relBitmask)</span><br><span class="line">            &amp;&amp; test_bit(REL_Y, device-&gt;relBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_CURSOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a rotary encoder type device.</span></span><br><span class="line">    String8 deviceType = String8();</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;configuration &amp;&amp;</span><br><span class="line">        device-&gt;configuration-&gt;tryGetProperty(String8(<span class="string">"device.type"</span>), deviceType)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!deviceType.compare(String8(<span class="string">"rotaryEncoder"</span>))) &#123;</span><br><span class="line">                device-&gt;classes |= INPUT_DEVICE_CLASS_ROTARY_ENCODER;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this is a touch pad.</span></span><br><span class="line">    <span class="comment">// Is this a new modern multi-touch driver?</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(ABS_MT_POSITION_X, device-&gt;absBitmask)</span><br><span class="line">            &amp;&amp; test_bit(ABS_MT_POSITION_Y, device-&gt;absBitmask)) &#123;</span><br><span class="line">        <span class="comment">// Some joysticks such as the PS3 controller report axes that conflict</span></span><br><span class="line">        <span class="comment">// with the ABS_MT range.  Try to confirm that the device really is</span></span><br><span class="line">        <span class="comment">// a touch screen.</span></span><br><span class="line">        <span class="keyword">if</span> (test_bit(BTN_TOUCH, device-&gt;keyBitmask) || !haveGamepadButtons) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_TOUCH | INPUT_DEVICE_CLASS_TOUCH_MT;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// Is this an old style single-touch driver?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_bit(BTN_TOUCH, device-&gt;keyBitmask)</span><br><span class="line">            &amp;&amp; test_bit(ABS_X, device-&gt;absBitmask)</span><br><span class="line">            &amp;&amp; test_bit(ABS_Y, device-&gt;absBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_TOUCH;</span><br><span class="line">    <span class="comment">// Is this a BT stylus?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test_bit(ABS_PRESSURE, device-&gt;absBitmask) ||</span><br><span class="line">                test_bit(BTN_TOUCH, device-&gt;keyBitmask))</span><br><span class="line">            &amp;&amp; !test_bit(ABS_X, device-&gt;absBitmask)</span><br><span class="line">            &amp;&amp; !test_bit(ABS_Y, device-&gt;absBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_EXTERNAL_STYLUS;</span><br><span class="line">        <span class="comment">// Keyboard will try to claim some of the buttons but we really want to reserve those so we</span></span><br><span class="line">        <span class="comment">// can fuse it with the touch screen data, so just take them back. Note this means an</span></span><br><span class="line">        <span class="comment">// external stylus cannot also be a keyboard device.</span></span><br><span class="line">        device-&gt;classes &amp;= ~INPUT_DEVICE_CLASS_KEYBOARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if this device is a joystick.</span></span><br><span class="line">    <span class="comment">// Assumes that joysticks always have gamepad buttons in order to distinguish them</span></span><br><span class="line">    <span class="comment">// from other devices such as accelerometers that also have absolute axes.</span></span><br><span class="line">    <span class="keyword">if</span> (haveGamepadButtons) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> assumedClasses = device-&gt;classes | INPUT_DEVICE_CLASS_JOYSTICK;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ABS_MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (test_bit(i, device-&gt;absBitmask)</span><br><span class="line">                    &amp;&amp; (getAbsAxisUsage(i, assumedClasses) &amp; INPUT_DEVICE_CLASS_JOYSTICK)) &#123;</span><br><span class="line">                device-&gt;classes = assumedClasses;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether this device has switches.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= SW_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test_bit(i, device-&gt;swBitmask)) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_SWITCH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether this device supports the vibrator.</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(FF_RUMBLE, device-&gt;ffBitmask)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_VIBRATOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure virtual keys.</span></span><br><span class="line">    <span class="keyword">if</span> ((device-&gt;classes &amp; INPUT_DEVICE_CLASS_TOUCH)) &#123;</span><br><span class="line">        <span class="comment">// Load the virtual keys for the touch screen, if any.</span></span><br><span class="line">        <span class="comment">// We do this now so that we can make sure to load the keymap if necessary.</span></span><br><span class="line">        <span class="keyword">status_t</span> status = loadVirtualKeyMapLocked(device);</span><br><span class="line">        <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_KEYBOARD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the key map.</span></span><br><span class="line">    <span class="comment">// We need to do this for joysticks too because the key layout may specify axes.</span></span><br><span class="line">    <span class="keyword">status_t</span> keyMapStatus = NAME_NOT_FOUND;</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes &amp; (INPUT_DEVICE_CLASS_KEYBOARD | INPUT_DEVICE_CLASS_JOYSTICK)) &#123;</span><br><span class="line">        <span class="comment">// Load the keymap for the device.</span></span><br><span class="line">        keyMapStatus = loadKeyMapLocked(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the keyboard, gamepad or virtual keyboard.</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes &amp; INPUT_DEVICE_CLASS_KEYBOARD) &#123;</span><br><span class="line">        <span class="comment">// Register the keyboard as a built-in keyboard if it is eligible.</span></span><br><span class="line">        <span class="keyword">if</span> (!keyMapStatus</span><br><span class="line">                &amp;&amp; mBuiltInKeyboardId == NO_BUILT_IN_KEYBOARD</span><br><span class="line">                &amp;&amp; isEligibleBuiltInKeyboard(device-&gt;identifier,</span><br><span class="line">                        device-&gt;configuration, &amp;device-&gt;keyMap)) &#123;</span><br><span class="line">            mBuiltInKeyboardId = device-&gt;id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'Q' key support = cheap test of whether this is an alpha-capable kbd</span></span><br><span class="line">        <span class="keyword">if</span> (hasKeycodeLocked(device, AKEYCODE_Q)) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_ALPHAKEY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See if this device has a DPAD.</span></span><br><span class="line">        <span class="keyword">if</span> (hasKeycodeLocked(device, AKEYCODE_DPAD_UP) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_DOWN) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_LEFT) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_RIGHT) &amp;&amp;</span><br><span class="line">                hasKeycodeLocked(device, AKEYCODE_DPAD_CENTER)) &#123;</span><br><span class="line">            device-&gt;classes |= INPUT_DEVICE_CLASS_DPAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See if this device has a gamepad.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(GAMEPAD_KEYCODES)/<span class="keyword">sizeof</span>(GAMEPAD_KEYCODES[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasKeycodeLocked(device, GAMEPAD_KEYCODES[i])) &#123;</span><br><span class="line">                device-&gt;classes |= INPUT_DEVICE_CLASS_GAMEPAD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the device isn't recognized as something we handle, don't monitor it.</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"Dropping device: id=%d, path='%s', name='%s'"</span>,</span><br><span class="line">                deviceId, devicePath, device-&gt;identifier.name.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">delete</span> device;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether the device has a mic.</span></span><br><span class="line">    <span class="keyword">if</span> (deviceHasMicLocked(device)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_MIC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether the device is external or internal.</span></span><br><span class="line">    <span class="keyword">if</span> (isExternalDeviceLocked(device)) &#123;</span><br><span class="line">        device-&gt;classes |= INPUT_DEVICE_CLASS_EXTERNAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;classes &amp; (INPUT_DEVICE_CLASS_JOYSTICK | INPUT_DEVICE_CLASS_DPAD)</span><br><span class="line">            &amp;&amp; device-&gt;classes &amp; INPUT_DEVICE_CLASS_GAMEPAD) &#123;</span><br><span class="line">        device-&gt;controllerNumber = getNextControllerNumberLocked(device);</span><br><span class="line">        setLedForControllerLocked(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registerDeviceForEpollLocked(device) != OK) &#123;</span><br><span class="line">        <span class="keyword">delete</span> device;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configureFd(device);</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"New device: id=%d, fd=%d, path='%s', name='%s', classes=0x%x, "</span></span><br><span class="line">            <span class="string">"configuration='%s', keyLayout='%s', keyCharacterMap='%s', builtinKeyboard=%s, "</span>,</span><br><span class="line">         deviceId, fd, devicePath, device-&gt;identifier.name.<span class="built_in">string</span>(),</span><br><span class="line">         device-&gt;classes,</span><br><span class="line">         device-&gt;configurationFile.<span class="built_in">string</span>(),</span><br><span class="line">         device-&gt;keyMap.keyLayoutFile.<span class="built_in">string</span>(),</span><br><span class="line">         device-&gt;keyMap.keyCharacterMapFile.<span class="built_in">string</span>(),</span><br><span class="line">         toString(mBuiltInKeyboardId == deviceId));</span><br><span class="line"></span><br><span class="line">    addDeviceLocked(device);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到设备列表</span></span><br><span class="line"><span class="keyword">void</span> EventHub::addDeviceLocked(Device* device) &#123;</span><br><span class="line">    mDevices.add(device-&gt;id, device);</span><br><span class="line">    device-&gt;next = mOpeningDevices;</span><br><span class="line">    mOpeningDevices = device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册到epoll监控事件"><a href="#注册到epoll监控事件" class="headerlink" title="注册到epoll监控事件"></a>注册到epoll监控事件</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventHub::registerDeviceForEpollLocked(Device* device) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mUsingEpollWakeup) &#123;</span><br><span class="line">        eventItem.events |= EPOLLWAKEUP;</span><br><span class="line">    &#125;</span><br><span class="line">    eventItem.data.u32 = device-&gt;id;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(mEpollFd, EPOLL_CTL_ADD, device-&gt;fd, &amp;eventItem)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not add device fd to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InputManager"><a href="#InputManager" class="headerlink" title="InputManager"></a>InputManager</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://androidxref.com/9.0.0_r3/xref/frameworks/native/services/inputflinger/InputManager.cpp</span></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputManager 建立了一个 InputReader 进行读取输入，一个 InputDispatcher 进行分发输出。同时，将 InputReader 的回调设置为 InputDispatcher。</p>
<p>同时开启了两个线程：InputReaderThread，InputDispatcherThread。</p>
<h2 id="InputManagerService-start"><a href="#InputManagerService-start" class="headerlink" title="InputManagerService.start()"></a>InputManagerService.start()</h2><p>InputManagerService 会先启动 C 层的服务，再进行 Java 层的操作。主要是注册了几个设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Starting input manager"</span>);</span><br><span class="line">        nativeStart(mPtr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">        Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        registerPointerSpeedSettingObserver();</span><br><span class="line">        registerShowTouchesSettingObserver();</span><br><span class="line">        registerAccessibilityLargePointerSettingObserver();</span><br><span class="line"></span><br><span class="line">        mContext.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">                updatePointerSpeedFromSettings();</span><br><span class="line">                updateShowTouchesFromSettings();</span><br><span class="line">                updateAccessibilityLargePointerFromSettings();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_SWITCHED), <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">        updatePointerSpeedFromSettings();</span><br><span class="line">        updateShowTouchesFromSettings();</span><br><span class="line">        updateAccessibilityLargePointerFromSettings();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="nativeStart"><a href="#nativeStart" class="headerlink" title="nativeStart()"></a>nativeStart()</h3><p>在 C 层面，将输入事件读取线程，分发线程都启动了起来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not start InputDispatcher thread due to error %d."</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not start InputReader thread due to error %d."</span>, result);</span><br><span class="line"></span><br><span class="line">        mDispatcherThread-&gt;requestExit();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h2><p>InputReader 在构造的时候，会有一个队列，队列的回调就是 Dipatcher：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputReaderThread"><a href="#InputReaderThread" class="headerlink" title="InputReaderThread"></a>InputReaderThread</h2><p>InputReaderThread 继承自 <strong>utils/thread.h</strong>中的  Thread。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/system/core/include/utils/Thread.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Create a Thread object, but doesn't create or start the associated</span></span><br><span class="line">    <span class="comment">// thread. See the run() method.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span>            <span class="title">Thread</span><span class="params">(<span class="keyword">bool</span> canCallJava = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span>             ~Thread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t    <span class="title">run</span><span class="params">(    <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="built_in">stack</span> = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask this object's thread to exit. This function is asynchronous, when the</span></span><br><span class="line">    <span class="comment">// function returns the thread might still be running. Of course, this</span></span><br><span class="line">    <span class="comment">// function can be called from a different thread.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>        <span class="title">requestExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Good place to do one-time initializations</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t    <span class="title">readyToRun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call requestExit() and wait until this object's thread exits.</span></span><br><span class="line">    <span class="comment">// BE VERY CAREFUL of deadlocks. In particular, it would be silly to call</span></span><br><span class="line">    <span class="comment">// this function from this object's thread. Will return WOULD_BLOCK in</span></span><br><span class="line">    <span class="comment">// that case.</span></span><br><span class="line">            <span class="keyword">status_t</span>    requestExitAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until this object's thread exits. Returns immediately if not yet running.</span></span><br><span class="line">    <span class="comment">// Do not call from this object's thread; will return WOULD_BLOCK in that case.</span></span><br><span class="line">            <span class="keyword">status_t</span>    join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicates whether this thread is running or not.</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span>        <span class="title">isRunning</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">    <span class="comment">// Return the thread's kernel ID, same as the thread itself calling gettid(),</span></span><br><span class="line">    <span class="comment">// or -1 if the thread is not running.</span></span><br><span class="line">            <span class="keyword">pid_t</span>       getTid() <span class="keyword">const</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// exitPending() returns true if requestExit() has been called.</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span>        <span class="title">exitPending</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></span><br><span class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></span><br><span class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></span><br><span class="line">    <span class="comment">//          requestExit() wasn't called.</span></span><br><span class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">threadLoop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thread&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Thread&amp;);</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span>             _threadLoop(<span class="keyword">void</span>* user);</span><br><span class="line">    <span class="keyword">const</span>   <span class="keyword">bool</span>            mCanCallJava;</span><br><span class="line">    <span class="comment">// always hold mLock when reading or writing</span></span><br><span class="line">            <span class="keyword">thread_id_t</span>     mThread;</span><br><span class="line">    <span class="keyword">mutable</span> Mutex           mLock;</span><br><span class="line">            Condition       mThreadExitedCondition;</span><br><span class="line">            <span class="keyword">status_t</span>        mStatus;</span><br><span class="line">    <span class="comment">// note that all accesses of mExitPending and mRunning need to hold mLock</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span>           mExitPending;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span>           mRunning;</span><br><span class="line">            sp&lt;Thread&gt;      mHoldSelf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">    <span class="comment">// legacy for debugging, not used by getTid() as it is set by the child thread</span></span><br><span class="line">    <span class="comment">// and so is not initialized until the child reaches that point</span></span><br><span class="line">            <span class="keyword">pid_t</span>           mTid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用 run 方法，实际上就是开始线程的 threadLoop 循环而已了。</p>
<h4 id="InputReader-loopOnce"><a href="#InputReader-loopOnce" class="headerlink" title="InputReader::loopOnce"></a>InputReader::loopOnce</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/native/services/inputflinger/InputReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">    mReader-&gt;loopOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        oldGeneration = mGeneration;</span><br><span class="line">        timeoutMillis = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> changes = mConfigurationChangesToRefresh;</span><br><span class="line">        <span class="keyword">if</span> (changes) &#123;</span><br><span class="line">            mConfigurationChangesToRefresh = <span class="number">0</span>;</span><br><span class="line">            timeoutMillis = <span class="number">0</span>;</span><br><span class="line">            refreshConfigurationLocked(changes);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mReaderIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            processEventsLocked(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= mNextTimeout) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">                ALOGD(<span class="string">"Timeout expired, latency=%0.3fms"</span>, (now - mNextTimeout) * <span class="number">0.000001f</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                mNextTimeout = LLONG_MAX;</span><br><span class="line">                timeoutExpiredLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldGeneration != mGeneration) &#123;</span><br><span class="line">            inputDevicesChanged = <span class="literal">true</span>;</span><br><span class="line">            getInputDevicesLocked(inputDevices);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send out a message that the describes the changed input devices.</span></span><br><span class="line">    <span class="keyword">if</span> (inputDevicesChanged) &#123;</span><br><span class="line">        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush queued events out to the listener.</span></span><br><span class="line">    <span class="comment">// This must happen outside of the lock because the listener could potentially call</span></span><br><span class="line">    <span class="comment">// back into the InputReader's methods, such as getScanCodeState, or become blocked</span></span><br><span class="line">    <span class="comment">// on another thread similarly waiting to acquire the InputReader lock thereby</span></span><br><span class="line">    <span class="comment">// resulting in a deadlock.  This situation is actually quite plausible because the</span></span><br><span class="line">    <span class="comment">// listener is actually the input dispatcher, which calls into the window manager,</span></span><br><span class="line">    <span class="comment">// which occasionally calls into the input reader.</span></span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputReader-processEventsLocked"><a href="#InputReader-processEventsLocked" class="headerlink" title="InputReader::processEventsLocked"></a>InputReader::processEventsLocked</h4><p>每次循环都会从 EventHub 中读取事件，然后进行处理，对于在 EventHub 内扫描后会出现的新增，删除事件， InputReader 会被对应的设备进行存储，同时为设备建立 mapper。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::processEventsLocked(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> type = rawEvent-&gt;type;</span><br><span class="line">        <span class="keyword">size_t</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">            <span class="keyword">while</span> (batchSize &lt; count) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT</span><br><span class="line">                        || rawEvent[batchSize].deviceId != deviceId) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                batchSize += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">            ALOGD(<span class="string">"BatchSize: %zu Count: %zu"</span>, batchSize, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_ADDED:</span><br><span class="line">                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_REMOVED:</span><br><span class="line">                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:</span><br><span class="line">                handleConfigurationChangedLocked(rawEvent-&gt;when);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOG_ASSERT(<span class="literal">false</span>); <span class="comment">// can't happen</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count -= batchSize;</span><br><span class="line">        rawEvent += batchSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::addDeviceLocked(<span class="keyword">nsecs_t</span> when, <span class="keyword">int32_t</span> deviceId) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    <span class="keyword">if</span> (deviceIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Ignoring spurious device added event for deviceId %d."</span>, deviceId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDeviceIdentifier identifier = mEventHub-&gt;getDeviceIdentifier(deviceId);</span><br><span class="line">    <span class="keyword">uint32_t</span> classes = mEventHub-&gt;getDeviceClasses(deviceId);</span><br><span class="line">    <span class="keyword">int32_t</span> controllerNumber = mEventHub-&gt;getDeviceControllerNumber(deviceId);</span><br><span class="line"></span><br><span class="line">    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);</span><br><span class="line">    device-&gt;configure(when, &amp;mConfig, <span class="number">0</span>);</span><br><span class="line">    device-&gt;reset(when);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;isIgnored()) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Device added: id=%d, name='%s' (ignored non-input device)"</span>, deviceId,</span><br><span class="line">                identifier.name.<span class="built_in">string</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGI(<span class="string">"Device added: id=%d, name='%s', sources=0x%08x"</span>, deviceId,</span><br><span class="line">                identifier.name.<span class="built_in">string</span>(), device-&gt;getSources());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDevices.add(deviceId, device);</span><br><span class="line">    bumpGenerationLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;getClasses() &amp; INPUT_DEVICE_CLASS_EXTERNAL_STYLUS) &#123;</span><br><span class="line">        notifyExternalStylusPresenceChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InputDevice* InputReader::createDeviceLocked(<span class="keyword">int32_t</span> deviceId, <span class="keyword">int32_t</span> controllerNumber,</span><br><span class="line">        <span class="keyword">const</span> InputDeviceIdentifier&amp; identifier, <span class="keyword">uint32_t</span> classes) &#123;</span><br><span class="line">    InputDevice* device = <span class="keyword">new</span> InputDevice(&amp;mContext, deviceId, bumpGenerationLocked(),</span><br><span class="line">            controllerNumber, identifier, classes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// External devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_EXTERNAL) &#123;</span><br><span class="line">        device-&gt;setExternal(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Devices with mics.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_MIC) &#123;</span><br><span class="line">        device-&gt;setMic(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_SWITCH) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> SwitchInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scroll wheel-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_ROTARY_ENCODER) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> RotaryEncoderInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vibrator-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_VIBRATOR) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> VibratorInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keyboard-like devices.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> keyboardSource = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> keyboardType = AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_KEYBOARD) &#123;</span><br><span class="line">        keyboardSource |= AINPUT_SOURCE_KEYBOARD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_ALPHAKEY) &#123;</span><br><span class="line">        keyboardType = AINPUT_KEYBOARD_TYPE_ALPHABETIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_DPAD) &#123;</span><br><span class="line">        keyboardSource |= AINPUT_SOURCE_DPAD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_GAMEPAD) &#123;</span><br><span class="line">        keyboardSource |= AINPUT_SOURCE_GAMEPAD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyboardSource != <span class="number">0</span>) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> KeyboardInputMapper(device, keyboardSource, keyboardType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cursor-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_CURSOR) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> CursorInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Touchscreens and touchpad devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> MultiTouchInputMapper(device));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> SingleTouchInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Joystick-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_JOYSTICK) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> JoystickInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// External stylus-like devices.</span></span><br><span class="line">    <span class="keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_EXTERNAL_STYLUS) &#123;</span><br><span class="line">        device-&gt;addMapper(<span class="keyword">new</span> ExternalStylusInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputReader-processEventsForDeviceLocked"><a href="#InputReader-processEventsForDeviceLocked" class="headerlink" title="InputReader::processEventsForDeviceLocked"></a>InputReader::processEventsForDeviceLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理设备添加，移除，扫描外的事件</span></span><br><span class="line"><span class="keyword">void</span> InputReader::processEventsForDeviceLocked(<span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        <span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Discarding event for unknown deviceId %d."</span>, deviceId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;isIgnored()) &#123;</span><br><span class="line">        <span class="comment">//ALOGD("Discarding event for ignored deviceId %d.", deviceId);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputDevice-process"><a href="#InputDevice-process" class="headerlink" title="InputDevice::process"></a>InputDevice::process</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDevice::process(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="comment">// Process all of the events in order for each mapper.</span></span><br><span class="line">    <span class="comment">// We cannot simply ask each mapper to process them in bulk because mappers may</span></span><br><span class="line">    <span class="comment">// have side-effects that must be interleaved.  For example, joystick movement events and</span></span><br><span class="line">    <span class="comment">// gamepad button presses are handled by different mappers but they should be dispatched</span></span><br><span class="line">    <span class="comment">// in the order received.</span></span><br><span class="line">    <span class="keyword">size_t</span> numMappers = mMappers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count != <span class="number">0</span>; rawEvent++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">        ALOGD(<span class="string">"Input event: device=%d type=0x%04x code=0x%04x value=0x%08x when=%"</span> PRId64,</span><br><span class="line">                rawEvent-&gt;deviceId, rawEvent-&gt;type, rawEvent-&gt;code, rawEvent-&gt;value,</span><br><span class="line">                rawEvent-&gt;when);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDropUntilNextSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">                mDropUntilNextSync = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">                ALOGD(<span class="string">"Recovered from input event buffer overrun."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_RAW_EVENTS</span><br><span class="line">                ALOGD(<span class="string">"Dropped input event while waiting for next input sync."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Detected input event buffer overrun for device %s."</span>, getName().<span class="built_in">string</span>());</span><br><span class="line">            mDropUntilNextSync = <span class="literal">true</span>;</span><br><span class="line">            reset(rawEvent-&gt;when);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numMappers; i++) &#123;</span><br><span class="line">                InputMapper* mapper = mMappers[i];</span><br><span class="line">                mapper-&gt;process(rawEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeyboardInputMapper-process"><a href="#KeyboardInputMapper-process" class="headerlink" title="KeyboardInputMapper::process"></a>KeyboardInputMapper::process</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::process(<span class="keyword">const</span> RawEvent* rawEvent) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY: &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode = rawEvent-&gt;code;</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode = mCurrentHidUsage;</span><br><span class="line">        mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyboardOrGamepadKey(scanCode)) &#123;</span><br><span class="line">            processKey(rawEvent-&gt;when, rawEvent-&gt;value != <span class="number">0</span>, scanCode, usageCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_MSC: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == MSC_SCAN) &#123;</span><br><span class="line">            mCurrentHidUsage = rawEvent-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_SYN: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">            mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeyboardInputMapper-processKey"><a href="#KeyboardInputMapper-processKey" class="headerlink" title="KeyboardInputMapper::processKey"></a>KeyboardInputMapper::processKey</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::processKey(<span class="keyword">nsecs_t</span> when, <span class="keyword">bool</span> down, <span class="keyword">int32_t</span> scanCode,</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> keyCode;</span><br><span class="line">    <span class="keyword">int32_t</span> keyMetaState;</span><br><span class="line">    <span class="keyword">uint32_t</span> policyFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, mMetaState,</span><br><span class="line">                              &amp;keyCode, &amp;keyMetaState, &amp;policyFlags)) &#123;</span><br><span class="line">        keyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">        keyMetaState = mMetaState;</span><br><span class="line">        policyFlags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">        <span class="comment">// Rotate key codes according to orientation if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (mParameters.orientationAware &amp;&amp; mParameters.hasAssociatedDisplay) &#123;</span><br><span class="line">            keyCode = rotateKeyCode(keyCode, mOrientation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add key down.</span></span><br><span class="line">        <span class="keyword">ssize_t</span> keyDownIndex = findKeyDown(scanCode);</span><br><span class="line">        <span class="keyword">if</span> (keyDownIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// key repeat, be sure to use same keycode as before in case of rotation</span></span><br><span class="line">            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key down</span></span><br><span class="line">            <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL)</span><br><span class="line">                    &amp;&amp; mContext-&gt;shouldDropVirtualKey(when,</span><br><span class="line">                            getDevice(), keyCode, scanCode)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (policyFlags &amp; POLICY_FLAG_GESTURE) &#123;</span><br><span class="line">                mDevice-&gt;cancelTouch(when);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mKeyDowns.push();</span><br><span class="line">            KeyDown&amp; keyDown = mKeyDowns.editTop();</span><br><span class="line">            keyDown.keyCode = keyCode;</span><br><span class="line">            keyDown.scanCode = scanCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDownTime = when;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove key down.</span></span><br><span class="line">        <span class="keyword">ssize_t</span> keyDownIndex = findKeyDown(scanCode);</span><br><span class="line">        <span class="keyword">if</span> (keyDownIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// key up, be sure to use same keycode as before in case of rotation</span></span><br><span class="line">            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;</span><br><span class="line">            mKeyDowns.removeAt(<span class="keyword">size_t</span>(keyDownIndex));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key was not actually down</span></span><br><span class="line">            ALOGI(<span class="string">"Dropping key up from device %s because the key was not down.  "</span></span><br><span class="line">                    <span class="string">"keyCode=%d, scanCode=%d"</span>,</span><br><span class="line">                    getDeviceName().<span class="built_in">string</span>(), keyCode, scanCode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (updateMetaStateIfNeeded(keyCode, down)) &#123;</span><br><span class="line">        <span class="comment">// If global meta state changed send it along with the key.</span></span><br><span class="line">        <span class="comment">// If it has not changed then we'll use what keymap gave us,</span></span><br><span class="line">        <span class="comment">// since key replacement logic might temporarily reset a few</span></span><br><span class="line">        <span class="comment">// meta bits for given key.</span></span><br><span class="line">        keyMetaState = mMetaState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> downTime = mDownTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key down on external an keyboard should wake the device.</span></span><br><span class="line">    <span class="comment">// We don't do this for internal keyboards to prevent them from waking up in your pocket.</span></span><br><span class="line">    <span class="comment">// For internal keyboards, the key layout file should specify the policy flags for</span></span><br><span class="line">    <span class="comment">// each wake key individually.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Use the input device configuration to control this behavior more finely.</span></span><br><span class="line">    <span class="keyword">if</span> (down &amp;&amp; getDevice()-&gt;isExternal() &amp;&amp; !isMediaKey(keyCode)) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_WAKE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParameters.handlesKeyRepeat) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_DISABLE_KEY_REPEAT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">NotifyKeyArgs <span class="title">args</span><span class="params">(when, getDeviceId(), mSource, policyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span></span></span><br><span class="line"><span class="function"><span class="params">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, keyMetaState, downTime)</span></span>;</span><br><span class="line">    getListener()-&gt;notifyKey(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里就会将按键信息，通知到 mQueuedListener。</p>
<h4 id="QueuedInputListener-notifyKey"><a href="#QueuedInputListener-notifyKey" class="headerlink" title="QueuedInputListener::notifyKey"></a>QueuedInputListener::notifyKey</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    mArgsQueue.push(<span class="keyword">new</span> NotifyKeyArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="QueuedInputListener-flush"><a href="#QueuedInputListener-flush" class="headerlink" title="QueuedInputListener::flush"></a>QueuedInputListener::flush</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mQueuedListener 中。mQueuedListener.flush() 会将所有的事件通知到 Dispatcher（mInnerListener 就是 Dispatcher）。</p>
<h4 id="InputDispatcher-notifyKey"><a href="#InputDispatcher-notifyKey" class="headerlink" title="InputDispatcher::notifyKey"></a>InputDispatcher::notifyKey</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_INBOUND_EVENT_DETAILS</span></span><br><span class="line">    ALOGD(<span class="string">"notifyKey - eventTime=%"</span> PRId64</span><br><span class="line">            <span class="string">", deviceId=%d, source=0x%x, policyFlags=0x%x, action=0x%x, "</span></span><br><span class="line">            <span class="string">"flags=0x%x, keyCode=0x%x, scanCode=0x%x, metaState=0x%x, downTime=%"</span> PRId64,</span><br><span class="line">            args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;policyFlags,</span><br><span class="line">            args-&gt;action, args-&gt;flags, args-&gt;keyCode, args-&gt;scanCode,</span><br><span class="line">            args-&gt;metaState, args-&gt;downTime);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!validateKeyEvent(args-&gt;action)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> policyFlags = args-&gt;policyFlags;</span><br><span class="line">    <span class="keyword">int32_t</span> flags = args-&gt;flags;</span><br><span class="line">    <span class="keyword">int32_t</span> metaState = args-&gt;metaState;</span><br><span class="line">    <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL) || (flags &amp; AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_VIRTUAL;</span><br><span class="line">        flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (policyFlags &amp; POLICY_FLAG_FUNCTION) &#123;</span><br><span class="line">        metaState |= AMETA_FUNCTION_ON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyFlags |= POLICY_FLAG_TRUSTED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> keyCode = args-&gt;keyCode;</span><br><span class="line">    <span class="keyword">if</span> (metaState &amp; AMETA_META_ON &amp;&amp; args-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> newKeyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == AKEYCODE_DEL) &#123;</span><br><span class="line">            newKeyCode = AKEYCODE_BACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyCode == AKEYCODE_ENTER) &#123;</span><br><span class="line">            newKeyCode = AKEYCODE_HOME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newKeyCode != AKEYCODE_UNKNOWN) &#123;</span><br><span class="line">            AutoMutex _l(mLock);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">KeyReplacement</span> <span class="title">replacement</span> = &#123;</span>keyCode, args-&gt;deviceId&#125;;</span><br><span class="line">            mReplacedKeys.add(replacement, newKeyCode);</span><br><span class="line">            keyCode = newKeyCode;</span><br><span class="line">            metaState &amp;= ~(AMETA_META_ON | AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args-&gt;action == AKEY_EVENT_ACTION_UP) &#123;</span><br><span class="line">        <span class="comment">// In order to maintain a consistent stream of up and down events, check to see if the key</span></span><br><span class="line">        <span class="comment">// going up is one we've replaced in a down event and haven't yet replaced in an up event,</span></span><br><span class="line">        <span class="comment">// even if the modifier was released between the down and the up events.</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">KeyReplacement</span> <span class="title">replacement</span> = &#123;</span>keyCode, args-&gt;deviceId&#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> index = mReplacedKeys.indexOfKey(replacement);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            keyCode = mReplacedKeys.valueAt(index);</span><br><span class="line">            mReplacedKeys.removeItemsAt(index);</span><br><span class="line">            metaState &amp;= ~(AMETA_META_ON | AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">            flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">            args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"></span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line">    <span class="keyword">if</span> (t.duration() &gt; SLOW_INTERCEPTION_THRESHOLD) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Excessive delay in interceptKeyBeforeQueueing; took %s ms"</span>,</span><br><span class="line">                <span class="built_in">std</span>::to_string(t.duration().count()).c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NativeInputManager-interceptKeyBeforeQueueing"><a href="#NativeInputManager-interceptKeyBeforeQueueing" class="headerlink" title="NativeInputManager::interceptKeyBeforeQueueing"></a>NativeInputManager::interceptKeyBeforeQueueing</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeInputManager::interceptKeyBeforeQueueing(<span class="keyword">const</span> KeyEvent* keyEvent,</span><br><span class="line">        <span class="keyword">uint32_t</span>&amp; policyFlags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// Policy:</span></span><br><span class="line">    <span class="comment">// - Ignore untrusted events and pass them along.</span></span><br><span class="line">    <span class="comment">// - Ask the window manager what to do with normal events and trusted injected events.</span></span><br><span class="line">    <span class="comment">// - For normal events wake and brighten the screen if currently off or dim.</span></span><br><span class="line">    <span class="keyword">bool</span> interactive = mInteractive.load();</span><br><span class="line">    <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">        policyFlags |= POLICY_FLAG_INTERACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_TRUSTED)) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> when = keyEvent-&gt;getEventTime();</span><br><span class="line">        JNIEnv* env = jniEnv();</span><br><span class="line">        jobject keyEventObj = android_view_KeyEvent_fromNative(env, keyEvent);</span><br><span class="line">        jint wmActions;</span><br><span class="line">        <span class="keyword">if</span> (keyEventObj) &#123;</span><br><span class="line">            wmActions = env-&gt;CallIntMethod(mServiceObj,</span><br><span class="line">                    gServiceClassInfo.interceptKeyBeforeQueueing,</span><br><span class="line">                    keyEventObj, policyFlags);</span><br><span class="line">            <span class="keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="string">"interceptKeyBeforeQueueing"</span>)) &#123;</span><br><span class="line">                wmActions = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android_view_KeyEvent_recycle(env, keyEventObj);</span><br><span class="line">            env-&gt;DeleteLocalRef(keyEventObj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"Failed to obtain key event object for interceptKeyBeforeQueueing."</span>);</span><br><span class="line">            wmActions = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleInterceptActions(wmActions, when, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">            policyFlags |= POLICY_FLAG_PASS_TO_USER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputManagerService-interceptKeyBeforeQueueing"><a href="#InputManagerService-interceptKeyBeforeQueueing" class="headerlink" title="InputManagerService.interceptKeyBeforeQueueing"></a>InputManagerService.interceptKeyBeforeQueueing</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Native callback.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindowManagerCallbacks.interceptKeyBeforeQueueing(event, policyFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Provides an opportunity for the window manager policy to intercept early key</span></span><br><span class="line"><span class="comment">     * processing as soon as the key has been read from the device. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService.mPolicy.interceptKeyBeforeQueueing(event, policyFlags);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="PhoneWindowManager-interceptKeyBeforeQueueing"><a href="#PhoneWindowManager-interceptKeyBeforeQueueing" class="headerlink" title="PhoneWindowManager:interceptKeyBeforeQueueing"></a>PhoneWindowManager:interceptKeyBeforeQueueing</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mSystemBooted) &#123;</span><br><span class="line">            <span class="comment">// If we have not yet booted, don't let key events do anything.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> interactive = (policyFlags &amp; FLAG_INTERACTIVE) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> down = event.getAction() == KeyEvent.ACTION_DOWN;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = event.isCanceled();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> keyCode = event.getKeyCode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isInjected = (policyFlags &amp; WindowManagerPolicy.FLAG_INJECTED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If screen is off then we treat the case where the keyguard is open but hidden</span></span><br><span class="line">        <span class="comment">// the same as if it were open and in front.</span></span><br><span class="line">        <span class="comment">// This will prevent any keys other than the power button from waking the screen</span></span><br><span class="line">        <span class="comment">// when the keyguard is hidden by another activity.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> keyguardActive = (mKeyguardDelegate == <span class="keyword">null</span> ? <span class="keyword">false</span> :</span><br><span class="line">                                            (interactive ?</span><br><span class="line">                                                isKeyguardShowingAndNotOccluded() :</span><br><span class="line">                                                mKeyguardDelegate.isShowing()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_INPUT) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"interceptKeyTq keycode="</span> + keyCode</span><br><span class="line">                    + <span class="string">" interactive="</span> + interactive + <span class="string">" keyguardActive="</span> + keyguardActive</span><br><span class="line">                    + <span class="string">" policyFlags="</span> + Integer.toHexString(policyFlags));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Basic policy based on interactive state.</span></span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> isWakeKey = (policyFlags &amp; WindowManagerPolicy.FLAG_WAKE) != <span class="number">0</span></span><br><span class="line">                || event.isWakeKey();</span><br><span class="line">        <span class="keyword">if</span> (interactive || (isInjected &amp;&amp; !isWakeKey)) &#123;</span><br><span class="line">            <span class="comment">// When the device is interactive or the key is injected pass the</span></span><br><span class="line">            <span class="comment">// key to the application.</span></span><br><span class="line">            result = ACTION_PASS_TO_USER;</span><br><span class="line">            isWakeKey = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">                <span class="comment">// If the screen is awake, but the button pressed was the one that woke the device</span></span><br><span class="line">                <span class="comment">// then don't pass it to the application</span></span><br><span class="line">                <span class="keyword">if</span> (keyCode == mPendingWakeKey &amp;&amp; !down) &#123;</span><br><span class="line">                    result = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Reset the pending key</span></span><br><span class="line">                mPendingWakeKey = PENDING_KEY_NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!interactive &amp;&amp; shouldDispatchInputWhenNonInteractive(event)) &#123;</span><br><span class="line">            <span class="comment">// If we're currently dozing with the screen on and the keyguard showing, pass the key</span></span><br><span class="line">            <span class="comment">// to the application but preserve its wake key status to make sure we still move</span></span><br><span class="line">            <span class="comment">// from dozing to fully interactive if we would normally go from off to fully</span></span><br><span class="line">            <span class="comment">// interactive.</span></span><br><span class="line">            result = ACTION_PASS_TO_USER;</span><br><span class="line">            <span class="comment">// Since we're dispatching the input, reset the pending key</span></span><br><span class="line">            mPendingWakeKey = PENDING_KEY_NULL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When the screen is off and the key is not injected, determine whether</span></span><br><span class="line">            <span class="comment">// to wake the device but don't pass the key to the application.</span></span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (isWakeKey &amp;&amp; (!down || !isWakeKeyWhenScreenOff(keyCode))) &#123;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Cache the wake key on down event so we can also avoid sending the up event to the app</span></span><br><span class="line">            <span class="keyword">if</span> (isWakeKey &amp;&amp; down) &#123;</span><br><span class="line">                mPendingWakeKey = keyCode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the key would be handled globally, just return the result, don't worry about special</span></span><br><span class="line">        <span class="comment">// key processing.</span></span><br><span class="line">        <span class="keyword">if</span> (isValidGlobalKey(keyCode)</span><br><span class="line">                &amp;&amp; mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isWakeKey) &#123;</span><br><span class="line">                wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, <span class="string">"android.policy:KEY"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable haptics if down and virtual key without multiple repetitions. If this is a hard</span></span><br><span class="line">        <span class="comment">// virtual key such as a navigation bar button, only vibrate if flag is enabled.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isNavBarVirtKey = ((event.getFlags() &amp; KeyEvent.FLAG_VIRTUAL_HARD_KEY) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> useHapticFeedback = down</span><br><span class="line">                &amp;&amp; (policyFlags &amp; WindowManagerPolicy.FLAG_VIRTUAL) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled)</span><br><span class="line">                &amp;&amp; event.getRepeatCount() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle special keys.</span></span><br><span class="line">        <span class="keyword">switch</span> (keyCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_BACK: &#123;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    interceptBackKeyDown();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> handled = interceptBackKeyUp(event);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Don't pass back press to app if we've already handled it via long press</span></span><br><span class="line">                    <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                        result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_DOWN:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_UP:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_MUTE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                        <span class="comment">// Any activity on the vol down button stops the ringer toggle shortcut</span></span><br><span class="line">                        cancelPendingRingerToggleChordAction();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == <span class="number">0</span>) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered = <span class="keyword">true</span>;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed = <span class="keyword">false</span>;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                            interceptAccessibilityShortcutChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mScreenshotChordVolumeDownKeyTriggered = <span class="keyword">false</span>;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                        cancelPendingAccessibilityShortcutAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_VOLUME_UP) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interactive &amp;&amp; !mA11yShortcutChordVolumeUpKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == <span class="number">0</span>) &#123;</span><br><span class="line">                            mA11yShortcutChordVolumeUpKeyTriggered = <span class="keyword">true</span>;</span><br><span class="line">                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();</span><br><span class="line">                            mA11yShortcutChordVolumeUpKeyConsumed = <span class="keyword">false</span>;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            cancelPendingScreenshotChordAction();</span><br><span class="line">                            cancelPendingRingerToggleChordAction();</span><br><span class="line"></span><br><span class="line">                            interceptAccessibilityShortcutChord();</span><br><span class="line">                            interceptRingerToggleChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mA11yShortcutChordVolumeUpKeyTriggered = <span class="keyword">false</span>;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                        cancelPendingAccessibilityShortcutAction();</span><br><span class="line">                        cancelPendingRingerToggleChordAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    sendSystemKeyToStatusBarAsync(event.getKeyCode());</span><br><span class="line"></span><br><span class="line">                    TelecomManager telecomManager = getTelecommService();</span><br><span class="line">                    <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span> &amp;&amp; !mHandleVolumeKeysInWM) &#123;</span><br><span class="line">                        <span class="comment">// When &#123;@link #mHandleVolumeKeysInWM&#125; is set, volume key events</span></span><br><span class="line">                        <span class="comment">// should be dispatched to WM.</span></span><br><span class="line">                        <span class="keyword">if</span> (telecomManager.isRinging()) &#123;</span><br><span class="line">                            <span class="comment">// If an incoming call is ringing, either VOLUME key means</span></span><br><span class="line">                            <span class="comment">// "silence ringer".  We handle these keys here, rather than</span></span><br><span class="line">                            <span class="comment">// in the InCallScreen, to make sure we'll respond to them</span></span><br><span class="line">                            <span class="comment">// even if the InCallScreen hasn't come to the foreground yet.</span></span><br><span class="line">                            <span class="comment">// Look for the DOWN event here, to agree with the "fallback"</span></span><br><span class="line">                            <span class="comment">// behavior in the InCallScreen.</span></span><br><span class="line">                            Log.i(TAG, <span class="string">"interceptKeyBeforeQueueing:"</span></span><br><span class="line">                                  + <span class="string">" VOLUME key-down while ringing: Silence ringer!"</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Silence the ringer.  (It's safe to call this</span></span><br><span class="line">                            <span class="comment">// even if the ringer has already been silenced.)</span></span><br><span class="line">                            telecomManager.silenceRinger();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// And *don't* pass this key thru to the current activity</span></span><br><span class="line">                            <span class="comment">// (which is probably the InCallScreen.)</span></span><br><span class="line">                            result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> audioMode = AudioManager.MODE_NORMAL;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        audioMode = getAudioService().getMode();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">"Error getting AudioService in interceptKeyBeforeQueueing."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> isInCall = (telecomManager != <span class="keyword">null</span> &amp;&amp; telecomManager.isInCall()) ||</span><br><span class="line">                            audioMode == AudioManager.MODE_IN_COMMUNICATION;</span><br><span class="line">                    <span class="keyword">if</span> (isInCall &amp;&amp; (result &amp; ACTION_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// If we are in call but we decided not to pass the key to</span></span><br><span class="line">                        <span class="comment">// the application, just pass it to the session service.</span></span><br><span class="line">                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(</span><br><span class="line">                                event, AudioManager.USE_DEFAULT_STREAM_TYPE, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mUseTvRouting || mHandleVolumeKeysInWM) &#123;</span><br><span class="line">                    <span class="comment">// Defer special key handlings to</span></span><br><span class="line">                    <span class="comment">// &#123;@link interceptKeyBeforeDispatching()&#125;.</span></span><br><span class="line">                    result |= ACTION_PASS_TO_USER;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((result &amp; ACTION_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// If we aren't passing to the user and no one else</span></span><br><span class="line">                    <span class="comment">// handled it send it to the session manager to</span></span><br><span class="line">                    <span class="comment">// figure out.</span></span><br><span class="line">                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(</span><br><span class="line">                            event, AudioManager.USE_DEFAULT_STREAM_TYPE, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_ENDCALL: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    TelecomManager telecomManager = getTelecommService();</span><br><span class="line">                    <span class="keyword">boolean</span> hungUp = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hungUp = telecomManager.endCall();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (interactive &amp;&amp; !hungUp) &#123;</span><br><span class="line">                        mEndCallKeyHandled = <span class="keyword">false</span>;</span><br><span class="line">                        mHandler.postDelayed(mEndCallLongPress,</span><br><span class="line">                                ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEndCallKeyHandled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mEndCallKeyHandled) &#123;</span><br><span class="line">                        mHandler.removeCallbacks(mEndCallLongPress);</span><br><span class="line">                        <span class="keyword">if</span> (!canceled) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((mEndcallBehavior</span><br><span class="line">                                    &amp; Settings.System.END_BUTTON_BEHAVIOR_HOME) != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (goHome()) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> ((mEndcallBehavior</span><br><span class="line">                                    &amp; Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != <span class="number">0</span>) &#123;</span><br><span class="line">                                goToSleep(event.getEventTime(),</span><br><span class="line">                                        PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, <span class="number">0</span>);</span><br><span class="line">                                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                <span class="comment">// Any activity on the power button stops the accessibility shortcut</span></span><br><span class="line">                cancelPendingAccessibilityShortcutAction();</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>; <span class="comment">// wake-up will be handled separately</span></span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                interceptSystemNavigationKey(event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SLEEP: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mPowerManager.isInteractive()) &#123;</span><br><span class="line">                    useHapticFeedback = <span class="keyword">false</span>; <span class="comment">// suppress feedback if already non-interactive</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    sleepPress();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sleepRelease(event.getEventTime());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_SOFT_SLEEP: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!down) &#123;</span><br><span class="line">                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_WAKEUP: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PAUSE:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_HEADSETHOOK:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MUTE:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_STOP:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_NEXT:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PREVIOUS:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_REWIND:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_RECORD:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK: &#123;</span><br><span class="line">                <span class="keyword">if</span> (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) &#123;</span><br><span class="line">                    <span class="comment">// If the global session is active pass all media keys to it</span></span><br><span class="line">                    <span class="comment">// instead of the active window.</span></span><br><span class="line">                    result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((result &amp; ACTION_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Only do this if we would otherwise not pass it to the user. In that</span></span><br><span class="line">                    <span class="comment">// case, the PhoneWindow class will do the same thing, except it will</span></span><br><span class="line">                    <span class="comment">// only do it if the showing app doesn't process the key on its own.</span></span><br><span class="line">                    <span class="comment">// Note that we need to make a copy of the key event here because the</span></span><br><span class="line">                    <span class="comment">// original key event will be recycled when we return.</span></span><br><span class="line">                    mBroadcastWakeLock.acquire();</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK,</span><br><span class="line">                            <span class="keyword">new</span> KeyEvent(event));</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_CALL: &#123;</span><br><span class="line">                <span class="keyword">if</span> (down) &#123;</span><br><span class="line">                    TelecomManager telecomManager = getTelecommService();</span><br><span class="line">                    <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (telecomManager.isRinging()) &#123;</span><br><span class="line">                            Log.i(TAG, <span class="string">"interceptKeyBeforeQueueing:"</span></span><br><span class="line">                                  + <span class="string">" CALL key-down while ringing: Answer the call!"</span>);</span><br><span class="line">                            telecomManager.acceptRingingCall();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// And *don't* pass this key thru to the current activity</span></span><br><span class="line">                            <span class="comment">// (which is presumably the InCallScreen.)</span></span><br><span class="line">                            result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_ASSIST: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> longPressed = event.getRepeatCount() &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (down &amp;&amp; longPressed) &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!down &amp;&amp; !longPressed) &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(),</span><br><span class="line">                            <span class="number">0</span> <span class="comment">/* unused */</span>, <span class="keyword">null</span> <span class="comment">/* hint */</span>);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_VOICE_ASSIST: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!down) &#123;</span><br><span class="line">                    mBroadcastWakeLock.acquire();</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    msg.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_WINDOW: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mPictureInPictureVisible) &#123;</span><br><span class="line">                        <span class="comment">// Consumes the key only if picture-in-picture is visible to show</span></span><br><span class="line">                        <span class="comment">// picture-in-picture control menu. This gives a chance to the foreground</span></span><br><span class="line">                        <span class="comment">// activity to customize PIP key behavior.</span></span><br><span class="line">                        <span class="keyword">if</span> (!down) &#123;</span><br><span class="line">                            showPictureInPictureMenu(event);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (useHapticFeedback) &#123;</span><br><span class="line">            performHapticFeedbackLw(<span class="keyword">null</span>, HapticFeedbackConstants.VIRTUAL_KEY, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isWakeKey) &#123;</span><br><span class="line">            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, <span class="string">"android.policy:KEY"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，事件已经进入了 dipatcher 的队列了，他就要准备开发发射数据。</p>
<p>## InputDispatcher</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">InputDispatcher::InputDispatcher(<span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(<span class="literal">NULL</span>), mLastDropReason(DROP_REASON_NOT_DROPPED),</span><br><span class="line">    mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(<span class="literal">NULL</span>),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputDispatcher-dispatchOnce"><a href="#InputDispatcher-dispatchOnce" class="headerlink" title="InputDispatcher::dispatchOnce"></a>InputDispatcher::dispatchOnce</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run a dispatch loop if there are no pending commands.</span></span><br><span class="line">        <span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputDispatcher-dispatchOnceInnerLocked"><a href="#InputDispatcher-dispatchOnceInnerLocked" class="headerlink" title="InputDispatcher::dispatchOnceInnerLocked"></a>InputDispatcher::dispatchOnceInnerLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the key repeat timer whenever normal dispatch is suspended while the</span></span><br><span class="line">    <span class="comment">// device is in a non-interactive state.  This is to ensure that we abort a key</span></span><br><span class="line">    <span class="comment">// repeat if the device is just coming out of sleep.</span></span><br><span class="line">    <span class="keyword">if</span> (!mDispatchEnabled) &#123;</span><br><span class="line">        resetKeyRepeatLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If dispatching is frozen, do not process timeouts or try to deliver any new events.</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchFrozen) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">        ALOGD(<span class="string">"Dispatch frozen.  Waiting some more."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimize latency of app switches.</span></span><br><span class="line">    <span class="comment">// Essentially we start a short timeout when an app switch key (HOME / ENDCALL) has</span></span><br><span class="line">    <span class="comment">// been pressed.  When it expires, we preempt dispatch and drop all other pending events.</span></span><br><span class="line">    <span class="keyword">bool</span> isAppSwitchDue = mAppSwitchDueTime &lt;= currentTime;</span><br><span class="line">    <span class="keyword">if</span> (mAppSwitchDueTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">        *nextWakeupTime = mAppSwitchDueTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">                <span class="comment">// The inbound queue is empty so the app switch key we were waiting</span></span><br><span class="line">                <span class="comment">// for will never arrive.  Stop waiting for it.</span></span><br><span class="line">                resetPendingAppSwitchLocked(<span class="literal">false</span>);</span><br><span class="line">                isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Synthesize a key repeat if appropriate.</span></span><br><span class="line">            <span class="keyword">if</span> (mKeyRepeatState.lastKeyEntry) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= mKeyRepeatState.nextRepeatTime) &#123;</span><br><span class="line">                    mPendingEvent = synthesizeKeyRepeatLocked(currentTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mKeyRepeatState.nextRepeatTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">                        *nextWakeupTime = mKeyRepeatState.nextRepeatTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Nothing to do if there is no pending event.</span></span><br><span class="line">            <span class="keyword">if</span> (!mPendingEvent) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have an event to dispatch.</span></span><br><span class="line">    <span class="comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    DropReason dropReason = DROP_REASON_NOT_DROPPED;</span><br><span class="line">    <span class="keyword">if</span> (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;</span><br><span class="line">        dropReason = DROP_REASON_POLICY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mDispatchEnabled) &#123;</span><br><span class="line">        dropReason = DROP_REASON_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNextUnblockedEvent == mPendingEvent) &#123;</span><br><span class="line">        mNextUnblockedEvent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">        ConfigurationChangedEntry* typedEntry =</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;ConfigurationChangedEntry*&gt;(mPendingEvent);</span><br><span class="line">        done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">        dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_DEVICE_RESET: &#123;</span><br><span class="line">        DeviceResetEntry* typedEntry =</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;DeviceResetEntry*&gt;(mPendingEvent);</span><br><span class="line">        done = dispatchDeviceResetLocked(currentTime, typedEntry);</span><br><span class="line">        dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// device resets are never dropped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchKeyEventLocked(typedEntry)) &#123;</span><br><span class="line">                resetPendingAppSwitchLocked(<span class="literal">true</span>);</span><br><span class="line">                isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">                dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;</span><br><span class="line">            dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InputDispatcher-dispatchKeyLocked"><a href="#InputDispatcher-dispatchKeyLocked" class="headerlink" title="InputDispatcher::dispatchKeyLocked"></a>InputDispatcher::dispatchKeyLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="comment">// Preprocessing.</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;dispatchInProgress) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;repeatCount == <span class="number">0</span></span><br><span class="line">                &amp;&amp; entry-&gt;action == AKEY_EVENT_ACTION_DOWN</span><br><span class="line">                &amp;&amp; (entry-&gt;policyFlags &amp; POLICY_FLAG_TRUSTED)</span><br><span class="line">                &amp;&amp; (!(entry-&gt;policyFlags &amp; POLICY_FLAG_DISABLE_KEY_REPEAT))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mKeyRepeatState.lastKeyEntry</span><br><span class="line">                    &amp;&amp; mKeyRepeatState.lastKeyEntry-&gt;keyCode == entry-&gt;keyCode) &#123;</span><br><span class="line">                <span class="comment">// We have seen two identical key downs in a row which indicates that the device</span></span><br><span class="line">                <span class="comment">// driver is automatically generating key repeats itself.  We take note of the</span></span><br><span class="line">                <span class="comment">// repeat here, but we disable our own next key repeat timer since it is clear that</span></span><br><span class="line">                <span class="comment">// we will not need to synthesize key repeats ourselves.</span></span><br><span class="line">                entry-&gt;repeatCount = mKeyRepeatState.lastKeyEntry-&gt;repeatCount + <span class="number">1</span>;</span><br><span class="line">                resetKeyRepeatLocked();</span><br><span class="line">                mKeyRepeatState.nextRepeatTime = LONG_LONG_MAX; <span class="comment">// don't generate repeats ourselves</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Not a repeat.  Save key down state in case we do see a repeat later.</span></span><br><span class="line">                resetKeyRepeatLocked();</span><br><span class="line">                mKeyRepeatState.nextRepeatTime = entry-&gt;eventTime + mConfig.keyRepeatTimeout;</span><br><span class="line">            &#125;</span><br><span class="line">            mKeyRepeatState.lastKeyEntry = entry;</span><br><span class="line">            entry-&gt;refCount += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! entry-&gt;syntheticRepeat) &#123;</span><br><span class="line">            resetKeyRepeatLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;repeatCount == <span class="number">1</span>) &#123;</span><br><span class="line">            entry-&gt;flags |= AKEY_EVENT_FLAG_LONG_PRESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry-&gt;flags &amp;= ~AKEY_EVENT_FLAG_LONG_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entry-&gt;dispatchInProgress = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        logOutboundKeyDetailsLocked(<span class="string">"dispatchKey - "</span>, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle case where the policy asked us to try again later last time.</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentTime &lt; entry-&gt;interceptKeyWakeupTime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;interceptKeyWakeupTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">                *nextWakeupTime = entry-&gt;interceptKeyWakeupTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// wait until next wakeup</span></span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN;</span><br><span class="line">        entry-&gt;interceptKeyWakeupTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the policy a chance to intercept the key.</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">                    &amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible);</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                commandEntry-&gt;inputWindowHandle = mFocusedWindowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            commandEntry-&gt;keyEntry = entry;</span><br><span class="line">            entry-&gt;refCount += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// wait for the command to run</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_SKIP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            *dropReason = DROP_REASON_POLICY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up if dropping the event.</span></span><br><span class="line">    <span class="keyword">if</span> (*dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">        setInjectionResultLocked(entry, *dropReason == DROP_REASON_POLICY</span><br><span class="line">                ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="findFocusedWindowTargetsLocked"><a href="#findFocusedWindowTargetsLocked" class="headerlink" title="findFocusedWindowTargetsLocked"></a>findFocusedWindowTargetsLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> reason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is no currently focused window and no focused application</span></span><br><span class="line">    <span class="comment">// then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, <span class="literal">NULL</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"Dropping event because there is no focused window or focused application."</span>);</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check permissions.</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the window is ready for more input.</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.empty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.c_str());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Success!  Output targets.</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"findFocusedWindow finished: injectionResult=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatchEventLocked"><a href="#dispatchEventLocked" class="headerlink" title="dispatchEventLocked"></a>dispatchEventLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"dispatchEventToCurrentInputTargets"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_FOCUS</span><br><span class="line">            ALOGD(<span class="string">"Dropping event delivery to target with channel '%s' because it "</span></span><br><span class="line">                    <span class="string">"is no longer registered with the input dispatcher."</span>,</span><br><span class="line">                    inputTarget.inputChannel-&gt;getName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prepareDispatchCycleLocked"><a href="#prepareDispatchCycleLocked" class="headerlink" title="prepareDispatchCycleLocked"></a>prepareDispatchCycleLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ prepareDispatchCycle - flags=0x%08x, "</span></span><br><span class="line">            <span class="string">"xOffset=%f, yOffset=%f, scaleFactor=%f, "</span></span><br><span class="line">            <span class="string">"pointerIds=0x%x"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str(), inputTarget-&gt;flags,</span><br><span class="line">            inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor, inputTarget-&gt;pointerIds.value);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip this event if the connection status is not normal.</span></span><br><span class="line">    <span class="comment">// We don't want to enqueue additional outbound events if the connection is broken.</span></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;status != Connection::STATUS_NORMAL) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">        ALOGD(<span class="string">"channel '%s' ~ Dropping event because the channel status is %s"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str(), connection-&gt;getStatusLabel());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split a motion event if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123;</span><br><span class="line">        ALOG_ASSERT(eventEntry-&gt;type == EventEntry::TYPE_MOTION);</span><br><span class="line"></span><br><span class="line">        MotionEntry* originalMotionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123;</span><br><span class="line">            MotionEntry* splitMotionEntry = splitMotionEvent(</span><br><span class="line">                    originalMotionEntry, inputTarget-&gt;pointerIds);</span><br><span class="line">            <span class="keyword">if</span> (!splitMotionEntry) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// split event was dropped</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' ~ Split motion event."</span>,</span><br><span class="line">                    connection-&gt;getInputChannelName().c_str());</span><br><span class="line">            logOutboundMotionDetailsLocked(<span class="string">"  "</span>, splitMotionEntry);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line">                    splitMotionEntry, inputTarget);</span><br><span class="line">            splitMotionEntry-&gt;release();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enqueueDispatchEntriesLocked"><a href="#enqueueDispatchEntriesLocked" class="headerlink" title="enqueueDispatchEntriesLocked"></a>enqueueDispatchEntriesLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntryLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span><br><span class="line">        <span class="keyword">int32_t</span> dispatchMode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a new event.</span></span><br><span class="line">    <span class="comment">// Enqueue a new dispatch entry onto the outbound queue for this connection.</span></span><br><span class="line">    DispatchEntry* dispatchEntry = <span class="keyword">new</span> DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply target flags and update the connection's input state.</span></span><br><span class="line">    <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line">        dispatchEntry-&gt;resolvedAction = keyEntry-&gt;action;</span><br><span class="line">        dispatchEntry-&gt;resolvedFlags = keyEntry-&gt;flags;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!connection-&gt;inputState.trackKey(keyEntry,</span><br><span class="line">                dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event"</span>,</span><br><span class="line">                    connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">delete</span> dispatchEntry;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// skip the inconsistent event</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_OUTSIDE) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_CANCEL;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedAction = motionEntry-&gt;action;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dispatchEntry-&gt;resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE</span><br><span class="line">                &amp;&amp; !connection-&gt;inputState.isHovering(</span><br><span class="line">                        motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">        ALOGD(<span class="string">"channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatchEntry-&gt;resolvedFlags = motionEntry-&gt;flags;</span><br><span class="line">        <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_OBSCURED) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) &#123;</span><br><span class="line">            dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!connection-&gt;inputState.trackMotion(motionEntry,</span><br><span class="line">                dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event"</span>,</span><br><span class="line">                    connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">delete</span> dispatchEntry;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// skip the inconsistent event</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember that we are waiting for this dispatch to complete.</span></span><br><span class="line">    <span class="keyword">if</span> (dispatchEntry-&gt;hasForegroundTarget()) &#123;</span><br><span class="line">        incrementPendingForegroundDispatchesLocked(eventEntry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">    traceOutboundQueueLengthLocked(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            PointerCoords scaledCoords[MAX_POINTERS];</span><br><span class="line">            <span class="keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the X and Y offset depending on the input source.</span></span><br><span class="line">            <span class="keyword">float</span> xOffset, yOffset;</span><br><span class="line">            <span class="keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)</span><br><span class="line">                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;</span><br><span class="line">                <span class="keyword">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;</span><br><span class="line">                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;</span><br><span class="line">                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;</span><br><span class="line">                <span class="keyword">if</span> (scaleFactor != <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];</span><br><span class="line">                        scaledCoords[i].scale(scaleFactor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xOffset = <span class="number">0.0f</span>;</span><br><span class="line">                yOffset = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We don't want the dispatch target to know.</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i].clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the result.</span></span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;waitQueue.isEmpty()) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full. "</span></span><br><span class="line">                            <span class="string">"This is unexpected because the wait queue is empty, so the pipe "</span></span><br><span class="line">                            <span class="string">"should be empty and we shouldn't have any problems writing an "</span></span><br><span class="line">                            <span class="string">"event to it, status=%d"</span>, connection-&gt;getInputChannelName().c_str(),</span><br><span class="line">                            status);</span><br><span class="line">                    abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Pipe is full and we are waiting for the app to finish process some events</span></span><br><span class="line">                    <span class="comment">// before sending more events to it.</span></span><br><span class="line">#<span class="keyword">if</span> DEBUG_DISPATCH_CYCLE</span><br><span class="line">                    ALOGD(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full, "</span></span><br><span class="line">                            <span class="string">"waiting for the application to catch up"</span>,</span><br><span class="line">                            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    connection-&gt;inputPublisherBlocked = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Could not publish event due to an unexpected error, "</span></span><br><span class="line">                        <span class="string">"status=%d"</span>, connection-&gt;getInputChannelName().c_str(), status);</span><br><span class="line">                abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="startDispatchCycleLocked"><a href="#startDispatchCycleLocked" class="headerlink" title="startDispatchCycleLocked"></a>startDispatchCycleLocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            PointerCoords scaledCoords[MAX_POINTERS];</span><br><span class="line">            <span class="keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the X and Y offset depending on the input source.</span></span><br><span class="line">            <span class="keyword">float</span> xOffset, yOffset;</span><br><span class="line">            <span class="keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)</span><br><span class="line">                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;</span><br><span class="line">                <span class="keyword">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;</span><br><span class="line">                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;</span><br><span class="line">                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;</span><br><span class="line">                <span class="keyword">if</span> (scaleFactor != <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];</span><br><span class="line">                        scaledCoords[i].scale(scaleFactor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xOffset = <span class="number">0.0f</span>;</span><br><span class="line">                yOffset = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We don't want the dispatch target to know.</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                        scaledCoords[i].clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    usingCoords = scaledCoords;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the result.</span></span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;waitQueue.isEmpty()) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full. "</span></span><br><span class="line">                            <span class="string">"This is unexpected because the wait queue is empty, so the pipe "</span></span><br><span class="line">                            <span class="string">"should be empty and we shouldn't have any problems writing an "</span></span><br><span class="line">                            <span class="string">"event to it, status=%d"</span>, connection-&gt;getInputChannelName().c_str(),</span><br><span class="line">                            status);</span><br><span class="line">                    abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Pipe is full and we are waiting for the app to finish process some events</span></span><br><span class="line">                    <span class="comment">// before sending more events to it.</span></span><br><span class="line">#<span class="keyword">if</span> DEBUG_DISPATCH_CYCLE</span><br><span class="line">                    ALOGD(<span class="string">"channel '%s' ~ Could not publish event because the pipe is full, "</span></span><br><span class="line">                            <span class="string">"waiting for the application to catch up"</span>,</span><br><span class="line">                            connection-&gt;getInputChannelName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    connection-&gt;inputPublisherBlocked = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Could not publish event due to an unexpected error, "</span></span><br><span class="line">                        <span class="string">"status=%d"</span>, connection-&gt;getInputChannelName().c_str(), status);</span><br><span class="line">                abortBrokenDispatchCycleLocked(currentTime, connection, <span class="literal">true</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="handleReceiveCallback"><a href="#handleReceiveCallback" class="headerlink" title="handleReceiveCallback"></a>handleReceiveCallback</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> InputDispatcher::handleReceiveCallback(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    InputDispatcher* d = <span class="keyword">static_cast</span>&lt;InputDispatcher*&gt;(data);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(d-&gt;mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = d-&gt;mConnectionsByFd.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Received spurious receive callback for unknown input channel.  "</span></span><br><span class="line">                    <span class="string">"fd=%d, events=0x%x"</span>, fd, events);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> notify;</span><br><span class="line">        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        <span class="keyword">if</span> (!(events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(events &amp; ALOOPER_EVENT_INPUT)) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName().c_str(), events);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">            <span class="keyword">bool</span> gotOne = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">status_t</span> status;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> seq;</span><br><span class="line">                <span class="keyword">bool</span> handled;</span><br><span class="line">                status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);</span><br><span class="line">                <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);</span><br><span class="line">                gotOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotOne) &#123;</span><br><span class="line">                d-&gt;runCommandsLockedInterruptible();</span><br><span class="line">                <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notify = status != DEAD_OBJECT || !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Failed to receive finished signal.  status=%d"</span>,</span><br><span class="line">                        connection-&gt;getInputChannelName().c_str(), status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Monitor channels are never explicitly unregistered.</span></span><br><span class="line">            <span class="comment">// We do it automatically when the remote endpoint is closed so don't warn</span></span><br><span class="line">            <span class="comment">// about them.</span></span><br><span class="line">            notify = !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Consumer closed input channel or an error occurred.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName().c_str(), events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unregister the channel.</span></span><br><span class="line">        d-&gt;unregisterInputChannelLocked(connection-&gt;inputChannel, notify);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/逆向/" rel="tag"># 逆向</a>
              <a href="/tags/Android-Input/" rel="tag"># Android Input</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Android/安卓原生模拟器进行root操作.html" rel="next" title="安卓原生模拟器进行root操作">
                  <i class="fa fa-chevron-left"></i> 安卓原生模拟器进行root操作
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/Lua/luasocket中的http实现.html" rel="prev" title="luasocket中的http实现">
                  luasocket中的http实现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关于安卓的输入"><span class="nav-number">1.</span> <span class="nav-text">关于安卓的输入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安卓的输入栈"><span class="nav-number">2.</span> <span class="nav-text">安卓的输入栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InputManagerService"><span class="nav-number">3.</span> <span class="nav-text">InputManagerService</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InputManagerService-1"><span class="nav-number">3.1.</span> <span class="nav-text">InputManagerService()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nativeInit"><span class="nav-number">3.2.</span> <span class="nav-text">nativeInit()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NativeInputManager"><span class="nav-number">3.2.1.</span> <span class="nav-text">NativeInputManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventHub"><span class="nav-number">3.2.2.</span> <span class="nav-text">EventHub</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EventHub-getEvents"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">EventHub.getEvents()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备扫描"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">设备扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打开设备"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">打开设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册到epoll监控事件"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">注册到epoll监控事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputManager"><span class="nav-number">3.2.3.</span> <span class="nav-text">InputManager</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputManagerService-start"><span class="nav-number">3.3.</span> <span class="nav-text">InputManagerService.start()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nativeStart"><span class="nav-number">3.3.1.</span> <span class="nav-text">nativeStart()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputReader"><span class="nav-number">3.4.</span> <span class="nav-text">InputReader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputReaderThread"><span class="nav-number">3.5.</span> <span class="nav-text">InputReaderThread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InputReader-loopOnce"><span class="nav-number">3.5.0.1.</span> <span class="nav-text">InputReader::loopOnce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputReader-processEventsLocked"><span class="nav-number">3.5.0.2.</span> <span class="nav-text">InputReader::processEventsLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputReader-processEventsForDeviceLocked"><span class="nav-number">3.5.0.3.</span> <span class="nav-text">InputReader::processEventsForDeviceLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputDevice-process"><span class="nav-number">3.5.0.4.</span> <span class="nav-text">InputDevice::process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyboardInputMapper-process"><span class="nav-number">3.5.0.5.</span> <span class="nav-text">KeyboardInputMapper::process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyboardInputMapper-processKey"><span class="nav-number">3.5.0.6.</span> <span class="nav-text">KeyboardInputMapper::processKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QueuedInputListener-notifyKey"><span class="nav-number">3.5.0.7.</span> <span class="nav-text">QueuedInputListener::notifyKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QueuedInputListener-flush"><span class="nav-number">3.5.0.8.</span> <span class="nav-text">QueuedInputListener::flush</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputDispatcher-notifyKey"><span class="nav-number">3.5.0.9.</span> <span class="nav-text">InputDispatcher::notifyKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NativeInputManager-interceptKeyBeforeQueueing"><span class="nav-number">3.5.0.10.</span> <span class="nav-text">NativeInputManager::interceptKeyBeforeQueueing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputManagerService-interceptKeyBeforeQueueing"><span class="nav-number">3.5.0.11.</span> <span class="nav-text">InputManagerService.interceptKeyBeforeQueueing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PhoneWindowManager-interceptKeyBeforeQueueing"><span class="nav-number">3.5.0.12.</span> <span class="nav-text">PhoneWindowManager:interceptKeyBeforeQueueing</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputDispatcher-dispatchOnce"><span class="nav-number">3.6.</span> <span class="nav-text">InputDispatcher::dispatchOnce</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InputDispatcher-dispatchOnceInnerLocked"><span class="nav-number">3.6.0.1.</span> <span class="nav-text">InputDispatcher::dispatchOnceInnerLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputDispatcher-dispatchKeyLocked"><span class="nav-number">3.6.0.2.</span> <span class="nav-text">InputDispatcher::dispatchKeyLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#findFocusedWindowTargetsLocked"><span class="nav-number">3.6.0.3.</span> <span class="nav-text">findFocusedWindowTargetsLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatchEventLocked"><span class="nav-number">3.6.0.4.</span> <span class="nav-text">dispatchEventLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prepareDispatchCycleLocked"><span class="nav-number">3.6.0.5.</span> <span class="nav-text">prepareDispatchCycleLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enqueueDispatchEntriesLocked"><span class="nav-number">3.6.0.6.</span> <span class="nav-text">enqueueDispatchEntriesLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#startDispatchCycleLocked"><span class="nav-number">3.6.0.7.</span> <span class="nav-text">startDispatchCycleLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handleReceiveCallback"><span class="nav-number">3.6.0.8.</span> <span class="nav-text">handleReceiveCallback</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gowa2017 Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">376</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">159</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gowa2017" title="GitHub → https://github.com/gowa2017" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shouzheng.zhang@gmail.com" title="E-Mail → mailto:shouzheng.zhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-json"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gowa2017 Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>














  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gowa-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://gowa.club/Android/InputService-安卓的输入系统.html",
            identifier: "Android/InputService-安卓的输入系统.html",
            title: "InputService-安卓的输入系统"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gowa-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
</script>

</body>
</html>
