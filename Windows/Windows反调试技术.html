<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="退思园" type="application/atom+xml">
  <meta name="google-site-verification" content="EDvvZZUFkxy_QUzZTaqwsG_9VHqFthY-NhQE4j6WL-s">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '8LQ0Z7JZKO',
      apiKey: '5d3485c20d60066c59575f644f5b3da9',
      indexName: 'gowa.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="转载的一篇文章，自己进行更详细的尝试。原文地址。反调试技术，恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。很多种反调试技术可以达到反调试效果。这里介绍">
<meta name="keywords" content="Windows,逆向">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows反调试技术">
<meta property="og:url" content="https:&#x2F;&#x2F;gowa.club&#x2F;Windows&#x2F;Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.html">
<meta property="og:site_name" content="退思园">
<meta property="og:description" content="转载的一篇文章，自己进行更详细的尝试。原文地址。反调试技术，恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。很多种反调试技术可以达到反调试效果。这里介绍">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_4ESEEHQ94JF7YPK.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_9PMDV7CV9MDFF46.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_9GEZ3Y8FGAQ8WA7.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_BZDANDDPZ3HN68Q.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_VT82HFSA5HUWDUB.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_QUBDAXKP2E7UFQC.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_Z2ZU7ZPKANY4YE8.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_36ZKBK3D5VTH4FZ.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_EVCXQN95Z2APNTP.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_Y9URZ32MHJMCBE4.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_BPAGXVTE95Q8C5E.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_HCU8CAXT5RH7R4J.png">
<meta property="og:updated_time" content="2019-10-24T15:21:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;gowa.club&#x2F;res&#x2F;734571_4ESEEHQ94JF7YPK.jpg">

<link rel="canonical" href="https://gowa.club/Windows/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Windows反调试技术 | 退思园</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137245514-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-137245514-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">退思园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">烦恼一般都是想太多了。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gowa.club/Windows/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gowa2017 Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="退思园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows反调试技术
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-24 23:21:30" itemprop="dateCreated datePublished" datetime="2019-10-24T23:21:30+08:00">2019-10-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/Windows/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Windows/Windows反调试技术.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>转载的一篇文章，自己进行更详细的尝试。<a href="https://bbs.pediy.com/thread-225740.htm" target="_blank" rel="noopener">原文地址</a>。反调试技术，恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。很多种反调试技术可以达到反调试效果。这里介绍当前常用的几种反调试技术，同时也会介绍一些逃避反调试的技巧。<br>有一个外国友人写了更强大的例子来展示 <a href="https://github.com/LordNoteworthy/al-khaser" target="_blank" rel="noopener">https://github.com/LordNoteworthy/al-khaser</a></p>
<a id="more"></a>

<h1 id="一、探测调试器"><a href="#一、探测调试器" class="headerlink" title="一、探测调试器"></a>一、探测调试器</h1><p>反调试技术，恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。很多种反调试技术可以达到反调试效果。这里介绍当前常用的几种反调试技术，同时也会介绍一些逃避反调试的技巧。</p>
<h2 id="1、使用Windows-API"><a href="#1、使用Windows-API" class="headerlink" title="1、使用Windows API"></a>1、使用Windows API</h2><p>使用Windows API函数检测调试器是否存在是最简单的反调试技术。Windows操作系统中提供了这样一些API，应用程序可以通过调用这些API，来检测自己是否正在被调试。这些API中有些是专门用来检测调试器的存在的，而另外一些API是出于其他目的而设计的，但也可以被改造用来探测调试器的存在。其中很小部分API函数没有在微软官方文档显示。通常，防止恶意代码使用API进行反调试的最简单的办法是在恶意代码运行期间修改恶意代码，使其不能调用探测调试器的API函数，或者修改这些API函数的返回值，确保恶意代码执行合适的路径。与这些方法相比，较复杂的做法是挂钩这些函数，如使用rootkit技术。</p>
<p>关于 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/debugapi/" target="_blank" rel="noopener">DebugAPI 请看这里 debugapi.h</a></p>
<h3 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent" target="_blank" rel="noopener">IsDebuggerPresent</a> 查询进程环境块(PEB)中的IsDebugged标志。如果进程没有运行在调试器环境中，函数返回0；如果调试附加了进程，函数返回一个非零值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsDebuggerPresent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h3><p><a href="https://docs.microsoft.com/windows/desktop/api/debugapi/nf-debugapi-checkremotedebuggerpresent" target="_blank" rel="noopener">CheckRemoteDebuggerPresent</a> 同IsDebuggerPresent几乎一致。它不仅可以探测系统其他进程是否被调试，通过传递自身进程句柄还可以探测自身是否被调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckRemoteDebuggerPresent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">  PBOOL  pbDebuggerPresent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>CheckRemoteDebuggerPresent</strong>  中的 <strong>Remote</strong> 不是说调试器一定存在于其他计算机，而是说其存在于一个单独的进程中。而 IsDebuggerPresent 则是用来检查调试器是否运行在本进程中。</p>
<p>如果有远程调试器存在，那么就会返回一个 非0值，如果函数执行失败，会返回一个非0值。这个时候可以用 GetLastError() 来获取失败的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL ret;</span><br><span class="line">    CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess" target="_blank" rel="noopener">NtQueryInformationProcess</a> 已经标记为可能修改或者在将来的 Windows 版本中不可用了。其应该使用其他可选的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">kernel_entry NTSTATUS <span class="title">NtQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  IN HANDLE           ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  OUT PVOID           ProcessInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN ULONG            ProcessInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  OUT PULONG          ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是Ntdll.dll中一个API，它用来提取一个给定进程的信息。它的第一个参数是进程句柄，第二个参数告诉我们它需要提取进程信息的类型。为第二个参数指定特定值并调用该函数，相关信息就会设置到第三个参数。第二个参数是一个枚举类型，其中与反调试有关的成员有ProcessDebugPort(0x7)、ProcessDebugObjectHandle(0x1E)和ProcessDebugFlags(0x1F)。例如将该参数置为ProcessDebugPort，如果进程正在被调试，则返回调试端口，否则返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> debugPort = <span class="number">0</span>;</span><br><span class="line">    HMODULE hModule = LoadLibrary(<span class="string">"Ntdll.dll"</span>);</span><br><span class="line">    NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, <span class="string">"NtQueryInformationProcess"</span>);</span><br><span class="line">    NtQueryInformationProcess(GetCurrentProcess(), <span class="number">0x7</span>, &amp;debugPort, <span class="keyword">sizeof</span>(debugPort), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> debugPort != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hdebugObject = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hModule = LoadLibrary(<span class="string">"Ntdll.dll"</span>);</span><br><span class="line">    NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, <span class="string">"NtQueryInformationProcess"</span>);</span><br><span class="line">    NtQueryInformationProcess(GetCurrentProcess(), <span class="number">0x1E</span>, &amp;hdebugObject, <span class="keyword">sizeof</span>(hdebugObject), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> hdebugObject != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bdebugFlag = TRUE;</span><br><span class="line">    HMODULE hModule = LoadLibrary(<span class="string">"Ntdll.dll"</span>);</span><br><span class="line">    NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, <span class="string">"NtQueryInformationProcess"</span>);</span><br><span class="line">    NtQueryInformationProcess(GetCurrentProcess(), <span class="number">0x1E</span>, &amp;bdebugFlag, <span class="keyword">sizeof</span>(bdebugFlag), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> bdebugFlag != TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a>GetLastError</h3><p>编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用TRUE和FALSE来表明函数的运行结果。一旦出现错误，MSDN中往往会指出请用<a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror" target="_blank" rel="noopener">GetLastError</a>()函数来获得错误原因。恶意代码可以使用异常来破坏或者探测调试器。<strong>调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。</strong>多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。</p>
<p>对于OutputDebugString函数，它的作用是在调试器中显示一个字符串，同时它也可以用来探测调试器的存在。使用SetLastError函数，将当前的错误码设置为一个任意值。如果进程没有被调试器附加，调用OutputDebugString函数会失败，错误码会重新设置，因此GetLastError获取的错误码应该不是我们设置的任意值。但如果进程被调试器附加，调用OutputDebugString函数会成功，这时GetLastError获取的错误码应该没改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD errorValue = <span class="number">12345</span>;</span><br><span class="line">    SetLastError(errorValue);</span><br><span class="line">    OutputDebugString(<span class="string">"Test for debugger!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == errorValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于DeleteFiber函数，如果给它传递一个无效的参数的话会抛出ERROR_INVALID_PARAMETER异常。如果进程正在被调试的话，异常会被调试器捕获。所以，同样可以通过验证LastError值来检测调试器的存在。如代码所示，0x57就是指ERROR_INVALID_PARAMETER。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fib[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    DeleteFiber(fib);</span><br><span class="line">    <span class="keyword">return</span> (GetLastError() != <span class="number">0x57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样还可以使用CloseHandle、CloseWindow产生异常，使得错误码改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD ret = CloseHandle((HANDLE)<span class="number">0x1234</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_HANDLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD ret = CloseWindow((HWND)<span class="number">0x1234</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_WINDOW_HANDLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h3><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-zwsetinformationthread" target="_blank" rel="noopener">ZwSetInformationThread</a>拥有两个参数，第一个参数用来接收当前线程的句柄，第二个参数表示线程信息类型，若其值设置为ThreadHideFromDebugger(0x11)，使用语句ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, NULL, 0);调用该函数后，调试进程就会被分离出来。该函数不会对正常运行的程序产生任何影响，但若运行的是调试器程序，因为该函数隐藏了当前线程，调试器无法再收到该线程的调试事件，最终停止调试。还有一个函DebugActiveProcessStop用来分离调试器和被调试进程，从而停止调试。两个API容易混淆，需要牢记它们的区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">ZwSetInformationThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE          ThreadHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  THREADINFOCLASS ThreadInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID           ThreadInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG           ThreadInformationLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="2、手动检测数据结构"><a href="#2、手动检测数据结构" class="headerlink" title="2、手动检测数据结构"></a>2、手动检测数据结构</h2><p>虽然使用Windows API是探测调试器存在的最简单办法，但手动检查数据结构是恶意代码编写者最常使用的办法。这是因为很多时候通过Windows API实现的反调试技术无效，例如这些API函数被rootkit挂钩，并返回错误信息。因此，恶意代码编写者经常手动执行与这些API功能相同的操作。在手动检测中，PEB结构中的一些标志暴露了调试器存在的信息。这里，我们关注检测调试器存在常用的一些标志。</p>
<h3 id="检测BeingDebugged属性"><a href="#检测BeingDebugged属性" class="headerlink" title="检测BeingDebugged属性"></a>检测BeingDebugged属性</h3><p>Windows操作系统维护着每个正在运行的进程的PEB结构，它包含与这个进程相关的所有用户态参数。这些参数包括进程环境数据，环境数据包括环境变量、加载的模块列表、内存地址，以及调试器状态。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb" target="_blank" rel="noopener">PEB</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">  BYTE                          Reserved1[<span class="number">2</span>];</span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line">  BYTE                          Reserved2[<span class="number">1</span>];</span><br><span class="line">  PVOID                         Reserved3[<span class="number">2</span>];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr;</span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  PVOID                         Reserved4[<span class="number">3</span>];</span><br><span class="line">  PVOID                         AtlThunkSListPtr;</span><br><span class="line">  PVOID                         Reserved5;</span><br><span class="line">  ULONG                         Reserved6;</span><br><span class="line">  PVOID                         Reserved7;</span><br><span class="line">  ULONG                         Reserved8;</span><br><span class="line">  ULONG                         AtlThunkSListPtr32;</span><br><span class="line">  PVOID                         Reserved9[<span class="number">45</span>];</span><br><span class="line">  BYTE                          Reserved10[<span class="number">96</span>];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved11[<span class="number">128</span>];</span><br><span class="line">  PVOID                         Reserved12[<span class="number">1</span>];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>

<p>进程运行时，位置fs:[30h]指向PEB的基地址。为了实现反调试技术，恶意代码通过这个位置检查BeingDebugged标志，这个标志标识进程是否正在被调试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">        mov al, BYTE PTR [eax + <span class="number">2</span>]</span><br><span class="line">        mov result, al</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种检查有多种形式，最终，条件跳转决定代码的路径。避免这种问题最简单的方法是在执行跳转指令前，手动修改零标志，强制执行跳转(或者不跳转)。<br>可以或者手动修改BeingDebugged属性值为0。在OllyDbg中安装命令行插件，为了启动该插件，用OllyDbg加载恶意代码，选择Plugins-&gt;Command Line-&gt;Command Line选项，在命令行窗口输入下面的命令。</p>
<p><img src="../res/734571_4ESEEHQ94JF7YPK.jpg" alt="img"></p>
<p>如图所示，这条命令会将BeingDebugged属性转储到转储面板窗口。右键单击BeingDebugged属性，选择Binary-&gt;Fill With 00’s，这时属性被设置为0。</p>
<p>OllyDbg的一些插件可以帮助我们修改BeingDebugged标志。其中最流行的有HideDebugger、Hidedebug和PhantOm。以PhantOm为例，同样将dll文件拷贝到OllyDbg的安装目录下就会自动安装。选择Plugins-&gt;PhantOm-&gt;Options选项，勾选hide from PEB即可。</p>
<p><img src="../res/734571_9PMDV7CV9MDFF46.jpg" alt="img"></p>
<h3 id="检测ProcessHeap属性"><a href="#检测ProcessHeap属性" class="headerlink" title="检测ProcessHeap属性"></a>检测ProcessHeap属性</h3><p>Reserved数组中一个未公开的位置叫作ProcessHeap，它被设置为加载器为进程分配的第一个堆的位置。ProcessHeap位于PEB结构的0x18处。第一个堆头部有一个属性字段，它告诉内核这个堆是否在调试器中创建。这些属性叫作ForceFlags和Flags。在Windows XP系统中，ForceFlags属性位于堆头部偏移量0x10处；在Windows 7系统中，对于32位的应用程序来说ForceFlags属性位于堆头部偏移量0x44处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    DWORD dwVersion = GetVersion();</span><br><span class="line">    DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));</span><br><span class="line">    <span class="comment">//for xp</span></span><br><span class="line">    <span class="keyword">if</span> (dwWindowsMajorVersion == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">18</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">10</span>h]</span><br><span class="line">            mov result, eax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">18</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">44</span>h]</span><br><span class="line">            mov result, eax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，恶意代码也可以检查Windows XP系统中偏移量0x0C处，或者Windows 7系统中偏移量0x40处的Flags属性。这个属性总与ForceFlags属性大致相同，但通常情况下Flags与值2进行比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    DWORD dwVersion = GetVersion();</span><br><span class="line">    DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));</span><br><span class="line">    <span class="comment">//for xp</span></span><br><span class="line">    <span class="keyword">if</span> (dwWindowsMajorVersion == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">18</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">0</span>ch]</span><br><span class="line">            mov result, eax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">18</span>h]</span><br><span class="line">            mov eax, [eax + <span class="number">40</span>h]</span><br><span class="line">            mov result, eax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免这种问题方法和前面的差不多。如果用OllyDbg的命令行插件修改，输入的命令为dump ds:[fs:[30]+0x18]+0x10。如果用PhantOm插件，它会禁用调试堆创建功能而不需要手动设置。</p>
<h3 id="检测NTGlobalFlag"><a href="#检测NTGlobalFlag" class="headerlink" title="检测NTGlobalFlag"></a>检测NTGlobalFlag</h3><p>由于调试器中启动进程与正常模式下启动进程有些不同，所以它们创建内存堆的方式也不同。系统使用PEB结构偏移量0x68处的一个未公开位置，来决定如何创建堆结构。如果这个位置的值为0x70，我们就知道进程正运行在调试器中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">        mov eax, [eax + <span class="number">68</span>h]</span><br><span class="line">        <span class="keyword">and</span> eax, <span class="number">0x70</span></span><br><span class="line">        mov result, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作系统创建堆时，值0x70是下列标志的一个组合。如果进程从调试器启动，那么进程的这些标志将被设置。<br>(FLG_HEAP_ENABLE_TAIL_CHECK|FLG_HEAP_ENABLE_FREE_CHECK|FLG_HEAP_VALIDATE_PARAMETERS)<br>避免这种问题方法和前面的差不多。如果用OllyDbg的命令行插件修改，输入的命令为dump fs:[30]+0x68。如果用PhantOm插件，它会逃避使用NTGlobalFlag的反调试技术而不需要手动设置。</p>
<h2 id="3、系统痕迹检测"><a href="#3、系统痕迹检测" class="headerlink" title="3、系统痕迹检测"></a>3、系统痕迹检测</h2><p>通常，我们使用调试工具来分析恶意代码，但这些工具会在系统中驻留一些痕迹。恶意代码通过搜索这种系统痕迹，来确定你是否试图分析它。</p>
<h3 id="查找调试器引用的注册表项"><a href="#查找调试器引用的注册表项" class="headerlink" title="查找调试器引用的注册表项"></a>查找调试器引用的注册表项</h3><p>下面是调试器在注册表中的一个常用位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug(32位系统)</span><br><span class="line">SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\AeDebug(64位系统)</span><br></pre></td></tr></table></figure>

<p>该注册表项指定当应用程序发生错误时，触发哪一个调试器。默认情况下，它被设置为Dr.Watson。如果该这册表的键值被修改为OllyDbg，则恶意代码就可能确定它正在被调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL is_64;</span><br><span class="line">    IsWow64Process(GetCurrentProcess(), &amp;is_64);</span><br><span class="line">    HKEY hkey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> key[] = <span class="string">"Debugger"</span>;</span><br><span class="line">    <span class="keyword">char</span> reg_dir_32bit[] = <span class="string">"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"</span>;</span><br><span class="line">    <span class="keyword">char</span> reg_dir_64bit[] = <span class="string">"SOFTWARE\\Wow6432Node\\Microsoft\\WindowsNT\\CurrentVersion\\AeDebug"</span>;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_64)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = RegCreateKeyA(HKEY_LOCAL_MACHINE, reg_dir_64bit, &amp;hkey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = RegCreateKeyA(HKEY_LOCAL_MACHINE, reg_dir_32bit, &amp;hkey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">256</span>];</span><br><span class="line">    DWORD len = <span class="number">256</span>;</span><br><span class="line">    DWORD type;</span><br><span class="line">    ret = RegQueryValueExA(hkey, key, <span class="literal">NULL</span>, &amp;type, (LPBYTE)tmp, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"OllyIce"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(tmp, <span class="string">"OllyDBG"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(tmp, <span class="string">"WinDbg"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(tmp, <span class="string">"x64dbg"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(tmp, <span class="string">"Immunity"</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找窗体信息"><a href="#查找窗体信息" class="headerlink" title="查找窗体信息"></a>查找窗体信息</h3><p>FindWindow函数检索处理顶级窗口的类名和窗口名称匹配指定的字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FindWindowA(<span class="string">"OLLYDBG"</span>, <span class="literal">NULL</span>)!=<span class="literal">NULL</span> || FindWindowA(<span class="string">"WinDbgFrameClass"</span>, <span class="literal">NULL</span>)!=<span class="literal">NULL</span> || FindWindowA(<span class="string">"QWidget"</span>, <span class="literal">NULL</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EnumWindows函数枚举所有屏幕上的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWndProc</span><span class="params">(HWND hwnd, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cur_window[<span class="number">1024</span>];</span><br><span class="line">    GetWindowTextA(hwnd, cur_window, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur_window, <span class="string">"WinDbg"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(cur_window, <span class="string">"x64_dbg"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(cur_window, <span class="string">"OllyICE"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(cur_window, <span class="string">"OllyDBG"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(cur_window, <span class="string">"Immunity"</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *((BOOL*)lParam) = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL ret = FALSE;</span><br><span class="line">    EnumWindows(EnumWndProc, (LPARAM)&amp;ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetForegroundWindow获取一个前台窗口的句柄</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fore_window[<span class="number">1024</span>];</span><br><span class="line">    GetWindowTextA(GetForegroundWindow(), fore_window, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(fore_window, <span class="string">"WinDbg"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(fore_window, <span class="string">"x64_dbg"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(fore_window, <span class="string">"OllyICE"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(fore_window, <span class="string">"OllyDBG"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(fore_window, <span class="string">"Immunity"</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防范这种技术，在OllyDbg的PhantOm插件中勾选hide OllyDbg windows。</p>
<h3 id="查找进程信息"><a href="#查找进程信息" class="headerlink" title="查找进程信息"></a>查找进程信息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD ID;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span>(bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">"OllyDBG.EXE"</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">"OllyICE.exe"</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">"x64_dbg.exe"</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">"windbg.exe"</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">"ImmunityDebugger.exe"</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、识别调试器行为"><a href="#二、识别调试器行为" class="headerlink" title="二、识别调试器行为"></a>二、识别调试器行为</h1><p>在逆向工程中，为了帮助恶意代码分析人员进行分析，可以使用调试器设置一个断点，或是单步执行一个进程。然而，在调试器中执行这些操作时，它们会修改进程中的代码。因此，恶意代码常使用几种反调试技术探测软件/硬件断点、完整性校验、时钟检测等几种类型的调试器行为。直接运行恶意代码与在调试器中运行恶意代码也会在一些细节上不同，如父进程信息、STARTUPINFO信息、SeDebugPrivilege权限等。</p>
<h2 id="1、软件断点检查"><a href="#1、软件断点检查" class="headerlink" title="1、软件断点检查"></a>1、软件断点检查</h2><p>调试器设置断点的基本机制是用软件中断指令INT 3临时替换运行程序中的一条指令，然后当程序运行到这条指令时，调用调试异常处理例程。INT 3指令的机器码是0xCC，因此无论何时，使用调试器设置一个断点，它都会插入一个0xCC来修改代码。恶意代码常用的一种反调试技术是在它的代码中查找机器码0xCC，来扫描调试器对它代码的INT 3修改。repne scasb指令用于在一段数据缓冲区中搜索一个字节。EDI需指向缓冲区地址，AL则包含要找的字节，ECX设为缓冲区的长度。当ECX=0或找到该字节时，比较停止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">    PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">    DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">    pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">    pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + <span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +</span><br><span class="line">                     (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">    DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;</span><br><span class="line">    DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">    BOOL Found = FALSE;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        cld</span><br><span class="line">        mov     edi,dwAddr</span><br><span class="line">        mov     ecx,dwCodeSize</span><br><span class="line">        mov     al,<span class="number">0</span>CCH</span><br><span class="line">        repne   scasb</span><br><span class="line">        jnz     NotFound</span><br><span class="line">        mov Found,<span class="number">1</span></span><br><span class="line">NotFound:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、硬件断点检查"><a href="#2、硬件断点检查" class="headerlink" title="2、硬件断点检查"></a>2、硬件断点检查</h2><p><img src="../res/734571_9GEZ3Y8FGAQ8WA7.jpg" alt="img"></p>
<p>在OllyDbg的寄存器窗口按下右键，点击View debug registers可以看到DR0、DR1、DR2、DR3、DR6和DR7这几个寄存器。DR0、Dr1、Dr2、Dr3用于设置硬件断点，由于只有4个硬件断点寄存器，所以同时最多只能设置4个硬件断点。DR4、DR5由系统保留。  DR6、DR7用于记录Dr0-Dr3中断点的相关属性。如果没有硬件断点，那么DR0、DR1、DR2、DR3这4个寄存器的值都为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTEXT context;</span><br><span class="line">    HANDLE hThread = GetCurrentThread();</span><br><span class="line">    context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">    GetThreadContext(hThread, &amp;context);</span><br><span class="line">    <span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> || context.Dr3!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、执行代码校验和检查"><a href="#3、执行代码校验和检查" class="headerlink" title="3、执行代码校验和检查"></a>3、执行代码校验和检查</h2><p>恶意代码可以计算代码段的校验并实现与扫描中断相同的目的。与扫描0xCC不同，这种检查仅执行恶意代码中机器码CRC或者MD5校验和检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">    PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">    DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">    pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">    pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + <span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +</span><br><span class="line">        (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">    DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;</span><br><span class="line">    DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">    DWORD checksum = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        cld</span><br><span class="line">        mov     esi, dwAddr</span><br><span class="line">        mov     ecx, dwCodeSize</span><br><span class="line">        xor eax, eax</span><br><span class="line">    checksum_loop :</span><br><span class="line">        movzx    ebx, <span class="keyword">byte</span> ptr[esi]</span><br><span class="line">        add        eax, ebx</span><br><span class="line">        rol eax, <span class="number">1</span></span><br><span class="line">        inc esi</span><br><span class="line">        loop       checksum_loop</span><br><span class="line">        mov checksum, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checksum != <span class="number">0x46ea24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、时钟检测"><a href="#4、时钟检测" class="headerlink" title="4、时钟检测"></a>4、时钟检测</h2><p>被调试时，进程的运行速度大大降低，例如，单步调试大幅降低恶意代码的运行速度，所以时钟检测是恶意代码探测调试器存在的最常用方式之一。有如下两种用时钟检测来探测调试器存在的方法。<br>记录一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器。<br>记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。默认情况下，调试器处理异常时需要人为干预，这导致大量延迟。虽然很多调试器允许我们忽略异常，将异常直接返回程序，但这样操作仍然存在不小的延迟。</p>
<h3 id="使用rdtsc指令"><a href="#使用rdtsc指令" class="headerlink" title="使用rdtsc指令"></a>使用rdtsc指令</h3><p>较常用的时钟检测方法是利用rdtsc指令(操作码0x0F31)，它返回至系统重新启动以来的时钟数，并且将其作为一个64位的值存入EDX:EAX中。恶意代码运行两次rdtsc指令，然后比较两次读取之间的差值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD time1, time2;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        rdtsc</span><br><span class="line">        mov time1, eax</span><br><span class="line">        rdtsc</span><br><span class="line">        mov time2, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (time2 - time1 &lt; <span class="number">0xff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用QueryPerformanceCounter和GetTickCount"><a href="#使用QueryPerformanceCounter和GetTickCount" class="headerlink" title="使用QueryPerformanceCounter和GetTickCount"></a>使用QueryPerformanceCounter和GetTickCount</h3><p>同rdtsc指令一样，这两个Windows API函数也被用来执行一个反调试的时钟检测。使用这种方法的前提是处理器有高分辨率能力的计数器-寄存器，它能存储处理器活跃的时钟数。为了获取比较的时间差，调用两次<a href="https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter" target="_blank" rel="noopener">QueryPerformanceCounter</a>函数查询这个计数器。若两次调用之间花费的时间过于长，则可以认为正在使用调试器。<a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount" target="_blank" rel="noopener">GetTickCount</a>函数返回最近系统重启时间与当前时间的相差毫秒数(由于时钟计数器的大小原因，计数器每49.7天就被重置一次)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueryPerformanceCounter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER *lpPerformanceCount</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetTickCount</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD time1 = GetTickCount();</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov     ecx,<span class="number">10</span></span><br><span class="line">        mov     edx,<span class="number">6</span></span><br><span class="line">        mov     ecx,<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time2 = GetTickCount();</span><br><span class="line">    <span class="keyword">if</span> (time2-time1 &gt; <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、判断父进程是否是explorer-exe"><a href="#5、判断父进程是否是explorer-exe" class="headerlink" title="5、判断父进程是否是explorer.exe"></a>5、判断父进程是否是explorer.exe</h2><p>一般双击运行的进程的父进程都是explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是explorer.exe则可以认为程序正在被调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LONG                      status;</span><br><span class="line">    DWORD                     dwParentPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE                    hProcess;</span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span>(!hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PNTQUERYINFORMATIONPROCESS  NtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandleA(<span class="string">"ntdll"</span>),<span class="string">"NtQueryInformationProcess"</span>);</span><br><span class="line">    status = NtQueryInformationProcess(hProcess,SystemBasicInformation,(PVOID)&amp;pbi,<span class="keyword">sizeof</span>(PROCESS_BASIC_INFORMATION),<span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span>(bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">"explorer.exe"</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、判断STARTUPINFO信息"><a href="#6、判断STARTUPINFO信息" class="headerlink" title="6、判断STARTUPINFO信息"></a>6、判断STARTUPINFO信息</h2><p>explorer.exe创建进程的时候会把<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa" target="_blank" rel="noopener">STARTUPINFO</a>结构中的值设为0，而非explorer.exe创建进程的时候会忽略这个结构中的值，也就是结构中的值不为0。所以可以利用STARTUPINFO来判断程序是否在被调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">  DWORD  cb;</span><br><span class="line">  LPSTR  lpReserved;</span><br><span class="line">  LPSTR  lpDesktop;</span><br><span class="line">  LPSTR  lpTitle;</span><br><span class="line">  DWORD  dwX;</span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;</span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;</span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  WORD   wShowWindow;</span><br><span class="line">  WORD   cbReserved2;</span><br><span class="line">  LPBYTE lpReserved2;</span><br><span class="line">  HANDLE hStdInput;</span><br><span class="line">  HANDLE hStdOutput;</span><br><span class="line">  HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    GetStartupInfo(&amp;si);</span><br><span class="line">    <span class="keyword">if</span> (si.dwX!=<span class="number">0</span> || si.dwY!=<span class="number">0</span> || si.dwFillAttribute!=<span class="number">0</span> || si.dwXSize!=<span class="number">0</span> || si.dwYSize!=<span class="number">0</span> || si.dwXCountChars!=<span class="number">0</span> || si.dwYCountChars!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、判断是否具有SeDebugPrivilege权限"><a href="#7、判断是否具有SeDebugPrivilege权限" class="headerlink" title="7、判断是否具有SeDebugPrivilege权限"></a>7、判断是否具有SeDebugPrivilege权限</h2><p>默认情况下进程是没有<a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants" target="_blank" rel="noopener">SeDebugPrivilege</a>权限的，但是当进程通过调试器启动时，由于调试器本身启动了SeDebugPrivilege权限，当调试进程被加载时SeDebugPrivilege也就被继承了。所以我们可以检测进程的SeDebugPrivilege权限来间接判断是否存在调试器，而对SeDebugPrivilege权限的判断可以用能否打开csrss.exe进程来判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD ID;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span>(bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pe32.szExeFile, <span class="string">"csrss.exe"</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ID = pe32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    <span class="keyword">if</span> (OpenProcess(PROCESS_QUERY_INFORMATION, <span class="literal">NULL</span>, ID) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、干扰调试器的功能"><a href="#三、干扰调试器的功能" class="headerlink" title="三、干扰调试器的功能"></a>三、干扰调试器的功能</h1><p>恶意代码可以用一些技术来干扰调试器的正常运行。例如线程本地存储(TLS)回调、插入中断、异常等。这些技术当且仅当程序处于调试器控制之下时才试图扰乱程序的运行</p>
<h2 id="1、使用TLS回调"><a href="#1、使用TLS回调" class="headerlink" title="1、使用TLS回调"></a>1、使用TLS回调</h2><p>Thread Local Storage(TLS)，即线程本地存储，是Windows为解决一个进程中多个线程同时访问全局变量而提供的机制。TLS可以简单地由操作系统代为完成整个互斥过程，也可以由用户自己编写控制信号量的函数。当进程中的线程访问预先制定的内存空间时，操作系统会调用系统默认的或用户自定义的信号量函数，保证数据的完整性与正确性。下面是一个简单的TLS回调的例子，TLS_CALLBACK1函数在main函数执行前调用IsDebuggerPresent函数检查它是否正在被调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NTAPI __<span class="function">stdcall <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _M_IX86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:__tls_used"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:__tls_callback"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:_tls_used"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:_tls_callback"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _M_X64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg (<span class="meta-string">".CRT$XLB"</span>)</span></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg (<span class="meta-string">".CRT$XLB"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; TLS_CALLBACK1,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg ()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NTAPI __<span class="function">stdcall <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsDebuggerPresent())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLS_CALLBACK: Debugger Detected!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLS_CALLBACK: No Debugger Present!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"233\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在程序中使用TLS，必须为TLS数据单独建一个数据段，用相关数据填充此段，并通知链接器为TLS数据在PE文件头中添加数据。_tls_callback[]数组中保存了所有的TLS回调函数指针。数组必须以NULL指针结束，且数组中的每一个回调函数在程序初始化时都会被调用，程序员可按需要添加。但程序员不应当假设操作系统已何种顺序调用回调函数。如此则要求在TLS回调函数中进行反调试操作需要一定的独立性。<br>正常运行这个程序会打印下面的内容。<br>TLS_CALLBACK: No Debugger Present!<br>233<br>如果把在OllyDbg中运行，在OllyDbg暂停之前会打印下面的内容。<br>TLS_CALLBACK: Debugger Detected!<br>使用PEview查看.tls段，可以发现TLS回调函数。通常情况下，正常程序不使用.tls段，如果在可执行程序中看到.tls段，应该立即怀疑它使用了反调试技术。</p>
<p><img src="../res/734571_BZDANDDPZ3HN68Q.jpg" alt="img"></p>
<p>在OllyDbg中选择Options-&gt;Debugging Options-&gt;Events，然后设置System break-point作为第一个暂停的位置，这样就可以让OllyDbg在TLS回调执行前暂停。</p>
<p><img src="../res/734571_VT82HFSA5HUWDUB.jpg" alt="img"></p>
<p>在IDA Pro中按Ctrl+E快捷键看到二进制的入口点，该组合键的作用是显示应用程序所有的入口点，其中包括TLS回调。双击函数名可以浏览回调函数。</p>
<p><img src="../res/734571_QUBDAXKP2E7UFQC.jpg" alt="img"></p>
<p>由于TLS回调已广为人知，因此同过去相比，恶意代码使用它的次数已经明显减少。为数不多的合法程序使用TLS回调，所以可执行程序中的.tls段特别突出。</p>
<h2 id="2、利用中断"><a href="#2、利用中断" class="headerlink" title="2、利用中断"></a>2、利用中断</h2><p>因为调试器使用INT 3来设置软件断点，所以一种反调试技术就是在合法代码段中插入0xCC(INT 3)欺骗调试器，使其认为这些0xCC机器码是自己设置的断点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      __try</span><br><span class="line">      &#123;</span><br><span class="line">            __asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">      __except(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用_try和_except以外还可以直接使用汇编代码安装SEH。在下面的代码中如果进程没有处于调试中，则正常终止；如果进程处于调试中，则跳转到非法地址0xFFFFFFFF处，无法继续调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AD_BreakPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SEH : BreakPoint\n"</span>);</span><br><span class="line"></span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">// install SEH</span></span><br><span class="line">        push handler</span><br><span class="line">        push DWORD ptr fs:[<span class="number">0</span>]</span><br><span class="line">        mov DWORD ptr fs:[<span class="number">0</span>], esp</span><br><span class="line"></span><br><span class="line">        <span class="comment">// generating exception</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) debugging</span></span><br><span class="line">        <span class="comment">//    go to terminating code</span></span><br><span class="line">        mov eax, <span class="number">0xFFFFFFFF</span></span><br><span class="line">        jmp eax                 <span class="comment">// process terminating!!!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) not debugging</span></span><br><span class="line">        <span class="comment">//    go to normal code</span></span><br><span class="line">handler:</span><br><span class="line">        mov eax, dword ptr ss:[esp+<span class="number">0xc</span>]</span><br><span class="line">        mov ebx, normal_code</span><br><span class="line">        mov dword ptr ds:[eax+<span class="number">0xb8</span>], ebx</span><br><span class="line">        xor eax, eax</span><br><span class="line">        retn</span><br><span class="line"></span><br><span class="line">normal_code:</span><br><span class="line">        <span class="comment">//   remove SEH</span></span><br><span class="line">        pop dword ptr fs:[<span class="number">0</span>]</span><br><span class="line">        add esp, <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  =&gt; Not debugging...\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    AD_BreakPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双字节操作码0xCD03也可以产生INT 3中断，这是恶意代码干扰WinDbg调试器的有效方法。在调试器外，0xCD03指令产生一个STATUS_BREAKPOINT异常。然而在WinDbg调试器内，由于断点通常是单字节机器码0xCC，因此WinDbg会捕获这个断点然后将EIP加1字节。这可能导致程序在被正常运行的WinDbg调试时，执行不同的指令集(OllyDbg可以避免双字节INT 3的攻击)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      __try</span><br><span class="line">      &#123;</span><br><span class="line">            __asm</span><br><span class="line">            &#123;</span><br><span class="line">                  __emit <span class="number">0xCD</span></span><br><span class="line">                  __emit <span class="number">0x03</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      __except(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>INT 2D原为内核模式中用来触发断点异常的指令，也可以在用户模式下触发异常。但程序调试运行时不会触发异常，只是忽略。INT 2D指令在ollydbg中有两个有趣的特性。在调试模式中执行INT 2D指令，下一条指令的第一个字节将被忽略。使用StepInto(F7)或者StepOver(F8)命令跟踪INT 2D指令，程序不会停在下一条指令开始的地方，而是一直运行，就像RUN(F9)一样。在下面的代码中，程序调试运行时，执行INT 2D之后不会运行SEH，而是跳过NOP，把bDebugging标志设置为1，跳转到normal_code；程序正常运行时，执行INT 2D之后触发SEH，在异常处理器中设置EIP并把bDebugging标志设置为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bDebugging = FALSE;</span><br><span class="line"></span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">// install SEH</span></span><br><span class="line">        push handler</span><br><span class="line">        push DWORD ptr fs:[<span class="number">0</span>]</span><br><span class="line">        mov DWORD ptr fs:[<span class="number">0</span>], esp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="number">0x2d</span></span><br><span class="line"></span><br><span class="line">        nop</span><br><span class="line">        mov bDebugging, <span class="number">1</span></span><br><span class="line">        jmp normal_code</span><br><span class="line"></span><br><span class="line">handler:</span><br><span class="line">        mov eax, dword ptr ss:[esp+<span class="number">0xc</span>]</span><br><span class="line">        mov dword ptr ds:[eax+<span class="number">0xb8</span>], offset normal_code</span><br><span class="line">        mov bDebugging, <span class="number">0</span></span><br><span class="line">        xor eax, eax</span><br><span class="line">        retn</span><br><span class="line"></span><br><span class="line">normal_code:</span><br><span class="line">        <span class="comment">//   remove SEH</span></span><br><span class="line">        pop dword ptr fs:[<span class="number">0</span>]</span><br><span class="line">        add esp, <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Trap Flag (INT 2D)\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>( bDebugging )  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片内仿真器(ICE)断点指令ICEBP(操作码0xF1)是Intel未公开的指令之一。由于使用ICE难以在任意位置设置断点，因此ICEBP指令被设计用来降低使用ICE设置断点的难度。运行ICEBP指令将会产生一个单步异常，如果通过单步调试跟踪程序，调试器会认为这是单步调试产生的异常，从而不执行先前设置的异常处理例程。利用这一点，恶意代码使用异常处理例程作为它的正常执行流程。为了防止这种反调试技术，执行ICEBP指令时不要使用单步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      __try</span><br><span class="line">      &#123;</span><br><span class="line">            __asm __emit <span class="number">0xF1</span></span><br><span class="line">      &#125;</span><br><span class="line">      __except(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、设置陷阱标志位"><a href="#3、设置陷阱标志位" class="headerlink" title="3、设置陷阱标志位"></a>3、设置陷阱标志位</h2><p>EFLAGS寄存器的第八个比特位是陷阱标志位。如果设置了，就会产生一个单步异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      __try</span><br><span class="line">      &#123;</span><br><span class="line">            __asm</span><br><span class="line">            &#123;</span><br><span class="line">                  pushfd</span><br><span class="line">                  <span class="keyword">or</span> <span class="keyword">word</span> ptr[esp], <span class="number">0x100</span></span><br><span class="line">                  popfd</span><br><span class="line">                  nop</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      __except(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、使用异常"><a href="#4、使用异常" class="headerlink" title="4、使用异常"></a>4、使用异常</h2><h3 id="RaiseException"><a href="#RaiseException" class="headerlink" title="RaiseException"></a>RaiseException</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception" target="_blank" rel="noopener">RaiseException</a>函数产生的若干不同类型的异常可以被调试器捕获</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">analysis_noreturn VOID <span class="title">RaiseException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD           dwExceptionCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD           dwExceptionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD           nNumberOfArguments,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> ULONG_PTR *lpArguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TestExceptionCode</span><span class="params">(DWORD dwCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      __try</span><br><span class="line">      &#123;</span><br><span class="line">            RaiseException(dwCode, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      __except(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> TestExceptionCode(DBG_RIPEXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetUnhandledExceptionFilter"><a href="#SetUnhandledExceptionFilter" class="headerlink" title="SetUnhandledExceptionFilter"></a>SetUnhandledExceptionFilter</h3><p>进程中发生异常时若SEH未处理或注册的SEH不存在，会调用UnhandledExceptionFilter，它会运行系统最后的异常处理器。UnhandledExceptionFilter内部调用了前面提到过的NtQueryInformationProcess以判断是否正在调试进程。若进程正常运行，则运行最后的异常处理器；若进程处于调试，则将异常派送给调试器。<a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter" target="_blank" rel="noopener">SetUnhandledExceptionFilter</a>函数可以修改系统最后的异常处理器。下面的代码先触发异常，然后在新注册的最后的异常处理器内部判断进程正常运行还是调试运行。进程正常运行时pExcept-&gt;ContextRecord-&gt;Eip+=4;将发生异常的代码地址加4使得其能够继续运行；进程调试运行时产生无效的内存访问异常，从而无法继续调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LPTOP_LEVEL_EXCEPTION_FILTER <span class="title">SetUnhandledExceptionFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line">LPVOID g_pOrgFilter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG WINAPI <span class="title">ExceptionFilter</span><span class="params">(PEXCEPTION_POINTERS pExcept)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)g_pOrgFilter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8900    MOV DWORD PTR DS:[EAX], EAX</span></span><br><span class="line">    <span class="comment">// FFE0    JMP EAX</span></span><br><span class="line">    pExcept-&gt;ContextRecord-&gt;Eip += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AD_SetUnhandledExceptionFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SEH : SetUnhandledExceptionFilter()\n"</span>);</span><br><span class="line"></span><br><span class="line">    g_pOrgFilter = (LPVOID)SetUnhandledExceptionFilter(</span><br><span class="line">                                (LPTOP_LEVEL_EXCEPTION_FILTER)ExceptionFilter);</span><br><span class="line"></span><br><span class="line">    __asm &#123;</span><br><span class="line">        xor eax, eax;</span><br><span class="line">        mov dword ptr [eax], eax</span><br><span class="line">        jmp eax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  =&gt; Not debugging...\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    AD_SetUnhandledExceptionFilter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在OllyDbg中，选择Options-&gt;Debugging Options-&gt;Exceptions来设置把异常传递给应用程序。</p>
<p><img src="../res/734571_Z2ZU7ZPKANY4YE8.jpg" alt="img"></p>
<h1 id="四、调试器漏洞"><a href="#四、调试器漏洞" class="headerlink" title="四、调试器漏洞"></a>四、调试器漏洞</h1><p>与所有软件一样，调试器也存在漏洞，有时恶意代码编写者为了防止被调试，会攻击这些漏洞。这里我们展示几种OllyDbg调试器处理PE格式文件时的常见漏洞。</p>
<h2 id="1、PE头漏洞"><a href="#1、PE头漏洞" class="headerlink" title="1、PE头漏洞"></a>1、PE头漏洞</h2><p>OllyDbg非常严格地遵循了微软对PE文件头部的规定。在PE文件的头部，通常存在一个叫作IMAGE_OPTIONAL_HEADER的结构。</p>
<p><img src="../res/734571_36ZKBK3D5VTH4FZ.jpg" alt="img"></p>
<p>需要特别注意这个结构中的最后几个元素。NumberOfRvaAndSizes属性标识后面DataDirectory数组中的元素个数。DataDirectory数组表示在这个可执行文件中的什么地方可找到其他导入可执行模块的位置，它位于可选头部结构的末尾，是一个比IMAGE_DATA_DIRECTORY略大一些的数组。数组中每个结构目录都指明了目录的相对虚拟地址和大小。DataDirectory数组的大小被设置为IMAGE_NUMBEROF_DIRECTORY_ENTRIES，它等于0x10。因为DataDirectory数组不足以容纳超过0x10个目录项，所以当NumberOfRvaAndSizes大于0x10时，Windows加载器将会忽略NumberOfRvaAndSizes。OllyDbg遵循了这个标准，并且无论NumberOfRvaAndSizes是什么值，OllyDbg都使用它。因此，设置NumberOfRvaAndSizes为一个超过0x10的值，会导致在程序退出前，OllyDbg对用户弹出一个窗口。如图所示，使用LordPE打开可执行文件，修改RVA数及大小并保存，再用OllyDbg打开，会提示错误Bad or unknown format of 32-bit executable file。</p>
<p><img src="../res/734571_EVCXQN95Z2APNTP.png" alt="img"></p>
<p><img src="../res/734571_Y9URZ32MHJMCBE4.png" alt="img"></p>
<p>另一种PE头的欺骗与节头部有关。文件内容中包含的节包括代码节、数据节、资源节，以及一些其他信息节。每个节都拥有一个IMAGE_SECTION_HEADER结构的头部。</p>
<p><img src="../res/734571_BPAGXVTE95Q8C5E.png" alt="img"></p>
<p>VirtualSize和SizeOfRawData是其中两个比较重要的属性。根据微软对PE的规定，VirtualSize应该包含载入到内存的节大小，SizeOfRawData应该包含节在硬盘中的大小。Windows加载器使用VirtualSize和SizeOfRawData中的最小值将节数据映射到内存。如果SizeOfRawData大于VirtualSize，则仅将VirtualSize大小的数据复制入内存，忽略其余数据。因为OllyDbg仅使用SizeOfRawData，所以设置SizeOfRawData为一个类似0x77777777的大数值时，会导致OllyDbg崩溃。如图所示，使用LordPE打开可执行文件，点击区段，在区段表上右击，点击编辑区段，修改物理大小并保存，再用OllyDbg打开，会提示同样的错误</p>
<p><img src="../res/734571_HCU8CAXT5RH7R4J.png" alt="img"></p>
<h2 id="2、OutputDebugString漏洞"><a href="#2、OutputDebugString漏洞" class="headerlink" title="2、OutputDebugString漏洞"></a>2、OutputDebugString漏洞</h2><p>恶意代码常尝试利用OllyDbg1.1的格式化字符串漏洞，为OutputDebugString函数提供一个%s字符串的参数，让OllyDbg崩溃。因此，需要注意程序中可疑的OutputDebugString调用，例如OutputDebugString(“%s%s%s%s%s%s%s%s%s”)。如果执行了这个调用，OllyDbg将会崩溃。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>最后让我们总结一下提到的内容。腾讯2016游戏安全技术竞赛有一道题，大概意思就是给一个exe，要求编写一个Tencent2016D.dll，并导出多个接口函数CheckDebugX。X为1-100之间的数字，比如CheckDebug1，CheckDebug8，…，CheckDebug98。函数功能是检测自己是否处于被调试状态，是返回TRUE，否则返回FALSE。函数的原型都是typedef BOOL (WINAPI* Type_CheckDebug)();。编译好dll之后，放在Tencent2016D.exe的同目录，运行Tencent2016D.exe，点击检测按钮，正常运行时，函数接口输出为0，调试运行或者被附加运行时，接口输出1。我们把提到的知识综合一下完成这道题目。<br>解题的参考代码和题目相关信息：<a href="https://github.com/houjingyi233/test-debug/" target="_blank" rel="noopener">https://github.com/houjingyi233/test-debug/</a></p>
<p>参考资料：</p>
<p>1.《恶意代码分析实战》第16章反调试技术(本文的主体框架)</p>
<p>2.《逆向工程核心原理》第51章静态反调试技术&amp;第52章动态反调试技术</p>
<p>3.<a href="http://www.freebuf.com/articles/terminal/99454.html" target="_blank" rel="noopener">技术分享：利用异常实现反调试</a></p>
<p>4.<a href="http://www.buptdubhe.com/" target="_blank" rel="noopener">天枢战队官方博客</a>(本文大部分代码的来源)</p>
<p>5.<a href="http://lilxam.free.fr/repo/Cracking/Anti-Debugging/Windows%20Anti-Debug%20Reference.pdf" target="_blank" rel="noopener">windows anti-debugger reference</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Windows/" rel="tag"># Windows</a>
              <a href="/tags/%E9%80%86%E5%90%91/" rel="tag"># 逆向</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Windows/Windows%E5%8F%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF.html" rel="next" title="Windows反虚拟机技术">
                  <i class="fa fa-chevron-left"></i> Windows反虚拟机技术
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/Android/%E5%9C%A8%E5%AE%89%E5%8D%93%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5.html" rel="prev" title="在安卓中进行共享库的注入">
                  在安卓中进行共享库的注入 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、探测调试器"><span class="nav-number">1.</span> <span class="nav-text">一、探测调试器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、使用Windows-API"><span class="nav-number">1.1.</span> <span class="nav-text">1、使用Windows API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IsDebuggerPresent"><span class="nav-number">1.1.1.</span> <span class="nav-text">IsDebuggerPresent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CheckRemoteDebuggerPresent"><span class="nav-number">1.1.2.</span> <span class="nav-text">CheckRemoteDebuggerPresent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NtQueryInformationProcess"><span class="nav-number">1.1.3.</span> <span class="nav-text">NtQueryInformationProcess</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GetLastError"><span class="nav-number">1.1.4.</span> <span class="nav-text">GetLastError</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZwSetInformationThread"><span class="nav-number">1.1.5.</span> <span class="nav-text">ZwSetInformationThread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、手动检测数据结构"><span class="nav-number">1.2.</span> <span class="nav-text">2、手动检测数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测BeingDebugged属性"><span class="nav-number">1.2.1.</span> <span class="nav-text">检测BeingDebugged属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测ProcessHeap属性"><span class="nav-number">1.2.2.</span> <span class="nav-text">检测ProcessHeap属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测NTGlobalFlag"><span class="nav-number">1.2.3.</span> <span class="nav-text">检测NTGlobalFlag</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、系统痕迹检测"><span class="nav-number">1.3.</span> <span class="nav-text">3、系统痕迹检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找调试器引用的注册表项"><span class="nav-number">1.3.1.</span> <span class="nav-text">查找调试器引用的注册表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找窗体信息"><span class="nav-number">1.3.2.</span> <span class="nav-text">查找窗体信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找进程信息"><span class="nav-number">1.3.3.</span> <span class="nav-text">查找进程信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、识别调试器行为"><span class="nav-number">2.</span> <span class="nav-text">二、识别调试器行为</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、软件断点检查"><span class="nav-number">2.1.</span> <span class="nav-text">1、软件断点检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、硬件断点检查"><span class="nav-number">2.2.</span> <span class="nav-text">2、硬件断点检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、执行代码校验和检查"><span class="nav-number">2.3.</span> <span class="nav-text">3、执行代码校验和检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、时钟检测"><span class="nav-number">2.4.</span> <span class="nav-text">4、时钟检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用rdtsc指令"><span class="nav-number">2.4.1.</span> <span class="nav-text">使用rdtsc指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用QueryPerformanceCounter和GetTickCount"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用QueryPerformanceCounter和GetTickCount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、判断父进程是否是explorer-exe"><span class="nav-number">2.5.</span> <span class="nav-text">5、判断父进程是否是explorer.exe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、判断STARTUPINFO信息"><span class="nav-number">2.6.</span> <span class="nav-text">6、判断STARTUPINFO信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、判断是否具有SeDebugPrivilege权限"><span class="nav-number">2.7.</span> <span class="nav-text">7、判断是否具有SeDebugPrivilege权限</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、干扰调试器的功能"><span class="nav-number">3.</span> <span class="nav-text">三、干扰调试器的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、使用TLS回调"><span class="nav-number">3.1.</span> <span class="nav-text">1、使用TLS回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、利用中断"><span class="nav-number">3.2.</span> <span class="nav-text">2、利用中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、设置陷阱标志位"><span class="nav-number">3.3.</span> <span class="nav-text">3、设置陷阱标志位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、使用异常"><span class="nav-number">3.4.</span> <span class="nav-text">4、使用异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RaiseException"><span class="nav-number">3.4.1.</span> <span class="nav-text">RaiseException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetUnhandledExceptionFilter"><span class="nav-number">3.4.2.</span> <span class="nav-text">SetUnhandledExceptionFilter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、调试器漏洞"><span class="nav-number">4.</span> <span class="nav-text">四、调试器漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、PE头漏洞"><span class="nav-number">4.1.</span> <span class="nav-text">1、PE头漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、OutputDebugString漏洞"><span class="nav-number">4.2.</span> <span class="nav-text">2、OutputDebugString漏洞</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、总结"><span class="nav-number">5.</span> <span class="nav-text">五、总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gowa2017 Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">286</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">106</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gowa2017" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gowa2017" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mailto:shouzheng.zhang@gmail.com" title="E-Mail → mailto:shouzheng.zhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-json"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gowa2017 Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>














  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gowa-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://gowa.club/Windows/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.html",
            identifier: "Windows/Windows反调试技术.html",
            title: "Windows反调试技术"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gowa-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
</script>

</body>
</html>
